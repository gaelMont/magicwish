// hooks/useTradeSystem.ts
import { useState, useEffect } from 'react';
import { db } from '@/lib/firebase';
import { 
  collection, addDoc, query, where, onSnapshot, 
  doc, updateDoc, serverTimestamp, orderBy 
} from 'firebase/firestore';
import { useAuth } from '@/lib/AuthContext';
import { CardType } from './useCardCollection';
import { useTradeTransaction } from './useTradeTransaction';
import toast from 'react-hot-toast';

export type TradeStatus = 'pending' | 'completed' | 'rejected' | 'cancelled';

export type TradeRequest = {
  id: string;
  senderUid: string;
  senderName: string;
  receiverUid: string;
  receiverName: string;
  itemsGiven: CardType[];    // Ce que le sender DONNE
  itemsReceived: CardType[]; // Ce que le sender REÇOIT
  status: TradeStatus;
  createdAt: any;
};

export function useTradeSystem() {
  const { user, username } = useAuth();
  const { executeTrade, isProcessing: isTransacting } = useTradeTransaction();
  
  const [incomingTrades, setIncomingTrades] = useState<TradeRequest[]>([]);
  const [outgoingTrades, setOutgoingTrades] = useState<TradeRequest[]>([]);
  const [loading, setLoading] = useState(true);

  // 1. Écouter les échanges (Entrants et Sortants)
  useEffect(() => {
    if (!user) return;

    // A. Échanges que je reçois (Je dois accepter/refuser)
    const qIn = query(
      collection(db, 'trades'),
      where('receiverUid', '==', user.uid),
      where('status', '==', 'pending'),
      orderBy('createdAt', 'desc')
    );

    // B. Échanges que j'ai envoyés (Je peux annuler)
    const qOut = query(
      collection(db, 'trades'),
      where('senderUid', '==', user.uid),
      where('status', '==', 'pending'),
      orderBy('createdAt', 'desc')
    );

    const unsubIn = onSnapshot(qIn, (snap) => {
      setIncomingTrades(snap.docs.map(d => ({ id: d.id, ...d.data() } as TradeRequest)));
    });

    const unsubOut = onSnapshot(qOut, (snap) => {
      setOutgoingTrades(snap.docs.map(d => ({ id: d.id, ...d.data() } as TradeRequest)));
      setLoading(false);
    });

    return () => { unsubIn(); unsubOut(); };
  }, [user]);

  // 2. Créer une proposition (Action du Sender)
  const proposeTrade = async (receiverUid: string, receiverName: string, toGive: CardType[], toReceive: CardType[]) => {
    if (!user) return;
    const toastId = toast.loading("Envoi de la proposition...");

    try {
      await addDoc(collection(db, 'trades'), {
        senderUid: user.uid,
        senderName: username || user.displayName || 'Inconnu',
        receiverUid,
        receiverName,
        itemsGiven: toGive,
        itemsReceived: toReceive,
        status: 'pending',
        createdAt: serverTimestamp()
      });
      toast.success("Proposition envoyée !", { id: toastId });
      return true;
    } catch (e) {
      console.error(e);
      toast.error("Erreur envoi", { id: toastId });
      return false;
    }
  };

  // 3. Accepter l'échange (Action du Receiver) - C'est ici que la transaction se fait !
  const acceptTrade = async (trade: TradeRequest) => {
    if (!user) return;

    // ATTENTION A L'INVERSION : 
    // Pour le Sender (créateur), itemsGiven c'est ce qu'il donne.
    // Pour Moi (Receiver), itemsGiven c'est ce que je REÇOIS.
    
    // executeTrade(MesCartesADonner, CartesQueJeRecois, ID_Partenaire)
    // MesCartesADonner = trade.itemsReceived (celles que le sender voulait recevoir de moi)
    // CartesQueJeRecois = trade.itemsGiven (celles que le sender me donne)
    
    const success = await executeTrade(
        trade.itemsReceived, // Je donne ce qu'il a demandé
        trade.itemsGiven,    // Je reçois ce qu'il a proposé
        trade.senderUid      // Le partenaire est l'envoyeur
    );

    if (success) {
      // Si la transaction DB a réussi, on marque l'échange comme terminé
      await updateDoc(doc(db, 'trades', trade.id), { status: 'completed' });
    }
  };

  // 4. Refuser ou Annuler
  const rejectTrade = async (tradeId: string) => {
    if(!confirm("Refuser cet échange ?")) return;
    await updateDoc(doc(db, 'trades', tradeId), { status: 'rejected' });
    toast.success("Échange refusé");
  };

  const cancelTrade = async (tradeId: string) => {
    if(!confirm("Annuler cette proposition ?")) return;
    await updateDoc(doc(db, 'trades', tradeId), { status: 'cancelled' });
    toast.success("Proposition annulée");
  };

  return { 
    incomingTrades, outgoingTrades, loading, 
    proposeTrade, acceptTrade, rejectTrade, cancelTrade,
    isProcessing: isTransacting 
  };
}