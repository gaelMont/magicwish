This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.firebaserc
.gitignore
app/actions/admin.ts
app/actions/chat.ts
app/actions/collection.ts
app/actions/export.ts
app/actions/friends.ts
app/actions/game.ts
app/actions/groups.ts
app/actions/import.ts
app/actions/lists.ts
app/actions/matching.ts
app/actions/scanner.ts
app/actions/stats.ts
app/actions/trade-proposal.ts
app/actions/trade.ts
app/actions/wishlist.ts
app/admin/page.tsx
app/ads-validation/page.tsx
app/api/cron/cleanup-users/route.ts
app/api/feedback/route.ts
app/api/portal/route.ts
app/api/search/route.ts
app/api/webhook/stripe/route.ts
app/card/[id]/page.tsx
app/collection/page.tsx
app/contacts/page.tsx
app/favicon.ico
app/globals.css
app/groups/page.tsx
app/layout.tsx
app/login/page.tsx
app/mentions-legales/page.tsx
app/page.tsx
app/politique-confidentialite/page.tsx
app/premium/page.tsx
app/pricing/page.tsx
app/search/page.tsx
app/settings/page.tsx
app/stats/page.tsx
app/trades/history/page.tsx
app/trades/manual/page.tsx
app/trades/new/[uid]/page.tsx
app/trades/page.tsx
app/user/[uid]/page.tsx
app/wishlist/page.tsx
components/AdContainer.tsx
components/auth/VerificationBlocker.tsx
components/card-page/CardMainDetails.tsx
components/card-page/CardVersionsGrid.tsx
components/card-page/DualQuantityManager.tsx
components/CardmarketExportModal.tsx
components/CardVersionPickerModal.tsx
components/chat/ChatWindow.tsx
components/collection/CollectionToolbar.tsx
components/CollectionToolsModal.tsx
components/CollectionTransferModal.tsx
components/ColumnSlider.tsx
components/common/CardListFilterBar.tsx
components/ConfirmModal.tsx
components/CreditsDisplay.tsx
components/DataTransferHubModal.tsx
components/DeleteAllButton.tsx
components/ExportModal.tsx
components/Footer.tsx
components/Header.tsx
components/ImportModal.tsx
components/LockedListModal.tsx
components/magic-card/CardImage.tsx
components/magic-card/CardPrice.tsx
components/magic-card/CardQuantity.tsx
components/magic-card/CardTags.tsx
components/magic-card/CardTradeQuantity.tsx
components/MagicCard.tsx
components/search/SearchToolbar.tsx
components/StripeButton.tsx
components/ThemeProvider.tsx
components/ThemeToggle.tsx
components/trades/TradeSelectionTable.tsx
components/trades/TradeSourceTable.tsx
components/user-profile/FriendCollectionDisplay.tsx
components/user-profile/FriendWishlistDisplay.tsx
components/UsernameSetupModal.tsx
components/wishlist/GlobalWishlistView.tsx
components/wishlist/SingleWishlistView.tsx
components/wishlist/WishlistToolbar.tsx
eslint.config.mjs
firebase.json
firestore.indexes.json
firestore.rules
hooks/useAggregatedCards.ts
hooks/useCardCollection.ts
hooks/useChat.ts
hooks/useCollections.ts
hooks/useColumnPreference.ts
hooks/useDebounceUpdate.ts
hooks/useFriends.ts
hooks/usePremium.ts
hooks/useSortPreference.ts
hooks/useTradeMatcher.ts
hooks/useTradeSystem.ts
hooks/useWishlists.ts
lib/AuthContext.tsx
lib/cardUtils.ts
lib/firebase-admin.ts
lib/firebase.ts
lib/globals.d.ts
lib/importRules.ts
lib/limits.ts
lib/services/collectionService.ts
lib/types.ts
lib/types/chat.ts
lib/validators.ts
next.config.ts
package.json
postcss.config.mjs
public/ads.txt
public/file.svg
public/globe.svg
public/manifest.json
public/next.svg
public/vercel.svg
public/window.svg
README.md
tsconfig.json
vercel.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="app/actions/export.ts">
// app/actions/export.ts
'use server';

import { checkAndConsumeCredits } from '@/lib/limits';

type ActionResponse = {
    success: boolean;
    error?: string;
};

/**
 * D√©bite un cr√©dit pour l'export.
 * Cette action doit √™tre appel√©e par le client AVANT de lancer la g√©n√©ration du CSV.
 */
export async function deductExportCreditAction(userId: string): Promise<ActionResponse> {
    const result = await checkAndConsumeCredits(userId, 'EXPORT');
    
    if (!result.allowed) {
        return { success: false, error: result.error };
    }

    return { success: true };
}
</file>

<file path="app/actions/lists.ts">
// app/actions/lists.ts
'use server';

import { getAdminFirestore } from '@/lib/firebase-admin';
import { FieldValue } from 'firebase-admin/firestore';
import { canCreateNewList } from '@/lib/limits';
import { z } from 'zod';

const createListSchema = z.object({
  userId: z.string().min(1),
  listName: z.string().min(3).max(50),
  type: z.enum(['collection', 'wishlist']),
});

type ActionResponse = {
  success: boolean;
  error?: string;
  listId?: string;
};

export async function createListAction(userId: string, listName: string, type: 'collection' | 'wishlist'): Promise<ActionResponse> {
  const db = getAdminFirestore();

  const validation = createListSchema.safeParse({ userId, listName, type });
  if (!validation.success) {
    return { success: false, error: validation.error.issues[0].message };
  }

  try {
    // 1. V√©rifier la limite Freemium
    // Appelle la fonction mise √† jour qui accepte (userId, type)
    const limitCheck = await canCreateNewList(userId, type);
    
    if (!limitCheck.allowed) {
      return { success: false, error: limitCheck.error };
    }

    // 2. Cr√©ation de la liste
    // Note : On utilise la m√™me logique de nommage que dans canCreateNewList pour la coh√©rence
    const collectionName = type === 'collection' ? 'collections_meta' : 'wishlists_meta';
    
    const newListRef = await db.collection('users').doc(userId).collection(collectionName).add({
      name: listName,
      createdAt: FieldValue.serverTimestamp(),
      updatedAt: FieldValue.serverTimestamp(),
      itemCount: 0, // Initialisation utile pour l'affichage
      type: type // Stocker le type explicitement peut aider pour le debugging
    });

    return { success: true, listId: newListRef.id };
  } catch (e) {
    console.error("Erreur createListAction:", e);
    const errorMessage = e instanceof Error ? e.message : "Erreur technique";
    return { success: false, error: errorMessage };
  }
}
</file>

<file path="app/pricing/page.tsx">
// app/pricing/page.tsx
import Link from 'next/link';
import { Check, Zap, Infinity } from 'lucide-react';
import StripeButton from '@/components/StripeButton'; // Import du composant partag√©

export default function PricingPage() {
  return (
    <div className="min-h-screen bg-slate-50 py-12 px-4 sm:px-6 lg:px-8">
      <div className="max-w-7xl mx-auto">
        <div className="text-center mb-12">
          <h1 className="text-3xl font-extrabold text-slate-900 sm:text-4xl">
            Passez au niveau sup√©rieur
          </h1>
          <p className="mt-4 text-xl text-slate-600">
            Lib√©rez tout le potentiel de votre collection pour le prix d&apos;un caf√©.
          </p>
        </div>

        <div className="grid md:grid-cols-2 gap-8 max-w-4xl mx-auto">
          {/* Plan Gratuit */}
          <div className="bg-white rounded-2xl shadow-sm border border-slate-200 p-8 flex flex-col relative overflow-hidden">
            <div className="mb-4">
              <h3 className="text-xl font-semibold text-slate-900">D√©couverte</h3>
              <p className="text-slate-500 mt-2">Pour g√©rer l&apos;essentiel.</p>
            </div>
            <div className="mb-6">
              <span className="text-4xl font-bold text-slate-900">Gratuit</span>
            </div>

            <ul className="space-y-4 mb-8 flex-1">
              <li className="flex items-start">
                <Check className="w-5 h-5 text-green-500 mr-3 shrink-0" />
                <span className="text-slate-600">1 Collection Principale</span>
              </li>
              <li className="flex items-start">
                <Check className="w-5 h-5 text-green-500 mr-3 shrink-0" />
                <span className="text-slate-600">1 Wishlist G√©n√©rale</span>
              </li>
              <li className="flex items-start">
                <Check className="w-5 h-5 text-green-500 mr-3 shrink-0" />
                <span className="text-slate-600">5 Cr√©dits / jour</span>
              </li>
              <li className="flex items-start">
                <Zap className="w-5 h-5 text-amber-500 mr-3 shrink-0" />
                <span className="text-slate-600">Scanner de match (co√ªt: 1 cr√©dit)</span>
              </li>
              <li className="flex items-start">
                <Zap className="w-5 h-5 text-amber-500 mr-3 shrink-0" />
                <span className="text-slate-600">Import / Export (co√ªt: 1 cr√©dit)</span>
              </li>
            </ul>

            <Link 
              href="/"
              className="block w-full py-3 px-4 bg-slate-100 text-slate-700 font-medium text-center rounded-lg hover:bg-slate-200 transition-colors"
            >
              Retour √† l&apos;accueil
            </Link>
          </div>

          {/* Plan Premium */}
          <div className="bg-slate-900 rounded-2xl shadow-xl border border-slate-800 p-8 flex flex-col relative overflow-hidden">
            
     

            <div className="mb-4">
              <h3 className="text-xl font-semibold text-white">Premium</h3>
              <p className="text-slate-400 mt-2">Z√©ro limite, z√©ro contrainte.</p>
            </div>
            <div className="mb-6 flex items-baseline">
              <span className="text-4xl font-bold text-white">1‚Ç¨</span>
              <span className="text-slate-400 ml-2">/ mois</span>
            </div>

            <ul className="space-y-4 mb-8 flex-1">
              <li className="flex items-start">
                <Infinity className="w-5 h-5 text-blue-400 mr-3 shrink-0" />
                <span className="text-slate-200 font-bold">Collections Illimit√©es</span>
              </li>
              <li className="flex items-start">
                <Infinity className="w-5 h-5 text-blue-400 mr-3 shrink-0" />
                <span className="text-slate-200 font-bold">Wishlists Illimit√©es</span>
              </li>
              <li className="flex items-start">
                <Infinity className="w-5 h-5 text-blue-400 mr-3 shrink-0" />
                <span className="text-slate-200 font-bold">Cr√©dits Illimit√©s</span>
              </li>
              <li className="flex items-start">
                <Check className="w-5 h-5 text-blue-400 mr-3 shrink-0" />
                <span className="text-slate-300">Scanner illimit√©</span>
              </li>
              <li className="flex items-start">
                <Check className="w-5 h-5 text-blue-400 mr-3 shrink-0" />
                <span className="text-slate-300">Imports & Exports illimit√©s</span>
              </li>
            </ul>

            {/* UTILISATION DU COMPOSANT PARTAG√â */}
            <StripeButton 
                className="block w-full py-3 px-4 bg-blue-600 text-white font-medium text-center rounded-lg hover:bg-blue-700 transition-colors shadow-lg shadow-blue-900/20"
            >
                Passer Premium (1‚Ç¨)
            </StripeButton>

            <p className="text-center text-xs text-slate-500 mt-4">
              Paiement s√©curis√© via Stripe. Annulation √† tout moment.
            </p>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="components/ConfirmModal.tsx">
// components/ConfirmModal.tsx
'use client';

type ConfirmModalProps = {
  isOpen: boolean;
  onClose: () => void;
  onConfirm: () => void;
  title?: string;
  message?: string;
};

export default function ConfirmModal({ 
  isOpen, 
  onClose, 
  onConfirm, 
  title = "Confirmation", 
  message = "√ätes-vous s√ªr de vouloir faire √ßa ?" 
}: ConfirmModalProps) {
  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black/60 flex items-center justify-center z-50 p-4 backdrop-blur-sm">
      <div className="bg-white dark:bg-gray-800 rounded-xl p-6 max-w-sm w-full shadow-2xl border border-gray-100 dark:border-gray-700 animate-in fade-in zoom-in duration-200">
        <h3 className="text-lg font-bold text-gray-900 dark:text-white mb-2">{title}</h3>
        <p className="text-gray-500 dark:text-gray-300 mb-6">{message}</p>
        
        <div className="flex justify-end gap-3">
          <button
            onClick={onClose}
            className="px-4 py-2 text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-lg transition"
          >
            Annuler
          </button>
          <button
            onClick={() => {
              onConfirm();
              onClose();
            }}
            className="px-4 py-2 bg-red-600 hover:bg-red-700 text-white rounded-lg font-medium transition shadow-sm"
          >
            Supprimer
          </button>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="components/CreditsDisplay.tsx">
// components/CreditsDisplay.tsx
'use client';

import { useAuth } from '@/lib/AuthContext';
import Link from 'next/link';
import { useMemo } from 'react';

export function CreditsDisplay() {
  const { user, userProfile, loading } = useAuth();

  // CORRECTION : On calcule la valeur directement au lieu d'utiliser un useEffect + useState.
  // useMemo permet de ne recalculer que si userProfile change.
  const displayCredits = useMemo(() => {
    if (!userProfile) return 0;

    // Si Premium, on ne se soucie pas des cr√©dits (mais la logique d'affichage est g√©r√©e plus bas)
    if (userProfile.isPremium) return 9999;

    const todayStr = new Date().toISOString().split('T')[0];
    const lastReset = userProfile.lastCreditReset;
    
    // Logique d'affichage simul√©e :
    // Si la date de reset n'est pas aujourd'hui, on affiche 5 (car ils seront reset √† la prochaine action)
    if (lastReset !== todayStr) {
      return 5; // Valeur par d√©faut
    }
    
    return userProfile.dailyCredits ?? 0;
  }, [userProfile]);

  if (loading || !user) return null;

  // Affichage Premium
  if (userProfile?.isPremium) {
    return (
      <div className="flex items-center gap-2 px-3 py-1.5 bg-linear-to-r from-yellow-400/10 to-amber-500/10 border border-amber-200 rounded-full">
        <span className="text-amber-600 font-bold text-xs tracking-wider uppercase">Premium</span>
      </div>
    );
  }

  // Version Gratuite
  return (
    <Link href="/pricing" className="group">
      <div className="flex items-center gap-2 px-3 py-1.5 bg-slate-100 hover:bg-slate-200 border border-slate-200 rounded-full transition-colors cursor-pointer">
        <div className="flex flex-col items-end leading-none">
          <span className="text-xs font-semibold text-slate-700">
            {displayCredits} Cr√©dits
          </span>
          <span className="text-[10px] text-slate-500 group-hover:text-blue-600">
            Recharger
          </span>
        </div>
        {/* Petit indicateur visuel */}
        <div className="w-2 h-2 rounded-full bg-blue-500 relative">
          {displayCredits === 0 && (
            <div className="absolute inset-0 bg-red-500 rounded-full animate-pulse" />
          )}
        </div>
      </div>
    </Link>
  );
}
</file>

<file path="components/DeleteAllButton.tsx">
// components/DeleteAllButton.tsx
'use client';

import { useState } from 'react';
import { useAuth } from '@/lib/AuthContext';
import { db } from '@/lib/firebase';
import { collection, getDocs, writeBatch } from 'firebase/firestore';
import toast from 'react-hot-toast';
import ConfirmModal from './ConfirmModal';

type DeleteAllButtonProps = {
  targetCollection: 'wishlist' | 'collection';
};

export default function DeleteAllButton({ targetCollection }: DeleteAllButtonProps) {
  const { user } = useAuth();
  const [isDeleting, setIsDeleting] = useState(false);
  const [isConfirmOpen, setIsConfirmOpen] = useState(false);

  // Fonction utilitaire pour d√©couper en paquets de 500
  const chunkArray = <T,>(arr: T[], size: number): T[][] => {
    const chunks = [];
    for (let i = 0; i < arr.length; i += size) {
      chunks.push(arr.slice(i, i + size));
    }
    return chunks;
  };

  const handleDeleteAll = async () => {
    if (!user) return;

    setIsDeleting(true);
    const toastId = toast.loading("Suppression en cours...");

    try {
      // 1. On r√©cup√®re TOUTES les cartes
      const colRef = collection(db, 'users', user.uid, targetCollection);
      const snapshot = await getDocs(colRef);

      if (snapshot.empty) {
        toast.success("La liste est d√©j√† vide !", { id: toastId });
        setIsDeleting(false);
        return;
      }

      const docs = snapshot.docs;
      // 2. On d√©coupe en lots de 500 (limite technique Firestore)
      const batches = chunkArray(docs, 500);

      // 3. On supprime lot par lot
      for (const batchDocs of batches) {
        const batch = writeBatch(db);
        batchDocs.forEach((doc) => {
          batch.delete(doc.ref);
        });
        await batch.commit();
      }

      toast.success(`Tout a √©t√© supprim√© (${docs.length} cartes).`, { id: toastId });

    } catch (error) {
      console.error(error);
      toast.error("Erreur lors de la suppression.", { id: toastId });
    } finally {
      setIsDeleting(false);
    }
  };

  return (
    <>
      <button
        onClick={() => setIsConfirmOpen(true)}
        disabled={isDeleting}
        className="text-red-600 hover:text-red-800 hover:bg-red-50 dark:hover:bg-red-900/20 px-3 py-2 rounded-lg text-sm font-medium transition flex items-center gap-2"
        title="Tout effacer"
      >
        {isDeleting ? '...' : 'üóëÔ∏è Vider la liste'}
      </button>

      <ConfirmModal
        isOpen={isConfirmOpen}
        onClose={() => setIsConfirmOpen(false)}
        onConfirm={handleDeleteAll}
        title="‚ö†Ô∏è DANGER : Tout supprimer ?"
        message={`Vous √™tes sur le point de supprimer INT√âGRALEMENT votre ${targetCollection}. Cette action est irr√©versible.`}
      />
    </>
  );
}
</file>

<file path="components/LockedListModal.tsx">
// components/LockedListModal.tsx
'use client';

import { useState } from 'react';
import StripeButton from '@/components/StripeButton'; // Import

type LockedListModalProps = {
  isOpen: boolean;
  listName?: string;
};

export function LockedListModal({ isOpen, listName }: LockedListModalProps) {
  const [isVisible, setIsVisible] = useState(true);

  if (!isOpen || !isVisible) return null;

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black/60 backdrop-blur-sm animate-in fade-in duration-200">
      <div className="bg-white dark:bg-slate-900 rounded-2xl shadow-2xl max-w-md w-full p-6 border border-slate-200 dark:border-slate-800 transform transition-all scale-100">
        
        <div className="text-center">
          <div className="mx-auto flex items-center justify-center h-12 w-12 rounded-full bg-amber-100 mb-4">
            {/* Remplacement emoji par texte ou icone Lucide si dispo */}
            <span className="text-2xl font-bold text-amber-600">üîí</span>
          </div>
          
          <h3 className="text-lg font-bold text-slate-900 dark:text-white">
            Liste Verrouill√©e
          </h3>
          
          <p className="mt-2 text-sm text-slate-500 dark:text-slate-400">
            La liste <strong>{listName}</strong> d√©passe la limite de votre compte gratuit.
            <br/><br/>
            Vous pouvez <strong>consulter</strong> vos cartes, mais vous ne pouvez plus en ajouter ni en modifier.
          </p>
        </div>

        <div className="mt-6 flex flex-col gap-3">
          {/* BOUTON D'ACHAT DIRECT */}
          <StripeButton 
            className="w-full inline-flex justify-center items-center px-4 py-2.5 rounded-lg bg-blue-600 text-white font-bold hover:bg-blue-700 transition-colors shadow-lg shadow-blue-500/20"
          >
            D√©verrouiller maintenant (1‚Ç¨)
          </StripeButton>
          
          <button
            onClick={() => setIsVisible(false)}
            className="w-full inline-flex justify-center items-center px-4 py-2.5 rounded-lg bg-slate-100 text-slate-700 font-medium hover:bg-slate-200 transition-colors dark:bg-slate-800 dark:text-slate-300 dark:hover:bg-slate-700"
          >
            Voir en lecture seule
          </button>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="components/StripeButton.tsx">
// components/StripeButton.tsx
'use client';

import React from 'react';

type Props = {
  className?: string;
  children?: React.ReactNode;
};

export default function StripeButton({ className, children }: Props) {
  // Ce formulaire reprend exactement la logique de votre page Settings
  // Il poste vers l'API route qui cr√©e la session Stripe
  return (
    <form action="/api/checkout_sessions" method="POST" className="w-full">
      {/* Vous pouvez ajouter ici des input hidden si besoin de passer un priceId sp√©cifique */}
      {/* <input type="hidden" name="priceId" value="..." /> */}
      
      <button 
        type="submit" 
        role="link"
        className={className}
      >
        {children || "Passer Premium"}
      </button>
    </form>
  );
}
</file>

<file path="eslint.config.mjs">
import { defineConfig, globalIgnores } from "eslint/config";
import nextVitals from "eslint-config-next/core-web-vitals";
import nextTs from "eslint-config-next/typescript";

const eslintConfig = defineConfig([
  ...nextVitals,
  ...nextTs,
  // Override default ignores of eslint-config-next.
  globalIgnores([
    // Default ignores of eslint-config-next:
    ".next/**",
    "out/**",
    "build/**",
    "next-env.d.ts",
  ]),
]);

export default eslintConfig;
</file>

<file path="hooks/useAggregatedCards.ts">
import { useState, useEffect } from 'react';
import { collection, query, onSnapshot, orderBy, doc, updateDoc, deleteDoc } from 'firebase/firestore';
import { db } from '@/lib/firebase';
import { useAuth } from '@/lib/AuthContext';
import { useCollections } from './useCollections';
import { useWishlists } from './useWishlists';
import toast from 'react-hot-toast';

// D√©finition d'un type de base pour √©viter 'any'
export interface BaseCard {
  id: string;
  name?: string;
  addedAt?: { seconds: number; nanoseconds: number };
  // Permet d'acc√©der √† d'autres propri√©t√©s dynamiquement tout en restant typ√©
  [key: string]: unknown;
}

// Type √©tendu pour la vue globale
export interface AggregatedCard extends BaseCard {
  _listId: string;
  _listName: string;
}

export function useAggregatedCards(type: 'collection' | 'wishlist') {
  const { user } = useAuth();
  const { lists: collectionLists } = useCollections();
  const { lists: wishlistLists } = useWishlists();
  
  const listsToFetch = type === 'collection' ? collectionLists : wishlistLists;

  const [cards, setCards] = useState<AggregatedCard[]>([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    // Si pas d'utilisateur, on ne fait rien
    if (!user) return;

    // Si aucune liste √† r√©cup√©rer, on arr√™te le chargement imm√©diatement
    if (listsToFetch.length === 0) {
      // eslint-disable-next-line react-hooks/set-state-in-effect
      setLoading(false);
      setCards([]);
      return;
    }

    setLoading(true);
    const unsubscribers: (() => void)[] = [];
    const cardsMap = new Map<string, AggregatedCard[]>();

    // Fonction interne pour fusionner et mettre √† jour l'√©tat
    const updateMergedCards = () => {
      const allCards: AggregatedCard[] = [];
      cardsMap.forEach((listCards) => {
        allCards.push(...listCards);
      });
      
      // Tri par date d'ajout (plus r√©cent en haut)
      // On s√©curise l'acc√®s √† addedAt
      allCards.sort((a, b) => {
        const timeA = a.addedAt?.seconds ?? 0;
        const timeB = b.addedAt?.seconds ?? 0;
        return timeB - timeA;
      });

      setCards(allCards);
      setLoading(false);
    };

    listsToFetch.forEach(list => {
      const collectionName = type === 'collection' ? 'collections' : 'wishlists';
      
      const q = query(
        collection(db, 'users', user.uid, collectionName, list.id, 'cards'),
        orderBy('addedAt', 'desc')
      );

      const unsub = onSnapshot(q, (snapshot) => {
        const listCards = snapshot.docs.map(doc => {
          const data = doc.data();
          return {
            id: doc.id,
            ...data,
            _listId: list.id,
            _listName: list.name
          } as AggregatedCard;
        });
        
        cardsMap.set(list.id, listCards);
        updateMergedCards();
      });

      unsubscribers.push(unsub);
    });

    return () => {
      unsubscribers.forEach(u => u());
    };
  }, [user, listsToFetch, type]);

  // --- ACTIONS ---

  const updateCard = async (cardId: string, listId: string, updates: Partial<BaseCard>) => {
    if (!user || !listId) return;
    try {
      const collectionName = type === 'collection' ? 'collections' : 'wishlists';
      const cardRef = doc(db, 'users', user.uid, collectionName, listId, 'cards', cardId);
      // On cast updates pour satisfaire Firestore qui attend des paires cl√©/valeur
      await updateDoc(cardRef, updates as Record<string, unknown>);
      toast.success("Carte mise √† jour");
    } catch (error) {
      console.error(error);
      toast.error("Erreur mise √† jour");
    }
  };

  const deleteCard = async (cardId: string, listId: string) => {
     if (!user || !listId) return;
     if (!confirm("Supprimer cette carte ?")) return;
     try {
        const collectionName = type === 'collection' ? 'collections' : 'wishlists';
        const cardRef = doc(db, 'users', user.uid, collectionName, listId, 'cards', cardId);
        await deleteDoc(cardRef);
        toast.success("Carte supprim√©e");
     } catch (error) {
        console.error(error);
        toast.error("Erreur suppression");
     }
  };

  return { cards, loading, updateCard, deleteCard };
}
</file>

<file path="lib/limits.ts">
// lib/limits.ts
import { getAdminFirestore } from '@/lib/firebase-admin';
import { FieldValue } from 'firebase-admin/firestore';
import { UserProfile } from '@/lib/types';

// RECOMMANDATION : 5 Cr√©dits gratuits par jour
const FREE_DAILY_CREDITS = 5;

// LIMITES FREEMIUM
const MAX_FREE_COLLECTIONS = 1; // 1 Classeur principal
const MAX_FREE_WISHLISTS = 1;   // 1 Wishlist g√©n√©rale uniquement

export const COSTS = {
  TRADE_MATCH: 1, // Le "Scanner" de match
  IMPORT: 1,      // Import CSV co√ªte 1 cr√©dit
  EXPORT: 1,      // Export CSV co√ªte 1 cr√©dit
  CREATE_LIST: 0, // Le co√ªt est g√©r√© par la limite stricte (MAX_FREE_...), pas par les cr√©dits
} as const;

type CostType = keyof typeof COSTS;

/**
 * V√©rifie et consomme les cr√©dits pour une action donn√©e.
 */
export async function checkAndConsumeCredits(userId: string, action: CostType): Promise<{ allowed: boolean; error?: string }> {
  const db = getAdminFirestore();
  const userRef = db.collection('users').doc(userId);
  const cost = COSTS[action];
  const todayStr = new Date().toISOString().split('T')[0];

  try {
    const result = await db.runTransaction(async (transaction) => {
      const userDoc = await transaction.get(userRef);
      
      if (!userDoc.exists) {
        throw new Error("Utilisateur introuvable");
      }

      const userData = userDoc.data() as UserProfile;
      
      // 1. Si Premium, TOUT est illimit√© (pas de consommation de cr√©dits)
      if (userData.isPremium) {
        return { allowed: true };
      }

      // 2. Gestion du Reset Quotidien
      let currentCredits = userData.dailyCredits ?? 0;
      const lastReset = userData.lastCreditReset;

      if (lastReset !== todayStr) {
        currentCredits = FREE_DAILY_CREDITS;
        transaction.update(userRef, {
          dailyCredits: FREE_DAILY_CREDITS,
          lastCreditReset: todayStr
        });
      }

      // 3. V√©rification du solde
      if (currentCredits < cost) {
        return { 
          allowed: false, 
          error: `Cr√©dits insuffisants (${currentCredits}/${cost}). Revenez demain ou passez Premium.` 
        };
      }

      // 4. Consommation
      if (cost > 0) {
        transaction.update(userRef, {
          dailyCredits: FieldValue.increment(-cost)
        });
      }

      return { allowed: true };
    });

    return result;

  } catch (error) {
    console.error("Erreur checkAndConsumeCredits:", error);
    const message = error instanceof Error ? error.message : "Erreur lors de la v√©rification des cr√©dits";
    return { allowed: false, error: message };
  }
}

/**
 * V√©rifie si l'utilisateur a atteint sa limite de listes.
 */
export async function canCreateNewList(userId: string, type: 'collection' | 'wishlist'): Promise<{ allowed: boolean; error?: string }> {
  const db = getAdminFirestore();
  
  const userDoc = await db.collection('users').doc(userId).get();
  if (!userDoc.exists) return { allowed: false, error: "Utilisateur introuvable" };
  
  const userData = userDoc.data() as UserProfile;
  if (userData.isPremium) return { allowed: true };

  const targetCollection = type === 'collection' ? 'collections_meta' : 'wishlists_meta';
  const limit = type === 'collection' ? MAX_FREE_COLLECTIONS : MAX_FREE_WISHLISTS;

  const snapshot = await db
    .collection('users')
    .doc(userId)
    .collection(targetCollection)
    .count()
    .get();

  const count = snapshot.data().count;

  if (count >= limit) {
    const message = type === 'collection' 
        ? "Vous √™tes limit√© √† 1 Collection Principale." 
        : "Vous √™tes limit√© √† 1 Wishlist G√©n√©rale.";
    return { allowed: false, error: `${message} Passez Premium pour cr√©er des listes illimit√©es.` };
  }

  return { allowed: true };
}
</file>

<file path="lib/types.ts">
// lib/types.ts
import { Timestamp } from 'firebase/firestore';

export interface UserProfile {
  uid: string;
  email: string | null;
  displayName: string | null;
  photoURL: string | null;
  isPremium: boolean;         // Statut Premium
  dailyCredits: number;       // Cr√©dits restants aujourd'hui
  lastCreditReset: string;    // Date du dernier reset (format YYYY-MM-DD)
  createdAt: Timestamp;
  updatedAt: Timestamp;
}

export interface FirestoreGroup {
  name: string;
  ownerUid: string;
  members: string[];
  admins: string[];
  createdAt?: unknown;
}

export type ActionResponse = {
  success: boolean;
  error?: string;
  data?: unknown;
};
</file>

<file path="public/file.svg">
<svg fill="none" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.5 13.5V5.41a1 1 0 0 0-.3-.7L9.8.29A1 1 0 0 0 9.08 0H1.5v13.5A2.5 2.5 0 0 0 4 16h8a2.5 2.5 0 0 0 2.5-2.5m-1.5 0v-7H8v-5H3v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1M9.5 5V2.12L12.38 5zM5.13 5h-.62v1.25h2.12V5zm-.62 3h7.12v1.25H4.5zm.62 3h-.62v1.25h7.12V11z" clip-rule="evenodd" fill="#666" fill-rule="evenodd"/></svg>
</file>

<file path="public/globe.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g clip-path="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.27 14.1a6.5 6.5 0 0 0 3.67-3.45q-1.24.21-2.7.34-.31 1.83-.97 3.1M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m.48-1.52a7 7 0 0 1-.96 0H7.5a4 4 0 0 1-.84-1.32q-.38-.89-.63-2.08a40 40 0 0 0 3.92 0q-.25 1.2-.63 2.08a4 4 0 0 1-.84 1.31zm2.94-4.76q1.66-.15 2.95-.43a7 7 0 0 0 0-2.58q-1.3-.27-2.95-.43a18 18 0 0 1 0 3.44m-1.27-3.54a17 17 0 0 1 0 3.64 39 39 0 0 1-4.3 0 17 17 0 0 1 0-3.64 39 39 0 0 1 4.3 0m1.1-1.17q1.45.13 2.69.34a6.5 6.5 0 0 0-3.67-3.44q.65 1.26.98 3.1M8.48 1.5l.01.02q.41.37.84 1.31.38.89.63 2.08a40 40 0 0 0-3.92 0q.25-1.2.63-2.08a4 4 0 0 1 .85-1.32 7 7 0 0 1 .96 0m-2.75.4a6.5 6.5 0 0 0-3.67 3.44 29 29 0 0 1 2.7-.34q.31-1.83.97-3.1M4.58 6.28q-1.66.16-2.95.43a7 7 0 0 0 0 2.58q1.3.27 2.95.43a18 18 0 0 1 0-3.44m.17 4.71q-1.45-.12-2.69-.34a6.5 6.5 0 0 0 3.67 3.44q-.65-1.27-.98-3.1" fill="#666"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h16v16H0z"/></clipPath></defs></svg>
</file>

<file path="public/next.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>
</file>

<file path="public/vercel.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1155 1000"><path d="m577.3 0 577.4 1000H0z" fill="#fff"/></svg>
</file>

<file path="public/window.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2.5h13v10a1 1 0 0 1-1 1h-11a1 1 0 0 1-1-1zM0 1h16v11.5a2.5 2.5 0 0 1-2.5 2.5h-11A2.5 2.5 0 0 1 0 12.5zm3.75 4.5a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5M7 4.75a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0m1.75.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5" fill="#666"/></svg>
</file>

<file path="README.md">
This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.
</file>

<file path=".firebaserc">
{
  "projects": {
    "mw": "magicwish-48604"
  },
  "targets": {},
  "etags": {}
}
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

# local tools
stripe.exe
</file>

<file path="app/actions/admin.ts">
// app/actions/admin.ts
'use server';

import { getAdminAuth } from '@/lib/firebase-admin';
import { refreshUserCollectionPrices } from '@/app/actions/collection';

export async function forceUpdateAllUsersCardsAction() {
    const auth = getAdminAuth();

    try {
        console.log("D√©marrage de la mise √† jour globale via Auth...");
        
        let successCount = 0;
        let failCount = 0;
        let pageToken: string | undefined = undefined;
        let totalUsersFound = 0;

        do {
            const listUsersResult = await auth.listUsers(1000, pageToken);
            const users = listUsersResult.users;
            totalUsersFound += users.length;
            
            console.log(`Traitement d'un lot de ${users.length} utilisateurs...`);

            for (const userRecord of users) {
                const uid = userRecord.uid;
                try {
                    await refreshUserCollectionPrices(uid);
                    successCount++;
                } catch (e) {
                    console.error(`Erreur update user ${uid}:`, e);
                    failCount++;
                }
            }

            pageToken = listUsersResult.pageToken;
        } while (pageToken);

        return { 
            success: true, 
            message: `Termin√© ! ${successCount}/${totalUsersFound} utilisateurs mis √† jour. ${failCount} √©checs.` 
        };

    } catch (e) {
        console.error("Erreur critique update all:", e);
        const msg = e instanceof Error ? e.message : "Erreur inconnue";
        return { success: false, error: msg };
    }
}
</file>

<file path="app/actions/friends.ts">
// app/actions/friends.ts
'use server';

import { getAdminFirestore } from '@/lib/firebase-admin';

// D√©finition stricte des types pour √©viter le 'any'
type FriendInput = {
  uid: string;
  username: string;
  displayName: string;
  photoURL: string | null;
};

type ActionResponse = {
  success: boolean;
  error?: string;
};

export async function acceptFriendRequestAction(
  currentUserId: string,
  targetUser: FriendInput
): Promise<ActionResponse> {
  const db = getAdminFirestore();
  
  try {
    // 1. R√©cup√©rer les infos √† jour de l'utilisateur courant (pour √™tre s√ªr des donn√©es)
    const currentUserDoc = await db.doc(`users/${currentUserId}/public_profile/info`).get();
    
    if (!currentUserDoc.exists) {
      throw new Error("Profil utilisateur introuvable.");
    }

    const currentUserData = currentUserDoc.data();
    
    // On s√©curise les donn√©es de l'utilisateur courant
    const currentUserPayload: FriendInput = {
        uid: currentUserId,
        username: currentUserData?.username || "Inconnu",
        displayName: currentUserData?.displayName || "Sans nom",
        photoURL: currentUserData?.photoURL || null
    };

    // 2. Pr√©parer le Batch
    const batch = db.batch();

    // A. Ajouter l'ami dans MA liste
    const myFriendRef = db.doc(`users/${currentUserId}/friends/${targetUser.uid}`);
    batch.set(myFriendRef, {
      uid: targetUser.uid,
      username: targetUser.username,
      displayName: targetUser.displayName,
      photoURL: targetUser.photoURL || null,
      addedAt: new Date()
    });

    // B. M'ajouter dans SA liste (C'est ici que √ßa bloquait c√¥t√© client)
    const hisFriendRef = db.doc(`users/${targetUser.uid}/friends/${currentUserId}`);
    batch.set(hisFriendRef, {
      ...currentUserPayload,
      addedAt: new Date()
    });

    // C. Supprimer la demande d'ami re√ßue
    const reqRef = db.doc(`users/${currentUserId}/friend_requests_received/${targetUser.uid}`);
    batch.delete(reqRef);

    // 3. Valider la transaction
    await batch.commit();

    return { success: true };

  } catch (error: unknown) {
    console.error("Erreur acceptFriendRequestAction:", error);
    let errorMessage = "Erreur serveur";
    
    if (error instanceof Error) {
        errorMessage = error.message;
    } else if (typeof error === "string") {
        errorMessage = error;
    }

    return { success: false, error: errorMessage };
  }
}
</file>

<file path="app/actions/game.ts">
// app/actions/game.ts
'use server';

import { getAdminFirestore } from '@/lib/firebase-admin';
import { FieldValue } from 'firebase-admin/firestore';
import { updateUserStats } from '@/app/actions/stats';

// D√©finition stricte des donn√©es pour un joueur dans une partie
interface PlayerResult {
    uid: string;
    displayName: string;
    finalLife: number;
    isWinner: boolean;
    commanderNames: string[]; // Noms des commandants
    deckName: string;         // Nom du deck utilis√© (si enregistr√©)
    startLife: number;
}

// CORRECTION : √âlargissement du type GameFormat
// Ajout des formats Standard, Commander, Modern, Pauper, Legacy, DuelCommander
export type GameFormat = 'Commander' | 'Standard' | 'Modern' | 'Pauper' | 'Legacy' | 'DuelCommander' | 'Other';

// Sch√©ma de l'enregistrement de partie
interface GameData {
    format: GameFormat; // Utilisation du type √©largi
    players: PlayerResult[];
    winnerUid: string;
    durationMinutes: number; // Optionnel
}

type ActionResponse = {
    success: boolean;
    error?: string;
    id?: string;
};

export async function recordGameAction(data: GameData): Promise<ActionResponse> {
    const db = getAdminFirestore();

    try {
        // 1. Validation basique (s'assurer qu'il y a un gagnant et des joueurs)
        if (data.players.filter(p => p.isWinner).length !== 1) {
            throw new Error("Une partie doit avoir exactement un gagnant.");
        }
        if (data.players.length < 2) {
            throw new Error("Une partie n√©cessite au moins deux joueurs.");
        }

        // 2. Enregistrement de la partie
        const gameRef = await db.collection('games').add({
            ...data,
            createdAt: FieldValue.serverTimestamp()
        });

        // 3. Mise √† jour des statistiques individuelles des joueurs (Background)
        data.players.forEach(player => {
            updateUserStats(player.uid).catch(console.error);
        });

        return { success: true, id: gameRef.id };

    } catch (error: unknown) {
        console.error("Erreur recordGameAction:", error);
        let message = "Erreur serveur";
        if (error instanceof Error) message = error.message;
        return { success: false, error: message };
    }
}
</file>

<file path="app/actions/groups.ts">
// app/actions/groups.ts
'use server';

import { getAdminFirestore } from '@/lib/firebase-admin';
import { FieldValue } from 'firebase-admin/firestore';
import { z } from 'zod';

// --- TYPES & SCH√âMAS ---

type ActionResponse = {
    success: boolean;
    error?: string;
    id?: string;
};

// Interface pour typer les donn√©es brutes de Firestore
interface FirestoreGroup {
    name: string;
    ownerUid: string;
    members: string[];
    admins: string[];
    createdAt?: unknown;
}

// Sch√©mas de validation Zod
const createGroupSchema = z.object({
    userId: z.string().min(1, "ID utilisateur invalide"),
    groupName: z.string().min(3, "Le nom du groupe doit contenir au moins 3 caract√®res").max(50, "Le nom du groupe est trop long"),
});

const memberActionSchema = z.object({
    requesterUid: z.string().min(1, "ID demandeur invalide"),
    groupId: z.string().min(1, "ID groupe invalide"),
    targetUid: z.string().min(1, "ID cible invalide"),
});

// --- ACTIONS ---

// Cr√©er un groupe (Le cr√©ateur devient Admin et Membre)
export async function createGroupAction(userId: string, groupName: string): Promise<ActionResponse> {
    const db = getAdminFirestore();

    // 1. Validation des entr√©es
    const validation = createGroupSchema.safeParse({ userId, groupName });
    if (!validation.success) {
        return { success: false, error: validation.error.issues[0].message };
    }

    try {
        const groupRef = await db.collection('groups').add({
            name: groupName,
            ownerUid: userId,
            members: [userId],
            admins: [userId],
            createdAt: FieldValue.serverTimestamp()
        });
        
        return { success: true, id: groupRef.id };
    } catch (e) {
        console.error("Erreur createGroupAction:", e);
        return { success: false, error: "Erreur technique lors de la cr√©ation du groupe" };
    }
}

// Ajouter un membre (Seulement si le demandeur est Admin du groupe)
export async function addMemberAction(requesterUid: string, groupId: string, targetUid: string): Promise<ActionResponse> {
    const db = getAdminFirestore();

    // 1. Validation des entr√©es
    const validation = memberActionSchema.safeParse({ requesterUid, groupId, targetUid });
    if (!validation.success) {
        return { success: false, error: validation.error.issues[0].message };
    }

    try {
        await db.runTransaction(async (transaction) => {
            const groupRef = db.collection('groups').doc(groupId);
            const docSnap = await transaction.get(groupRef);

            if (!docSnap.exists) throw new Error("Groupe introuvable");
            
            const data = docSnap.data() as FirestoreGroup;

            // S√âCURIT√â : V√©rifier que celui qui invite est admin
            if (!data.admins.includes(requesterUid)) {
                throw new Error("Permission refus√©e. Seul un admin peut inviter.");
            }

            if (data.members.includes(targetUid)) {
                throw new Error("Cet utilisateur est d√©j√† membre.");
            }

            transaction.update(groupRef, {
                members: FieldValue.arrayUnion(targetUid)
            });
        });

        return { success: true };
    } catch (e) {
        console.error("Erreur addMemberAction:", e);
        const errorMessage = e instanceof Error ? e.message : "Erreur technique";
        return { success: false, error: errorMessage };
    }
}

// Promouvoir un membre en Admin
export async function promoteMemberAction(requesterUid: string, groupId: string, targetUid: string): Promise<ActionResponse> {
    const db = getAdminFirestore();

    // 1. Validation des entr√©es
    const validation = memberActionSchema.safeParse({ requesterUid, groupId, targetUid });
    if (!validation.success) {
        return { success: false, error: validation.error.issues[0].message };
    }

    try {
        await db.runTransaction(async (transaction) => {
            const groupRef = db.collection('groups').doc(groupId);
            const docSnap = await transaction.get(groupRef);

            if (!docSnap.exists) throw new Error("Groupe introuvable");
            const data = docSnap.data() as FirestoreGroup;

            if (!data.admins.includes(requesterUid)) {
                throw new Error("Permission refus√©e. Seul un admin peut promouvoir.");
            }

            if (!data.members.includes(targetUid)) {
                throw new Error("L'utilisateur cible n'est pas membre du groupe.");
            }

            if (data.admins.includes(targetUid)) {
                throw new Error("Cet utilisateur est d√©j√† admin.");
            }

            transaction.update(groupRef, {
                admins: FieldValue.arrayUnion(targetUid)
            });
        });

        return { success: true };
    } catch (e) {
        console.error("Erreur promoteMemberAction:", e);
        const errorMessage = e instanceof Error ? e.message : "Erreur technique";
        return { success: false, error: errorMessage };
    }
}

// Quitter ou Exclure (Si admin exclut un autre, ou si l'utilisateur quitte lui-m√™me)
export async function removeMemberAction(requesterUid: string, groupId: string, targetUid: string): Promise<ActionResponse> {
    const db = getAdminFirestore();

    // 1. Validation des entr√©es
    const validation = memberActionSchema.safeParse({ requesterUid, groupId, targetUid });
    if (!validation.success) {
        return { success: false, error: validation.error.issues[0].message };
    }

    try {
        await db.runTransaction(async (transaction) => {
            const groupRef = db.collection('groups').doc(groupId);
            const docSnap = await transaction.get(groupRef);

            if (!docSnap.exists) throw new Error("Groupe introuvable");
            const data = docSnap.data() as FirestoreGroup;

            // PROTECTION : On ne touche pas au propri√©taire
            if (targetUid === data.ownerUid) {
                throw new Error("Impossible de retirer le propri√©taire du groupe.");
            }

            const isSelf = requesterUid === targetUid;
            const isAdmin = data.admins.includes(requesterUid);

            // On autorise si c'est soi-m√™me OU si le demandeur est admin
            if (!isSelf && !isAdmin) {
                throw new Error("Permission refus√©e.");
            }

            // On retire des deux tableaux pour √™tre propre (membres et admins)
            transaction.update(groupRef, {
                members: FieldValue.arrayRemove(targetUid),
                admins: FieldValue.arrayRemove(targetUid)
            });
        });

        return { success: true };
    } catch (e) {
        console.error("Erreur removeMemberAction:", e);
        const errorMessage = e instanceof Error ? e.message : "Erreur technique";
        return { success: false, error: errorMessage };
    }
}
</file>

<file path="app/actions/matching.ts">
'use server';

import { getAdminFirestore } from '@/lib/firebase-admin';
import { FieldValue } from 'firebase-admin/firestore';

type CardAnalysisInput = {
    id: string;
    name: string;
    isFoil: boolean;
};

// 1. SCAN TRADE -> WISHLIST (Notifie l'ami qui cherche)
export async function checkAutoMatch(userId: string, cardsToCheck: CardAnalysisInput[]) {
    const db = getAdminFirestore();

    try {
        const userDoc = await db.doc(`users/${userId}/public_profile/info`).get();
        const userName = userDoc.data()?.displayName || "Un ami";

        const friendsSnap = await db.collection(`users/${userId}/friends`).get();
        const friendIds = friendsSnap.docs.map(d => d.id);

        if (friendIds.length === 0) return { success: true, matches: 0 };

        let matchCount = 0;
        const batch = db.batch();

        await Promise.all(friendIds.map(async (friendId) => {
            const targetCards = cardsToCheck.slice(0, 10); 
            
            for (const card of targetCards) {
                // On cherche dans la wishlist de l'ami
                const wishlistRef = db.collection(`users/${friendId}/wishlist`);
                const nameQuery = wishlistRef.where('name', '==', card.name).limit(1);
                
                const snap = await nameQuery.get();

                if (!snap.empty) {
                    matchCount++;

                    // Notification pour l'AMI
                    const notifRefFriend = db.collection(`users/${friendId}/notifications`).doc();
                    batch.set(notifRefFriend, {
                        type: 'match_found',
                        title: "Nouvelle opportunit√© !",
                        message: `${userName} propose une carte de votre wishlist : ${card.name}`,
                        link: `/trades/new/${userId}`,
                        read: false,
                        createdAt: FieldValue.serverTimestamp(),
                        relatedCardOwner: userId,
                        relatedCardId: card.id 
                    });
                }
            }
        }));

        if (matchCount > 0) {
            await batch.commit();
        }

        return { success: true, matches: matchCount };

    } catch (error) {
        console.error("Erreur AutoMatch:", error);
        return { success: false, error: "Erreur analyse" };
    }
}

// 2. SCAN WISHLIST -> TRADE (Me notifie si un ami a la carte)
export async function checkWishlistMatch(userId: string, cardsLookingFor: CardAnalysisInput[]) {
    const db = getAdminFirestore();

    try {
        const friendsSnap = await db.collection(`users/${userId}/friends`).get();
        const friendIds = friendsSnap.docs.map(d => d.id);

        if (friendIds.length === 0) return { success: true, matches: 0 };

        let matchCount = 0;
        const batch = db.batch();

        await Promise.all(friendIds.map(async (friendId) => {
            
            const friendProfile = await db.doc(`users/${friendId}/public_profile/info`).get();
            const friendName = friendProfile.data()?.displayName || "Un ami";

            const targetCards = cardsLookingFor.slice(0, 10);

            for (const card of targetCards) {
                // On cherche dans la collection de l'ami par nom
                const colRef = db.collection(`users/${friendId}/collection`);
                const q = colRef.where('name', '==', card.name).limit(1);
                
                const snap = await q.get();

                if (!snap.empty) {
                    const friendCardData = snap.docs[0].data();
                    const tradeQty = friendCardData.quantityForTrade || 0;

                    // Si l'ami a la carte EN TRADE
                    if (tradeQty > 0) {
                        matchCount++;

                        // Notification pour MOI
                        const notifRefMe = db.collection(`users/${userId}/notifications`).doc();
                        batch.set(notifRefMe, {
                            type: 'match_found',
                            title: "Carte trouv√©e !",
                            message: `${friendName} poss√®de "${card.name}" √† l'√©change !`,
                            link: `/trades/new/${friendId}`,
                            read: false,
                            createdAt: FieldValue.serverTimestamp(),
                            relatedCardOwner: friendId,
                            relatedCardId: snap.docs[0].id
                        });
                    }
                }
            }
        }));

        if (matchCount > 0) {
            await batch.commit();
        }

        return { success: true, matches: matchCount };

    } catch (error) {
        console.error("Erreur WishlistMatch:", error);
        return { success: false, error: "Erreur scan" };
    }
}

// 3. NETTOYAGE DES NOTIFICATIONS (Si carte plus dispo)
export async function removeAutoMatchNotification(userId: string, cardIdsToRemove: string[]) {
    const db = getAdminFirestore();

    try {
        const friendsSnap = await db.collection(`users/${userId}/friends`).get();
        const friendIds = friendsSnap.docs.map(d => d.id);

        if (friendIds.length === 0 || cardIdsToRemove.length === 0) return { success: true };

        const batch = db.batch();
        let deletedCount = 0;

        await Promise.all(friendIds.map(async (friendId) => {
            const notifRef = db.collection(`users/${friendId}/notifications`);
            
            // On cherche les notifs qui viennent de MOI (userId) et concernent CES cartes
            const safeIds = cardIdsToRemove.slice(0, 10); 

            const q = notifRef
                .where('relatedCardOwner', '==', userId)
                .where('relatedCardId', 'in', safeIds);

            const snap = await q.get();
            
            snap.forEach(doc => {
                batch.delete(doc.ref);
                deletedCount++;
            });
        }));

        if (deletedCount > 0) {
            await batch.commit();
        }

        return { success: true };

    } catch (error) {
        console.error("Erreur nettoyage notifs:", error);
        return { success: false };
    }
}
</file>

<file path="app/actions/stats.ts">
'use server';

import { getAdminFirestore } from '@/lib/firebase-admin';

export async function updateUserStats(userId: string) {
    const db = getAdminFirestore();
    
    try {
        const collectionRef = db.collection(`users/${userId}/collection`);
        const snapshot = await collectionRef.get();

        let totalValue = 0;
        let totalCards = 0;
        let foilCount = 0;
        
        snapshot.forEach(doc => {
            const data = doc.data();
            const qty = (typeof data.quantity === 'number') ? data.quantity : 0;
            
            // Gestion s√©curis√©e des prix (priorit√© au customPrice)
            let price = 0;
            if (typeof data.customPrice === 'number') {
                price = data.customPrice;
            } else if (typeof data.price === 'number') {
                price = data.price;
            }
            
            totalValue += price * qty;
            totalCards += qty;
            if (data.isFoil === true) foilCount += qty;
        });

        const uniqueCards = snapshot.size;
        const avgPrice = totalCards > 0 ? totalValue / totalCards : 0;

        // Sauvegarde dans un document l√©ger d√©di√© √† la lecture rapide
        await db.doc(`users/${userId}/public_profile/stats`).set({
            totalValue,
            totalCards,
            uniqueCards,
            foilCount,
            avgPrice,
            lastUpdated: new Date()
        }, { merge: true });

        return { success: true };

    } catch (error) {
        console.error("Erreur update stats:", error);
        return { success: false, error: "Echec du calcul des statistiques" };
    }
}
</file>

<file path="app/actions/wishlist.ts">
// app/actions/wishlist.ts
'use server';

import { getAdminFirestore } from '@/lib/firebase-admin';

type ActionResponse = {
  success: boolean;
  error?: string;
};

export async function deleteWishlistAction(userId: string, listId: string): Promise<ActionResponse> {
  const db = getAdminFirestore();

  try {
    // 1. R√©cup√©rer toutes les cartes de la sous-collection
    // Note : Si la liste contient plus de 500 cartes, il faudrait boucler. 
    // Ici on g√®re un batch simple (jusqu'√† 500 ops), suffisant pour une wishlist standard.
    const cardsRef = db.collection(`users/${userId}/wishlists_data/${listId}/cards`);
    const snapshot = await cardsRef.get();

    const batch = db.batch();

    // 2. Ajouter la suppression de chaque carte au batch
    snapshot.docs.forEach((doc) => {
      batch.delete(doc.ref);
    });

    // 3. Supprimer le document de m√©tadonn√©es (le pointeur de la liste)
    const metaRef = db.doc(`users/${userId}/wishlists_meta/${listId}`);
    batch.delete(metaRef);

    // 4. Ex√©cuter
    await batch.commit();

    return { success: true };

  } catch (error: unknown) {
    console.error("Erreur deleteWishlistAction:", error);
    let errorMessage = "Erreur suppression";
    if (error instanceof Error) errorMessage = error.message;
    
    return { success: false, error: errorMessage };
  }
}
</file>

<file path="app/ads-validation/page.tsx">
// app/ads-validation/page.tsx
// C'est une page Server Component statique par d√©faut.
export default function AdsValidationPage() {
    return (
        <div>
            {/* Petit contenu pour √™tre certain que la page ne soit pas vide */}
            <h1>Validation Google AdSense</h1>
            <p>Ce contenu est public pour permettre la v√©rification du site.</p>
        </div>
    );
}
</file>

<file path="app/api/cron/cleanup-users/route.ts">
// app/api/cron/cleanup-users/route.ts
import { NextResponse } from 'next/server';
import { getAdminAuth, getAdminFirestore } from '@/lib/firebase-admin';
import type { UserRecord } from 'firebase-admin/auth'; // Import du type pour corriger l'erreur 'any'

// Pour empecher le cache sur cette route
export const dynamic = 'force-dynamic';

interface DeleteResult {
    uid: string;
    success: boolean;
    error?: string;
}

export async function GET(request: Request) {
    // SECURITE : Verification du header d'autorisation
    const authHeader = request.headers.get('authorization');
    if (process.env.CRON_SECRET && authHeader !== `Bearer ${process.env.CRON_SECRET}`) {
        return NextResponse.json({ error: 'Non autorise' }, { status: 401 });
    }

    // INITIALISATION DES INSTANCES ADMIN
    const auth = getAdminAuth();
    const db = getAdminFirestore();

    try {
        console.log("Demarrage du nettoyage des comptes inactifs...");
        
        // 1. Definir la date limite (il y a 30 jours)
        const THIRTY_DAYS_MS = 30 * 24 * 60 * 60 * 1000;
        const now = Date.now();
        const cutoffDate = now - THIRTY_DAYS_MS;

        // 2. Recuperer les utilisateurs (par lots de 1000)
        const listUsersResult = await auth.listUsers(1000);
        
        // Typage explicite de 'user' ici pour √©viter l'erreur "implicitly has an 'any' type"
        const usersToDelete = listUsersResult.users.filter((user: UserRecord) => {
            if (!user.metadata.creationTime) return false;
            const creationTime = new Date(user.metadata.creationTime).getTime();
            
            // Condition : Email NON verifie ET Compte cree AVANT la date limite
            return !user.emailVerified && creationTime < cutoffDate;
        });

        console.log(`Utilisateurs trouves a supprimer : ${usersToDelete.length}`);

        // 3. Supprimer les utilisateurs identifies
        const results: DeleteResult[] = [];

        // On traite les suppressions en parallele
        await Promise.all(usersToDelete.map(async (user: UserRecord) => {
            try {
                // A. Supprimer de l'Authentication
                await auth.deleteUser(user.uid);

                // B. Supprimer le document User racine dans Firestore
                await db.collection('users').doc(user.uid).delete();

                // Note : Firestore ne supprime pas les sous-collections automatiquement.
                // Il faudrait un script recursif pour nettoyer parfaitement, 
                // mais supprimer le parent suffit pour invalider le compte.
                
                results.push({ uid: user.uid, success: true });
            } catch (err: unknown) {
                const errorMessage = err instanceof Error ? err.message : String(err);
                console.error(`Erreur suppression user ${user.uid}:`, errorMessage);
                results.push({ uid: user.uid, success: false, error: errorMessage });
            }
        }));

        console.log("Nettoyage termine.");

        return NextResponse.json({
            success: true,
            message: "Nettoyage termine.",
            countDeleted: results.filter(r => r.success).length,
            details: results
        });

    } catch (error: unknown) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        console.error("Erreur critique Cron:", errorMessage);
        return NextResponse.json({ error: errorMessage }, { status: 500 });
    }
}
</file>

<file path="app/api/feedback/route.ts">
// app/api/feedback/route.ts
import { NextResponse } from 'next/server';
import { getAdminFirestore } from '@/lib/firebase-admin';
import { FieldValue } from 'firebase-admin/firestore';
import { z } from 'zod';

// Sch√©ma de validation de la suggestion entrante
const FeedbackSchema = z.object({
  userId: z.string().min(1),
  username: z.string().min(1).max(50),
  suggestion: z.string().min(10).max(1000),
  context: z.string().default('settings-page') 
});

export async function POST(req: Request) {
  const db = getAdminFirestore();

  try {
    const body = await req.json();
    const validation = FeedbackSchema.safeParse(body);

    if (!validation.success) {
      console.error("Erreur de validation Feedback:", validation.error);
      return NextResponse.json(
        { error: 'Donn√©es invalides. La suggestion doit √™tre entre 10 et 1000 caract√®res.' }, 
        { status: 400 }
      );
    }

    const data = validation.data;

    // Enregistrement dans une nouvelle collection 'app_feedback'
    await db.collection('app_feedback').add({
      ...data,
      createdAt: FieldValue.serverTimestamp(),
      status: 'new' // Statut initial pour le suivi
    });

    return NextResponse.json({ success: true, message: 'Merci pour votre suggestion !' }, { status: 200 });

  } catch (error) {
    console.error('Erreur interne du serveur lors de l\'enregistrement du feedback:', error);
    return NextResponse.json(
      { error: 'Une erreur interne est survenue.' }, 
      { status: 500 }
    );
  }
}
</file>

<file path="app/login/page.tsx">
'use client';

import { useState, useEffect } from 'react'; // Ajout de useEffect
import { useRouter } from 'next/navigation';
import { useAuth } from '@/lib/AuthContext';
import Link from 'next/link';

export default function LoginPage() {
  const { user, signInWithGoogle, signInWithEmail, signUpWithEmail, loading } = useAuth();
  const router = useRouter();

  const [isLoginMode, setIsLoginMode] = useState(true);
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);

  // --- CORRECTION ICI ---
  // On utilise useEffect pour g√©rer la redirection APRES le rendu
  useEffect(() => {
    if (!loading && user) {
      router.push('/');
    }
  }, [user, loading, router]);

  // On retourne null pour ne rien afficher pendant la redirection
  // cela √©vite un "flash" du formulaire de connexion
  if (!loading && user) {
    return null;
  }

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!email || !password) return;
    
    setIsSubmitting(true);
    let success = false;

    if (isLoginMode) {
        success = await signInWithEmail(email, password);
    } else {
        success = await signUpWithEmail(email, password);
    }

    if (success) {
        router.push('/');
    } else {
        setIsSubmitting(false);
    }
  };

  if (loading) return <div className="min-h-screen flex items-center justify-center bg-background text-muted">Chargement...</div>;

  return (
    <main className="min-h-screen flex items-center justify-center p-4 bg-background transition-colors duration-300">
      
      <div className="w-full max-w-md bg-surface rounded-2xl shadow-xl border border-border overflow-hidden animate-in fade-in zoom-in duration-300">
        
        {/* EN-T√äTE */}
        <div className="p-8 text-center bg-linear-to-b from-primary/10 to-transparent">
            <h1 className="text-3xl font-black text-primary mb-2">MagicWish</h1>
            <p className="text-muted text-sm">
                {isLoginMode ? 'Heureux de vous revoir !' : 'Rejoignez la communaut√©.'}
            </p>
        </div>

        {/* TABS (Connexion / Inscription) */}
        <div className="flex border-b border-border">
            <button 
                onClick={() => setIsLoginMode(true)}
                className={`flex-1 py-4 text-sm font-bold transition-colors ${isLoginMode ? 'border-b-2 border-primary text-primary bg-primary/5' : 'text-muted hover:text-foreground hover:bg-secondary'}`}
            >
                Connexion
            </button>
            <button 
                onClick={() => setIsLoginMode(false)}
                className={`flex-1 py-4 text-sm font-bold transition-colors ${!isLoginMode ? 'border-b-2 border-primary text-primary bg-primary/5' : 'text-muted hover:text-foreground hover:bg-secondary'}`}
            >
                Inscription
            </button>
        </div>

        {/* FORMULAIRE */}
        <div className="p-8 pt-6">
            <form onSubmit={handleSubmit} className="space-y-4">
                <div>
                    <label className="block text-xs font-bold text-muted uppercase mb-1">Email</label>
                    <input 
                        type="email" 
                        required
                        placeholder="exemple@email.com"
                        className="w-full p-3 rounded-lg border border-border bg-background text-foreground focus:ring-2 focus:ring-primary focus:border-primary outline-none transition"
                        value={email}
                        onChange={(e) => setEmail(e.target.value)}
                    />
                </div>
                <div>
                    <label className="block text-xs font-bold text-muted uppercase mb-1">Mot de passe</label>
                    <input 
                        type="password" 
                        required
                        placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢"
                        className="w-full p-3 rounded-lg border border-border bg-background text-foreground focus:ring-2 focus:ring-primary focus:border-primary outline-none transition"
                        value={password}
                        onChange={(e) => setPassword(e.target.value)}
                    />
                    {!isLoginMode && <p className="text-[10px] text-muted mt-1">Au moins 6 caract√®res.</p>}
                </div>

                <button 
                    type="submit"
                    disabled={isSubmitting}
                    className="w-full btn-primary py-3 rounded-xl shadow-lg mt-2 flex justify-center items-center"
                >
                    {isSubmitting 
                        ? <div className="w-5 h-5 border-2 border-white/30 border-t-white rounded-full animate-spin" />
                        : (isLoginMode ? 'Se connecter' : 'Cr√©er un compte')
                    }
                </button>
            </form>

            <div className="relative my-6">
                <div className="absolute inset-0 flex items-center"><div className="w-full border-t border-border"></div></div>
                <div className="relative flex justify-center text-xs uppercase"><span className="bg-surface px-2 text-muted">Ou continuer avec</span></div>
            </div>

            <button
                onClick={signInWithGoogle}
                className="w-full flex items-center justify-center gap-3 bg-white dark:bg-zinc-800 text-zinc-700 dark:text-zinc-200 border border-border hover:bg-zinc-50 dark:hover:bg-zinc-700 font-bold py-3 rounded-xl transition shadow-sm"
            >
                <svg className="w-5 h-5" viewBox="0 0 24 24">
                    <path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z" />
                    <path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z" />
                    <path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z" />
                    <path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z" />
                </svg>
                Google
            </button>
        </div>
        
        <div className="bg-secondary/50 p-4 text-center border-t border-border">
            <Link href="/" className="text-xs text-muted hover:text-primary transition">Retour √† l&apos;accueil</Link>
        </div>
      </div>
    </main>
  );
}
</file>

<file path="components/auth/VerificationBlocker.tsx">
// components/auth/VerificationBlocker.tsx
'use client';

import { useAuth } from '@/lib/AuthContext';
import { useState } from 'react';

export default function VerificationBlocker({ children }: { children: React.ReactNode }) {
    const { user, loading, sendVerificationEmail, reloadUser, logOut } = useAuth();
    const [isSending, setIsSending] = useState(false);
    const [isChecking, setIsChecking] = useState(false);

    // 1. Si chargement, on ne fait rien (ou on affiche un spinner)
    if (loading) return null;

    // 2. Si pas connect√©, on laisse passer (pour qu'il puisse aller sur /login ou /register)
    if (!user) return <>{children}</>;

    // 3. Si connect√© ET v√©rifi√©, on laisse passer l'application
    if (user.emailVerified) return <>{children}</>;

    // 4. SINON (Connect√© mais NON v√©rifi√©) : On affiche l'√©cran de blocage
    const handleResend = async () => {
        setIsSending(true);
        await sendVerificationEmail();
        setIsSending(false);
    };

    const handleCheck = async () => {
        setIsChecking(true);
        await reloadUser();
        setIsChecking(false);
    };

    return (
        <div className="min-h-screen flex items-center justify-center bg-background p-4">
            <div className="max-w-md w-full bg-surface border border-border rounded-xl shadow-lg p-8 text-center">
                <div className="w-16 h-16 bg-amber-100 text-amber-600 rounded-full flex items-center justify-center mx-auto mb-6">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-8 h-8">
                        <path strokeLinecap="round" strokeLinejoin="round" d="M16.5 10.5V6.75a4.5 4.5 0 10-9 0v3.75m-.75 11.25h10.5a2.25 2.25 0 002.25-2.25v-6.75a2.25 2.25 0 00-2.25-2.25H6.75a2.25 2.25 0 00-2.25 2.25v6.75a2.25 2.25 0 002.25 2.25z" />
                    </svg>
                </div>

                <h1 className="text-2xl font-bold text-foreground mb-2">V√©rification Requise</h1>
                
                <p className="text-muted text-sm mb-6 leading-relaxed">
                    Un email de validation a √©t√© envoy√© √† <strong>{user.email}</strong>.
                    <br/><br/>
                    Pour des raisons de s√©curit√©, vous devez valider votre adresse email avant d&apos;acc√©der √† MagicWish.
                </p>

                <div className="space-y-3">
                    <button 
                        onClick={handleCheck}
                        disabled={isChecking}
                        className="w-full btn-primary py-3 font-bold flex justify-center items-center gap-2"
                    >
                        {isChecking ? 'V√©rification...' : 'J\'ai valid√© mon email'}
                    </button>

                    <button 
                        onClick={handleResend}
                        disabled={isSending}
                        className="w-full bg-secondary hover:bg-border text-foreground py-3 rounded-xl font-medium text-sm transition"
                    >
                        {isSending ? 'Envoi en cours...' : 'Renvoyer l\'email'}
                    </button>
                </div>

                <div className="mt-8 pt-6 border-t border-border">
                    <button onClick={() => logOut()} className="text-xs text-muted hover:text-danger hover:underline">
                        Se d√©connecter / Changer de compte
                    </button>
                </div>
            </div>
        </div>
    );
}
</file>

<file path="components/CardmarketExportModal.tsx">
// components/CardmarketExportModal.tsx
'use client';

import { CardType } from '@/hooks/useCardCollection';
import { useState, useMemo } from 'react';
import toast from 'react-hot-toast';

type Props = {
    isOpen: boolean;
    onClose: () => void;
    cards: CardType[];
    listName: string;
};

// Fonction de formatage au standard Cardmarket (Plain Text Import)
const formatForCardmarket = (cards: CardType[]): string => {
    return cards
        .map(card => {
            // Le format requis est g√©n√©ralement : Qty Name (Set Code) [Foil]
            const qty = card.quantity;
            const name = card.name.split(' // ')[0].trim(); // Retire la double face si pr√©sente
            const setCode = card.setCode?.toUpperCase() || '';
            const foilTag = card.isFoil ? ' Foil' : '';

            // Format standard avec code d'√©dition entre parenth√®ses
            return `${qty} ${name} (${setCode})${foilTag}`;
        })
        .join('\n');
};

export default function CardmarketExportModal({ isOpen, onClose, cards, listName }: Props) {
    
    // Le texte format√© est calcul√© une seule fois
    const exportText = useMemo(() => formatForCardmarket(cards), [cards]);
    const [copied, setCopied] = useState(false);

    if (!isOpen) return null;

    const handleCopy = () => {
        navigator.clipboard.writeText(exportText);
        setCopied(true);
        toast.success("Texte copi√© ! Vous pouvez coller dans Cardmarket.");
        setTimeout(() => setCopied(false), 2000);
    };

    return (
        <div className="fixed inset-0 bg-black/60 flex items-center justify-center z-50 p-4 backdrop-blur-sm" onClick={onClose}>
            <div className="bg-surface rounded-xl p-6 max-w-lg w-full shadow-2xl border border-border flex flex-col max-h-[90vh]" onClick={e => e.stopPropagation()}>
                
                <h2 className="text-xl font-bold text-foreground mb-4">
                    Exporter : {listName}
                </h2>
                
                <p className="text-sm text-muted mb-4">
                    Copiez le texte ci-dessous et collez-le dans l&apos;outil **Plain Text Import** de Cardmarket pour ajouter vos cartes.
                </p>

                {/* Champ de texte avec le contenu export√© */}
                <textarea
                    readOnly
                    value={exportText}
                    rows={10}
                    className="w-full p-3 mb-4 rounded-lg border border-border bg-background text-foreground font-mono text-xs resize-none"
                />

                <div className="flex justify-between items-center">
                    <span className="text-xs text-muted">{cards.length} cartes pr√©par√©es.</span>
                    <button
                        onClick={handleCopy}
                        className={`px-4 py-2 rounded-lg text-sm font-bold transition shadow-md ${
                            copied ? 'bg-success text-white' : 'btn-primary'
                        }`}
                    >
                        {copied ? '‚úÖ Copi√© !' : 'üìã Copier le texte'}
                    </button>
                </div>
            </div>
        </div>
    );
}
</file>

<file path="components/CollectionTransferModal.tsx">

</file>

<file path="components/Footer.tsx">
// components/Footer.tsx
import React from 'react';
import Link from 'next/link';

export default function Footer() {
    const currentYear = new Date().getFullYear();

    return (
        <footer className="w-full border-t border-border bg-card/50 mt-auto">
            <div className="container mx-auto px-4 py-12">
                <div className="grid grid-cols-1 md:grid-cols-4 gap-8 lg:gap-12 mb-8">
                    
                    {/* Bloc Marque : Prend 2 colonnes sur 4 */}
                    <div className="md:col-span-2 flex flex-col gap-4">
                        <div>
                            <h3 className="font-bold text-xl text-primary flex items-center gap-2">
                                MagicWish
                            </h3>
                            <p className="text-sm text-muted-foreground mt-2 max-w-md leading-relaxed">
                                L&apos;outil de r√©f√©rence pour g√©rer vos collections de cartes Magic: The Gathering. 
                                Trouvez facilement les cartes que vous cherchez dans les collections de vos amis !
                            </p>
                        </div>
                    </div>

                    {/* Bloc Liens : Prend 1 colonne */}
                    <div className="flex flex-col gap-4">
                        <h3 className="font-semibold text-foreground">Informations</h3>
                        <ul className="space-y-2 text-sm text-muted-foreground">
                            {/* AJOUT DU LIEN PREMIUM ICI */}
                            <li>
                                <Link href="/pricing" className="hover:text-primary transition-colors font-medium text-blue-600 dark:text-blue-400">
                                    Offre Premium (1‚Ç¨)
                                </Link>
                            </li>
                            <li>
                                <Link href="/mentions-legales" className="hover:text-primary transition-colors">
                                    Mentions L√©gales & CGV
                                </Link>
                            </li>
                            <li>
                                <Link href="/politique-confidentialite" className="hover:text-primary transition-colors">
                                    Politique de Confidentialit√©
                                </Link>
                            </li>
                            <li>
                                <Link href="/politique-confidentialite" className="hover:text-primary transition-colors">
                                    Gestion des Cookies
                                </Link>
                            </li>
                        </ul>
                    </div>

                    {/* Bloc Disclaimer : Prend 1 colonne */}
                    <div className="flex flex-col gap-4">
                        <h3 className="font-semibold text-foreground">Droits d&apos;auteur</h3>
                        <div className="text-xs text-muted-foreground leading-relaxed space-y-2">
                            <p>
                                Magic: The Gathering est une marque d√©pos√©e de Wizards of the Coast LLC.
                            </p>
                            <p>
                                MagicWish n&apos;est pas affili√©, approuv√© ou sponsoris√© par Wizards of the Coast.
                            </p>
                        </div>
                    </div>
                </div>

                {/* Barre de copyright en bas */}
                <div className="border-t border-border pt-6 mt-2 flex flex-col md:flex-row justify-between items-center gap-4 text-xs text-muted-foreground">
                    <p>¬© {currentYear} MagicWish Project. Tous droits r√©serv√©s.</p>
                    <div className="flex items-center gap-4">
                        <span>Fait avec passion en Belgique üáßüá™</span>
                    </div>
                </div>
            </div>
        </footer>
    );
}
</file>

<file path="components/magic-card/CardImage.tsx">
'use client';

import Image from 'next/image';

const CARD_BACK_URL = "https://cards.scryfall.io/large/front/a/6/a6984342-f723-4e80-8e69-902d287a915f.jpg";

type Props = {
    imageUrl: string;
    imageBackUrl?: string | null;
    name: string;
    isFoil?: boolean;
    isSelectMode?: boolean;
    isSelected?: boolean;
    isFlipped: boolean;
    onFlip: () => void;
};

export default function CardImage({ 
    imageUrl, imageBackUrl, name, isFoil, 
    isSelectMode, isSelected, isFlipped, onFlip 
}: Props) {
    
    // Logique d'affichage : Si retourn√© et image dispo, on affiche le dos, sinon la face
    const currentImage = (isFlipped && imageBackUrl) ? imageBackUrl : imageUrl;

    return (
        <div className="relative w-full aspect-[2.5/3.5] bg-secondary rounded-lg overflow-hidden shrink-0 group/image shadow-sm border border-border/50">
            
            {/* IMAGE PRINCIPALE */}
            <Image
                src={currentImage || CARD_BACK_URL}
                alt={name}
                fill
                sizes="(max-width: 640px) 50vw, (max-width: 1024px) 33vw, 20vw"
                className="w-full h-full object-cover transition-transform duration-500 group-hover/image:scale-105"
                onError={(e) => { e.currentTarget.src = CARD_BACK_URL; }}
            />
            
            {/* OVERLAY DE S√âLECTION (Prioritaire) */}
            {isSelectMode && (
                <div className="absolute inset-0 z-30 bg-black/10 flex items-start justify-end p-2 pointer-events-none">
                     <div className={`w-6 h-6 rounded-full border-2 flex items-center justify-center transition-all shadow-md ${isSelected ? 'bg-primary border-primary scale-110' : 'bg-black/40 border-white/70'}`}>
                        {isSelected && <span className="text-white text-xs font-bold">‚úì</span>}
                    </div>
                </div>
            )}

            {/* BADGE FOIL */}
            {isFoil && !isSelectMode && (
                <div className="absolute bottom-0 right-0 z-20">
                    <span className="bg-linear-to-br from-amber-400 to-amber-600 text-white text-[10px] font-bold px-2 py-0.5 rounded-tl-lg shadow-sm block tracking-wide">
                        FOIL
                    </span>
                </div>
            )}

            {/* BOUTON FLIP (Seulement si recto-verso et pas en mode s√©lection) */}
            {imageBackUrl && !isSelectMode && (
                <button 
                    onClick={(e) => { 
                        e.preventDefault(); 
                        e.stopPropagation(); 
                        onFlip(); 
                    }} 
                    // Visible par d√©faut sur mobile, au survol sur desktop
                    className="absolute top-2 right-2 z-20 bg-black/60 hover:bg-black/80 text-white p-1.5 rounded-full backdrop-blur-md transition-all active:scale-95 shadow-md border border-white/20 opacity-100 lg:opacity-0 lg:group-hover/image:opacity-100"
                    title="Retourner la carte"
                >
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={2.5} stroke="currentColor" className="w-4 h-4">
                        <path strokeLinecap="round" strokeLinejoin="round" d="M16.023 9.348h4.992v-.001M2.985 19.644v-4.992m0 0h4.992m-4.993 0 3.181 3.183a8.25 8.25 0 0 0 13.803-3.7M4.031 9.865a8.25 8.25 0 0 1 13.803-3.7l3.181 3.182m0-4.991v4.99" />
                    </svg>
                </button>
            )}
        </div>
    );
}
</file>

<file path="components/magic-card/CardPrice.tsx">
'use client';

type Props = {
    displayPriceString: string;
    hasPrice: boolean;
    isFoil?: boolean; // Ajout√© pour compatibilit√© future si besoin
};

export default function CardPrice({ displayPriceString, hasPrice }: Props) {
    return (
        <p className={`font-bold text-[10px] whitespace-nowrap leading-none ${!hasPrice ? 'text-muted italic' : 'text-foreground'}`}>
            {displayPriceString}
        </p>
    );
}
</file>

<file path="components/magic-card/CardQuantity.tsx">
'use client';

type Props = {
    quantity: number;
    readOnly?: boolean;
    onIncrement?: () => void;
    onDecrement?: () => void;
};

export default function CardQuantity({ quantity, readOnly, onIncrement, onDecrement }: Props) {
    return (
        <div className="flex items-center bg-secondary rounded-sm p-px border border-border h-5">
            {!readOnly && (
                <button 
                    onClick={(e) => {e.stopPropagation(); onDecrement?.()}} 
                    className="w-3.5 h-full hover:bg-border text-muted hover:text-foreground rounded-xs flex items-center justify-center text-[10px] font-bold transition leading-none"
                >
                    -
                </button>
            )}
            
            <span className="text-[10px] leading-none flex items-center justify-center h-full px-1 font-bold text-foreground min-w-3">
                {quantity}
            </span>

            {!readOnly && (
                <button 
                    onClick={(e) => {e.stopPropagation(); onIncrement?.()}} 
                    className="w-3.5 h-full bg-primary/10 hover:bg-primary/20 text-primary rounded-xs flex items-center justify-center text-[10px] font-bold transition leading-none"
                >
                    +
                </button>
            )}
        </div>
    );
}
</file>

<file path="components/magic-card/CardTags.tsx">
// components/magic-card/CardTags.tsx
'use client';

type Props = {
    isWishlist?: boolean;
    readOnly?: boolean;
    isSelectMode?: boolean;
    isFoil?: boolean;
    isSpecificVersion?: boolean;
    onToggleAttribute?: (field: 'isFoil' | 'isSpecificVersion', val: boolean) => void;
    onMove?: () => void;
};

export default function CardTags({
    isWishlist, readOnly, isSelectMode, isFoil = false, isSpecificVersion = false,
    onToggleAttribute, onMove
}: Props) {
    
    // Helper pour g√©rer le clic proprement
    const handleToggle = (e: React.MouseEvent, field: 'isFoil' | 'isSpecificVersion', currentValue: boolean) => {
        e.stopPropagation();
        if (onToggleAttribute) {
            // CORRECTION ICI : On passe la valeur ACTUELLE (currentValue).
            // Votre hook useCardCollection fait `!value`, donc on lui donne la valeur brute.
            onToggleAttribute(field, currentValue); 
        }
    };

    return (
        <div className={`flex flex-wrap gap-1 mb-auto ${isSelectMode ? 'pointer-events-none opacity-50' : ''}`}>
            
            {/* CAS 1: COLLECTION (Badge non cliquable) */}
            {!isWishlist && (
                <span className={`text-[9px] px-1.5 py-0.5 rounded border font-medium flex-1 text-center ${
                    isFoil 
                    ? 'bg-amber-50 text-amber-700 border-amber-200 dark:bg-amber-900/30 dark:text-amber-400 dark:border-amber-800' 
                    : 'bg-secondary text-muted border-transparent'
                }`}>
                    {isFoil ? 'Foil' : 'Normal'}
                </span>
            )}

            {/* CAS 2: WISHLIST (Boutons cliquables) */}
            {isWishlist && onToggleAttribute && (
                <>
                    <button 
                        type="button"
                        onClick={(e) => handleToggle(e, 'isFoil', isFoil)}
                        className={`text-[9px] px-1.5 py-0.5 rounded border transition-colors font-medium flex-1 text-center ${
                            isFoil ? 'bg-amber-50 text-amber-700 border-amber-200 dark:bg-amber-900/30 dark:text-amber-400 dark:border-amber-800' : 'bg-secondary text-muted border-transparent hover:bg-border'
                        }`}
                    >
                        {isFoil ? 'Foil' : 'Normal'}
                    </button>
                    
                    <button 
                        type="button"
                        onClick={(e) => handleToggle(e, 'isSpecificVersion', isSpecificVersion)}
                        className={`text-[9px] px-1.5 py-0.5 rounded border transition-colors font-medium flex-1 text-center ${
                            isSpecificVersion ? 'bg-primary/10 text-primary border-primary/30' : 'bg-secondary text-muted border-transparent'
                        }`}
                    >
                        {isSpecificVersion ? 'Exact' : 'Auto'}
                    </button>
                </>
            )}
            
            {/* BOUTON MOVE (Acheter) */}
            {isWishlist && !readOnly && !isSelectMode && onMove && (
                <button 
                    type="button"
                    onClick={(e) => { e.stopPropagation(); onMove(); }}
                    className="text-[9px] px-1.5 py-0.5 rounded border transition-colors font-bold flex-1 text-center bg-surface text-success border-success/30 hover:bg-success/5"
                    title="J'ai re√ßu cette carte"
                >
                    Achet√©
                </button>
            )}
        </div>
    );
}
</file>

<file path="components/magic-card/CardTradeQuantity.tsx">
'use client';

type Props = {
    quantity: number;
    tradeQty: number;
    onIncrementTrade?: () => void;
    onDecrementTrade?: () => void;
};

export default function CardTradeQuantity({ quantity, tradeQty, onIncrementTrade, onDecrementTrade }: Props) {
    return (
        <div className="flex items-center bg-success/10 border border-success/20 rounded-sm p-px h-5">
            <button 
                onClick={(e) => {e.stopPropagation(); onDecrementTrade?.()}} 
                disabled={tradeQty <= 0}
                className="w-3.5 h-full hover:bg-success/20 text-success/70 hover:text-success rounded-xs flex items-center justify-center text-[10px] font-bold transition leading-none disabled:opacity-30" 
            >
                -
            </button>
            
            <span className="text-[10px] leading-none flex items-center justify-center h-full px-1 font-bold text-success min-w-3">
                {tradeQty}
            </span>

            <button 
                onClick={(e) => {e.stopPropagation(); onIncrementTrade?.()}} 
                disabled={tradeQty >= quantity}
                className="w-3.5 h-full hover:bg-success/20 text-success/70 hover:text-success rounded-xs flex items-center justify-center text-[10px] font-bold transition leading-none disabled:opacity-30" 
            >
                +
            </button>
        </div>
    );
}
</file>

<file path="components/search/SearchToolbar.tsx">
// components/search/SearchToolbar.tsx
'use client';

interface SearchToolbarProps {
    isSelectMode: boolean;
    setIsSelectMode: (val: boolean) => void;
    totalResults: number;
}

export default function SearchToolbar({
    isSelectMode,
    setIsSelectMode,
    totalResults
}: SearchToolbarProps) {
    if (totalResults === 0) return null;

    return (
        <div className="flex flex-col gap-4 mb-6 animate-in fade-in slide-in-from-top-2">
            <div className="flex items-center gap-2 overflow-x-auto pb-2 -mx-4 px-4 md:mx-0 md:px-0 no-scrollbar">
                
                <button 
                    onClick={() => setIsSelectMode(!isSelectMode)}
                    className={`shrink-0 px-3 py-2 rounded-lg text-sm font-medium transition shadow-sm border flex items-center gap-2 whitespace-nowrap ${isSelectMode ? 'bg-primary text-primary-foreground border-primary' : 'bg-surface hover:bg-secondary text-foreground border-border'}`}
                >
                    {isSelectMode ? 'Annuler la s√©lection' : 'S√©lectionner'}
                </button>

                {!isSelectMode && (
                    <span className="text-xs text-muted ml-auto">
                        {totalResults} r√©sultat(s)
                    </span>
                )}
            </div>
        </div>
    );
}
</file>

<file path="components/ThemeProvider.tsx">
'use client';

import { ThemeProvider as NextThemesProvider } from 'next-themes';
import { type ThemeProviderProps } from 'next-themes'; // corrig√© l'import

export function ThemeProvider({ children, ...props }: ThemeProviderProps) {
  return <NextThemesProvider {...props}>{children}</NextThemesProvider>;
}
</file>

<file path="components/trades/TradeSelectionTable.tsx">
// components/trades/TradeSelectionTable.tsx
'use client';

import { CardType } from '@/hooks/useCardCollection';
import { ScryfallRawData } from '@/lib/cardUtils';

interface TradeSelectionTableProps {
    cards: CardType[];
    onRemove: (id: string) => void;
    onUpdatePrice: (id: string, newPrice: number) => void;
    colorClass: 'text-danger' | 'text-success';
    emptyLabel: string;
}

export default function TradeSelectionTable({ 
    cards, 
    onRemove, 
    onUpdatePrice, 
    colorClass, 
    emptyLabel 
}: TradeSelectionTableProps) {
    if (cards.length === 0) return (
        <div className="flex-1 flex items-center justify-center border-b border-border bg-secondary/10 text-muted text-sm italic p-8">{emptyLabel}</div>
    );
    
    return (
        <div className="flex-1 overflow-hidden flex flex-col bg-surface border-b border-border shadow-sm">
            <div className="overflow-y-auto custom-scrollbar flex-1">
                <table className="w-full text-xs text-left border-collapse">
                    <thead className="bg-secondary text-muted sticky top-0 z-10 font-semibold uppercase">
                        <tr>
                            <th className="px-2 py-2 text-center w-8">Qt√©</th>
                            <th className="px-2 py-2">Nom</th>
                            <th className="px-2 py-2 w-10 text-center">Set</th>
                            <th className="px-2 py-2 w-10 text-center">N¬∞</th>
                            <th className="px-2 py-2 w-10 text-center">Foil</th>
                            <th className="px-2 py-2 text-right w-16">Prix</th>
                            <th className="px-2 py-2 w-8"></th>
                        </tr>
                    </thead>
                    <tbody className="divide-y divide-border">
                        {cards.map((card, i) => {
                            const key = `${card.id}-${i}`; 
                            const currentPrice = card.customPrice !== undefined ? card.customPrice : (card.price || 0);
                            const scryData = card.scryfallData as ScryfallRawData | undefined;
                            const collectorNum = scryData?.collector_number || '?';
                            
                            return (
                                <tr key={key} className="hover:bg-secondary/50 transition-colors text-foreground select-none">
                                    <td className={`px-2 py-1.5 text-center font-bold ${colorClass} bg-opacity-10`}>{card.quantity}</td>
                                    <td className="px-2 py-1.5 font-medium truncate max-w-[120px]" title={card.name}>{card.name}</td>
                                    <td className="px-2 py-1.5 text-center"><span className="text-[9px] font-mono bg-secondary text-muted px-1 rounded border border-border">{card.setCode?.toUpperCase()}</span></td>
                                    <td className="px-2 py-1.5 text-center text-muted font-mono text-[10px]">{collectorNum}</td>
                                    <td className="px-2 py-1.5 text-center">{card.isFoil && <span className="text-[9px] font-bold text-amber-600 bg-amber-100 px-1 rounded">Foil</span>}</td>
                                    
                                    {/* INPUT PRIX */}
                                    <td className="px-2 py-1.5 text-right">
                                        <div className="flex items-center justify-end gap-1">
                                            <input 
                                                type="number" 
                                                min="0" 
                                                step="0.01"
                                                className="w-16 p-1 text-right bg-background border border-border rounded text-xs outline-none focus:border-primary"
                                                value={currentPrice}
                                                onChange={(e) => onUpdatePrice(card.id, parseFloat(e.target.value) || 0)}
                                            />
                                            <span className="text-muted">‚Ç¨</span>
                                        </div>
                                    </td>
                                    
                                    <td className="px-2 py-1.5 text-center"><button onClick={() => onRemove(card.id)} className="text-muted hover:text-danger transition px-1 font-bold">‚úï</button></td>
                                </tr>
                            );
                        })}
                    </tbody>
                </table>
            </div>
        </div>
    );
}
</file>

<file path="components/wishlist/WishlistToolbar.tsx">
// components/wishlist/WishlistToolbar.tsx
'use client';

import DeleteAllButton from '@/components/DeleteAllButton';

interface WishlistToolbarProps {
    isSelectMode: boolean;
    setIsSelectMode: (val: boolean) => void;
    onOpenHub: () => void;
    targetListId: string;
}

export default function WishlistToolbar({
    isSelectMode,
    setIsSelectMode,
    onOpenHub,
    targetListId
}: WishlistToolbarProps) {

    return (
        <div className="flex flex-col gap-4 mb-6">
            <div className="flex items-center gap-2 overflow-x-auto pb-2 -mx-4 px-4 md:mx-0 md:px-0 no-scrollbar">
                
                {/* Mode S√©lection */}
                <button 
                    onClick={() => { setIsSelectMode(!isSelectMode); }}
                    className={`shrink-0 px-3 py-2 rounded-lg text-sm font-medium transition shadow-sm border flex items-center gap-2 whitespace-nowrap ${isSelectMode ? 'bg-primary text-primary-foreground border-primary' : 'bg-surface hover:bg-secondary text-foreground border-border'}`}
                >
                    {isSelectMode ? 'Annuler' : 'S√©lectionner'}
                </button>

                {/* Actions (cach√©es en mode s√©lection) */}
                {!isSelectMode && (
                    <>
                        <div className="shrink-0">
                            {/* Le bouton Vider ne s'affiche pas pour la vue globale */}
                            {targetListId !== 'GLOBAL_VIEW' && (
                                <DeleteAllButton targetCollection="wishlist" />
                            )}
                        </div>
                        
                        <button 
                            onClick={onOpenHub}
                            className="btn-primary text-sm whitespace-nowrap"
                        >
                            Importer/Exporter
                        </button>
                    </>
                )}
            </div>
        </div>
    );
}
</file>

<file path="firebase.json">
{
  "firestore": {
    "rules": "firestore.rules",
    "indexes": "firestore.indexes.json"
  }
}
</file>

<file path="hooks/useColumnPreference.ts">
// hooks/useColumnPreference.ts
'use client';

import { useState, useEffect } from 'react';

export function useColumnPreference(storageKey: string, defaultValue: number) {
  const [columns, setColumnsState] = useState(defaultValue);
  const [isLoaded, setIsLoaded] = useState(false);

  useEffect(() => {
    // Lecture au montage du composant (c√¥t√© client uniquement)
    const saved = localStorage.getItem(storageKey);
    if (saved) {
      const parsed = parseInt(saved, 10);
      if (!isNaN(parsed) && parsed > 0) {
        // eslint-disable-next-line react-hooks/set-state-in-effect
        setColumnsState(parsed);
      }
    }
    setIsLoaded(true);
  }, [storageKey]);

  const setColumns = (val: number) => {
    setColumnsState(val);
    localStorage.setItem(storageKey, val.toString());
  };

  return { columns, setColumns, isLoaded };
}
</file>

<file path="hooks/useDebounceUpdate.ts">
import { useCallback, useRef } from 'react';

/**
 * Hook qui permet de diff√©rer l'ex√©cution d'une fonction (ex: √©criture en DB)
 * tout en permettant une mise √† jour locale instantan√©e (UI Optimiste).
 */
export function useDebouncedUpdate<T extends unknown[]>(
    callback: (...args: T) => void,
    delay: number
) {
    // On utilise une ref pour stocker le timer afin qu'il survive aux re-rendus
    const timeoutRef = useRef<NodeJS.Timeout | null>(null);
    
    // On utilise une ref pour la callback pour toujours avoir la version la plus r√©cente
    // sans avoir √† la mettre dans les d√©pendances du useCallback
    const callbackRef = useRef(callback);
    // eslint-disable-next-line react-hooks/refs
    callbackRef.current = callback;

    const debouncedFunction = useCallback((...args: T) => {
        // Si un timer existe d√©j√† (appel pr√©c√©dent r√©cent), on l'annule
        if (timeoutRef.current) {
            clearTimeout(timeoutRef.current);
        }

        // On lance un nouveau timer
        timeoutRef.current = setTimeout(() => {
            callbackRef.current(...args);
        }, delay);
    }, [delay]);

    // Fonction pour annuler manuellement si besoin (ex: d√©montage composant)
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const cancel = useCallback(() => {
        if (timeoutRef.current) {
            clearTimeout(timeoutRef.current);
        }
    }, []);

    return debouncedFunction;
}
</file>

<file path="lib/firebase.ts">
import { initializeApp, getApps, getApp } from 'firebase/app';
import { getAuth } from 'firebase/auth';
import { getFirestore } from 'firebase/firestore';

const firebaseConfig = {
  apiKey: process.env.NEXT_PUBLIC_FIREBASE_API_KEY,
  authDomain: process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN,
  projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID,
  storageBucket: process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET,
  messagingSenderId: process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID,
  appId: process.env.NEXT_PUBLIC_FIREBASE_APP_ID,
};

// Initialisation unique (√©vite les erreurs de re-init en dev)
const app = !getApps().length ? initializeApp(firebaseConfig) : getApp();

export const auth = getAuth(app);
export const db = getFirestore(app);
</file>

<file path="lib/globals.d.ts">
// Fichier : lib/globals.d.ts (√Ä CR√âER)

declare global {
  interface Window {
    // D√©claration pour Google AdSense
    adsbygoogle: unknown[]; 
  }
}

// Assurez-vous que ce fichier est inclus dans la propri√©t√© "include" de votre tsconfig.json
</file>

<file path="lib/importRules.ts">
// lib/importRules.ts
import { ScryfallRawData } from '@/lib/cardUtils';

export type ValidationResult = {
  isValid: boolean;
  reason?: string;
  suggestedAction?: 'FORCE_FOIL' | 'FORCE_NONFOIL' | 'REJECT';
};

/**
 * V√©rifie si une demande d'import est valide par rapport aux donn√©es Scryfall.
 * Emp√™che d'importer une version qui n'existe pas physiquement.
 */
export function validateImport(
  cardData: ScryfallRawData, 
  requestedFoil: boolean
): ValidationResult {
  
  // S√©curisation des prix et finitions (conversion en nombre pour √©viter les erreurs)
  const priceNormal = parseFloat(cardData.prices?.eur || "0");
  const priceFoil = parseFloat(cardData.prices?.eur_foil || "0");

  // Une version existe si elle est dans 'finishes' OU si elle a un prix
  // (Parfois finishes est incomplet sur les vieux sets, le prix est un bon indicateur de backup)
  const hasNonFoil = cardData.finishes?.includes('nonfoil') || priceNormal > 0;
  // On ajoute 'etched' comme valide pour le foil
  const hasFoil = cardData.finishes?.includes('foil') || cardData.finishes?.includes('etched') || priceFoil > 0;

  // Cas 1 : L'utilisateur VEUT du Foil
  if (requestedFoil) {
    if (!hasFoil) {
      return { 
        isValid: false, 
        reason: `La carte "${cardData.name}" n'existe pas en version Foil pour cette √©dition (${cardData.set.toUpperCase()}).`,
        suggestedAction: hasNonFoil ? 'FORCE_NONFOIL' : 'REJECT'
      };
    }
  } 
  // Cas 2 : L'utilisateur VEUT du Normal (ou n'a rien pr√©cis√©)
  else {
    if (!hasNonFoil) {
      // Si elle n'existe QU'EN Foil (ex: Commander decks, From the Vault...)
      if (hasFoil) {
          return { 
            isValid: false, 
            reason: `La carte "${cardData.name}" n'existe qu'en Foil (Edition sp√©ciale).`,
            suggestedAction: 'FORCE_FOIL'
          };
      }
      return {
          isValid: false,
          reason: `Cette carte ne semble exister ni en Foil ni en Normal pour cette √©dition.`,
          suggestedAction: 'REJECT'
      };
    }
  }

  return { isValid: true };
}
</file>

<file path="lib/services/collectionService.ts">
// lib/services/collectionService.ts
import { db } from '@/lib/firebase';
import { doc, runTransaction, increment, serverTimestamp } from 'firebase/firestore';
import { CardType } from '@/hooks/useCardCollection';

/**
 * D√©place une carte d'une Wishlist vers la Collection principale.
 * G√®re la transaction atomique (Ajout Collection + Suppression Wishlist).
 */
export async function moveCardFromWishlistToCollection(
    userId: string,
    card: CardType,
    originListId: string = 'default'
): Promise<{ success: boolean; error?: string }> {
    
    try {
        const sourcePath = originListId === 'default' 
            ? 'wishlist' 
            : `wishlists_data/${originListId}/cards`;
            
        const wishlistRef = doc(db, 'users', userId, sourcePath, card.id);
        const collectionRef = doc(db, 'users', userId, 'collection', card.id);

        await runTransaction(db, async (transaction) => {
            // Lecture (n√©cessaire avant √©criture dans une transaction)
            const colDoc = await transaction.get(collectionRef);

            // √âcritures
            if (colDoc.exists()) {
                // Si la carte existe, on incr√©mente
                transaction.update(collectionRef, { 
                    quantity: increment(card.quantity) 
                });
            } else {
                // Sinon on cr√©e
                transaction.set(collectionRef, { 
                    ...card,
                    // On s'assure que les champs sont propres
                    imageBackUrl: card.imageBackUrl || null, 
                    wishlistId: null, // Elle n'est plus dans une wishlist
                    addedAt: serverTimestamp(), // Utilisation du timestamp client
                    isFoil: card.isFoil || false,
                    isForTrade: false // Par d√©faut, pas √† l'√©change quand on vient de l'acheter
                });
            }

            // Suppression de la source
            transaction.delete(wishlistRef);
        });

        return { success: true };

    } catch (error: unknown) {
        console.error("Erreur Service Collection:", error);
        let msg = "Erreur inconnue";
        if (error instanceof Error) msg = error.message;
        return { success: false, error: msg };
    }
}
</file>

<file path="lib/types/chat.ts">
// lib/types/chat.ts
import { FieldValue, Timestamp } from 'firebase/firestore';

export type ChatType = 'direct' | 'group';

export interface Chat {
  id: string;
  type: ChatType;
  participants: string[];
  lastMessage?: {
    text: string;
    senderId: string;
    createdAt: Timestamp | FieldValue;
  };
  playgroupId?: string; // Optionnel : lien avec un playgroup
  createdAt: Timestamp | FieldValue;
}

export interface Message {
  id?: string;
  senderId: string;
  senderName: string;
  text: string;
  createdAt: Timestamp | FieldValue;
}
</file>

<file path="postcss.config.mjs">
const config = {
  plugins: {
    "@tailwindcss/postcss": {},
  },
};

export default config;
</file>

<file path="public/ads.txt">
google.com, pub-5492732016245735, DIRECT, f08c47fec0942fa0
</file>

<file path="public/manifest.json">
{
  "name": "MagicWish",
  "short_name": "MagicWish",
  "description": "Votre wishlist et collection de cartes Magic",
  "start_url": "/",
  "display": "standalone",
  "background_color": "#ffffff",
  "theme_color": "#2563eb",
  "orientation": "portrait",
  "icons": [
    {
      "src": "/file.svg",
      "sizes": "any",
      "type": "image/svg+xml"
    }
  ]
}
</file>

<file path="vercel.json">
{
  "crons": [
    {
      "path": "/api/cron/cleanup-users",
      "schedule": "0 4 * * *" 
    }
  ]
}
</file>

<file path="app/actions/collection.ts">
// app/actions/collection.ts
'use server';

import { getAdminFirestore } from '@/lib/firebase-admin';
import { FieldValue } from 'firebase-admin/firestore';
import { updateUserStats } from '@/app/actions/stats';
import { checkAutoMatch, removeAutoMatchNotification } from '@/app/actions/matching';
import { normalizeCardData, ScryfallRawData } from '@/lib/cardUtils'; // Import de la fonction normalis√©e

// Interfaces
interface ScryfallCollectionResponse {
    data?: ScryfallRawData[];
    not_found?: unknown[];
    warnings?: unknown[];
}

interface FirestoreCardData {
    name?: string;
    quantity?: number;
    quantityForTrade?: number;
    isForTrade?: boolean;
    isFoil?: boolean;
    [key: string]: unknown;
}

// --- ACTUALISATION DES PRIX ET DES DONN√âES (CMC/COULEURS) ---
export async function refreshUserCollectionPrices(userId: string): Promise<{ success: boolean; updatedCount: number; error?: string }> {
    const db = getAdminFirestore();

    try {
        const collectionRef = db.collection(`users/${userId}/collection`);
        const snapshot = await collectionRef.get();

        if (snapshot.empty) {
            return { success: true, updatedCount: 0 };
        }

        const cardsToUpdate = snapshot.docs.map(doc => ({ id: doc.id }));
        
        const chunks = [];
        for (let i = 0; i < cardsToUpdate.length; i += 75) {
            chunks.push(cardsToUpdate.slice(i, i + 75));
        }

        let updatedCount = 0;
        let batch = db.batch();
        let operationCounter = 0;

        for (const chunk of chunks) {
            const identifiers = chunk.map(c => ({ id: c.id }));

            const response = await fetch('https://api.scryfall.com/cards/collection', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ identifiers }),
                cache: 'no-store'
            });

            if (!response.ok) continue;

            const scryData = (await response.json()) as ScryfallCollectionResponse;
            const foundCards = scryData.data || [];

            for (const scryCard of foundCards) {
                // Utilisation de normalizeCardData pour obtenir l'identit√© couleur correcte
                const normalized = normalizeCardData(scryCard);
                
                const cardRef = collectionRef.doc(scryCard.id);
                
                batch.update(cardRef, {
                    price: normalized.price,
                    customPrice: FieldValue.delete(), 
                    lastPriceUpdate: new Date(),
                    scryfallData: scryCard,
                    // --- ENREGISTREMENT DES NOUVEAUX CHAMPS ---
                    cmc: normalized.cmc,
                    colors: normalized.colors
                });
                
                updatedCount++;
                operationCounter++;

                if (operationCounter >= 450) {
                    await batch.commit();
                    batch = db.batch();
                    operationCounter = 0;
                }
            }
            
            await new Promise(resolve => setTimeout(resolve, 50));
        }

        if (operationCounter > 0) {
            await batch.commit();
        }

        if (updatedCount > 0) {
            await updateUserStats(userId);
        }

        return { success: true, updatedCount };

    } catch (error: unknown) {
        console.error("Erreur serveur refresh prix:", error);
        let message = "Erreur inconnue lors de la mise a jour";
        if (error instanceof Error) message = error.message;
        return { success: false, updatedCount: 0, error: message };
    }
}

// --- GESTION DE MASSE (TRADE / BINDER) ---
export async function bulkSetTradeStatusAction(
    userId: string, 
    action: 'excess' | 'all' | 'reset', 
    threshold: number = 4
): Promise<{ success: boolean; count: number; error?: string }> {
    const db = getAdminFirestore();

    try {
        const collectionRef = db.collection(`users/${userId}/collection`);
        const snapshot = await collectionRef.get();

        if (snapshot.empty) return { success: true, count: 0 };

        let batch = db.batch();
        let opCount = 0;
        let totalUpdated = 0;
        
        const cardsToScan: { id: string, name: string, isFoil: boolean }[] = [];
        const cardsToRemoveNotif: string[] = [];

        for (const doc of snapshot.docs) {
            const data = doc.data() as FirestoreCardData;
            const quantity = typeof data.quantity === 'number' ? data.quantity : 0;
            const currentTradeQty = typeof data.quantityForTrade === 'number' ? data.quantityForTrade : 0;
            
            let shouldUpdate = false;
            let newTradeQty = 0;

            if (action === 'reset') {
                if (currentTradeQty > 0) {
                    shouldUpdate = true;
                    newTradeQty = 0;
                }
            } 
            else if (action === 'all') {
                if (currentTradeQty !== quantity) {
                    shouldUpdate = true;
                    newTradeQty = quantity;
                }
            } 
            else if (action === 'excess') {
                const tradeableQty = Math.max(0, quantity - threshold);
                if (currentTradeQty !== tradeableQty) {
                    shouldUpdate = true;
                    newTradeQty = tradeableQty;
                }
            }

            if (shouldUpdate) {
                batch.update(doc.ref, { 
                    quantityForTrade: newTradeQty,
                    isForTrade: newTradeQty > 0 
                });
                opCount++;
                totalUpdated++;

                if (newTradeQty > 0) {
                    cardsToScan.push({ 
                        id: doc.id, 
                        name: data.name || '', 
                        isFoil: !!data.isFoil 
                    });
                } else {
                    cardsToRemoveNotif.push(doc.id);
                }

                if (opCount >= 450) {
                    await batch.commit();
                    batch = db.batch();
                    opCount = 0;
                }
            }
        }

        if (opCount > 0) {
            await batch.commit();
        }
            
        if (cardsToScan.length > 0) {
            await checkAutoMatch(userId, cardsToScan.slice(0, 50)); 
        }
        if (cardsToRemoveNotif.length > 0) {
            await removeAutoMatchNotification(userId, cardsToRemoveNotif);
        }

        return { success: true, count: totalUpdated };

    } catch (error: unknown) {
        console.error("Erreur bulk trade:", error);
        let message = "Erreur serveur";
        if (error instanceof Error) message = error.message;
        return { success: false, count: 0, error: message };
    }
}

export async function bulkRemoveCardsAction(userId: string, cardIds: string[]): Promise<{ success: boolean; count: number; error?: string }> {
    const db = getAdminFirestore();
    try {
        let batch = db.batch();
        let opCount = 0;
        
        for (const id of cardIds) {
            const ref = db.doc(`users/${userId}/collection/${id}`);
            batch.delete(ref);
            opCount++;

            if (opCount >= 450) {
                await batch.commit();
                batch = db.batch();
                opCount = 0;
            }
        }

        if (opCount > 0) {
            await batch.commit();
        }
        
        await removeAutoMatchNotification(userId, cardIds);
        await updateUserStats(userId);

        return { success: true, count: cardIds.length };

    } catch (error: unknown) {
        console.error("Erreur bulk delete:", error);
        let message = "Erreur serveur";
        if (error instanceof Error) message = error.message;
        return { success: false, count: 0, error: message };
    }
}

export async function bulkUpdateAttributeAction(
    userId: string, 
    cardIds: string[], 
    field: string, 
    value: boolean | number
): Promise<{ success: boolean; count: number; error?: string }> {
    const db = getAdminFirestore();
    try {
        if (cardIds.length === 0) return { success: true, count: 0 };

        let batch = db.batch();
        let opCount = 0;
        
        const cardsToScan: { id: string, name: string, isFoil: boolean }[] = [];
        const cardsToRemoveNotif: string[] = [];
        const needsScan = field === 'quantityForTrade' || field === 'isForTrade';

        if (needsScan) {
            const chunkIds = [];
            for (let i = 0; i < cardIds.length; i += 50) {
                chunkIds.push(cardIds.slice(i, i + 50));
            }

            for (const chunk of chunkIds) {
                const refs = chunk.map(id => db.doc(`users/${userId}/collection/${id}`));
                const snaps = await db.getAll(...refs);

                for (const snap of snaps) {
                    if (snap.exists) {
                        const data = snap.data() as FirestoreCardData;
                        const updateData: Record<string, unknown> = { [field]: value };
                        
                        if (field === 'quantityForTrade') {
                            const numValue = value as number;
                            updateData.isForTrade = numValue > 0;
                            if (numValue > 0) cardsToScan.push({ id: snap.id, name: data.name || '', isFoil: !!data.isFoil });
                            else cardsToRemoveNotif.push(snap.id);
                        } 
                        else if (field === 'isForTrade') {
                            const boolValue = value as boolean;
                            const newQty = boolValue ? (data.quantity || 1) : 0;
                            updateData.quantityForTrade = newQty;
                            if (boolValue) cardsToScan.push({ id: snap.id, name: data.name || '', isFoil: !!data.isFoil });
                            else cardsToRemoveNotif.push(snap.id);
                        }

                        batch.update(snap.ref, updateData);
                        opCount++;
                    }
                }
                
                if (opCount >= 400) {
                    await batch.commit();
                    batch = db.batch();
                    opCount = 0;
                }
            }
        } else {
            for (const id of cardIds) {
                const ref = db.doc(`users/${userId}/collection/${id}`);
                batch.update(ref, { [field]: value });
                opCount++;

                if (opCount >= 450) {
                    await batch.commit();
                    batch = db.batch();
                    opCount = 0;
                }
            }
        }

        if (opCount > 0) {
            await batch.commit();
        }

        if (field === 'isFoil') await updateUserStats(userId);
        if (cardsToScan.length > 0) await checkAutoMatch(userId, cardsToScan.slice(0, 50));
        if (cardsToRemoveNotif.length > 0) await removeAutoMatchNotification(userId, cardsToRemoveNotif);

        return { success: true, count: cardIds.length };

    } catch (error: unknown) {
        console.error("Erreur bulk update:", error);
        let message = "Erreur serveur";
        if (error instanceof Error) message = error.message;
        return { success: false, count: 0, error: message };
    }
}
</file>

<file path="app/actions/trade-proposal.ts">
// app/actions/trade-proposal.ts
'use server';

import { getAdminFirestore } from '@/lib/firebase-admin';
import { FieldValue } from 'firebase-admin/firestore';
import { z } from 'zod';
import { CardSchema } from '@/lib/validators';

// On r√©utilise CardSchema pour d√©finir la structure de la proposition
const ProposalSchema = z.object({
  senderUid: z.string().min(1),
  senderName: z.string().min(1),
  receiverUid: z.string().min(1),
  receiverName: z.string().min(1),
  itemsGiven: z.array(CardSchema),
  itemsReceived: z.array(CardSchema)
});

type ActionResponse = {
  success: boolean;
  error?: string;
  // Nouveau champ pour indiquer un conflit de proposition
  proposalConflict?: boolean; 
  existingTradeId?: string; // ID de la proposition existante
};

// Fonction utilitaire pour normaliser les cartes pour une comparaison stricte
const normalizeCards = (cards: z.infer<typeof CardSchema>[]) => 
    cards
        .map(c => ({ 
            id: c.id, 
            qty: c.quantity, 
            // Ajout du champ pour la comparaison de version sp√©cifique (Foil/Exact)
            isFoil: c.isFoil || false,
            isSpecific: c.isSpecificVersion || false,
        }))
        // Trie par ID pour garantir que deux propositions avec le m√™me contenu mais un ordre diff√©rent sont consid√©r√©es comme identiques
        .sort((a, b) => a.id.localeCompare(b.id));


export async function proposeTradeAction(rawData: unknown): Promise<ActionResponse> {
  const db = getAdminFirestore();

  try {
    // 1. PARSING & VALIDATION
    const data = ProposalSchema.parse(rawData);

    // 2. PR√âPARATION DES HASHES POUR LA COMPARAISON
    const normalizedGiven = normalizeCards(data.itemsGiven);
    const normalizedReceived = normalizeCards(data.itemsReceived);
    
    // Convertir les objets normalis√©s en cha√Æne JSON pour une comparaison stricte
    const hashGiven = JSON.stringify(normalizedGiven);
    const hashReceived = JSON.stringify(normalizedReceived);

    // 3. V√âRIFICATION DES DOUBLONS EN COURS (pending)
    
    const duplicateQuery = db.collection('trades')
      .where('senderUid', '==', data.senderUid)
      .where('receiverUid', '==', data.receiverUid)
      .where('status', '==', 'pending')
      .limit(10); 

    const snapshot = await duplicateQuery.get();
    let existingTradeId: string | null = null;
    let proposalsAreIdentical = false;

    // V√©rification approfondie du contenu
    snapshot.docs.forEach(doc => {
      const existingData = doc.data();
      
      const existingNormalizedGiven = normalizeCards(existingData.itemsGiven as z.infer<typeof CardSchema>[]);
      const existingNormalizedReceived = normalizeCards(existingData.itemsReceived as z.infer<typeof CardSchema>[]);
      
      const existingHashGiven = JSON.stringify(existingNormalizedGiven);
      const existingHashReceived = JSON.stringify(existingNormalizedReceived);

      // Comparaison stricte des deux c√¥t√©s de l'√©change
      if (existingHashGiven === hashGiven && existingHashReceived === hashReceived) {
          proposalsAreIdentical = true;
          existingTradeId = doc.id;
      }
    });

    // 4. GESTION DU CONFLIT
    if (proposalsAreIdentical && existingTradeId) {
        // Renvoie une r√©ponse sp√©ciale pour le client
        return { 
            success: false, 
            error: "Une proposition identique est d√©j√† en attente.", 
            proposalConflict: true, 
            existingTradeId
        };
    }

    // 5. ENREGISTREMENT (Si pas de doublon)
    await db.collection('trades').add({
      senderUid: data.senderUid,
      senderName: data.senderName,
      receiverUid: data.receiverUid,
      receiverName: data.receiverName,
      itemsGiven: data.itemsGiven,
      itemsReceived: data.itemsReceived,
      status: 'pending',
      createdAt: FieldValue.serverTimestamp()
    });

    return { success: true };

  } catch (error: unknown) {
    console.error("Erreur proposeTradeAction:", error);
    let errorMessage = "Erreur lors de la proposition";
    
    if (error instanceof z.ZodError) {
      errorMessage = "Donn√©es invalides : " + error.issues.map(i => i.message).join(', ');
    } else if (error instanceof Error) {
      errorMessage = error.message;
    }

    return { success: false, error: errorMessage };
  }
}
</file>

<file path="app/admin/page.tsx">
// app/admin/page.tsx
'use client';

import { useState, useEffect, useMemo } from 'react';
import { useAuth } from '@/lib/AuthContext';
import { useRouter } from 'next/navigation';
import { db } from '@/lib/firebase';
import { collection, onSnapshot, query, orderBy, DocumentData, Timestamp, updateDoc, doc, deleteDoc } from 'firebase/firestore';
import toast from 'react-hot-toast';
import { forceUpdateAllUsersCardsAction } from '@/app/actions/admin';

interface FeedbackItem extends DocumentData {
    id: string;
    userId: string;
    username: string;
    suggestion: string;
    createdAt: Timestamp;
    status: 'new' | 'read' | 'interesting' | 'in_progress' | 'implemented';
}

const STATUS_COLORS: Record<FeedbackItem['status'], string> = {
    new: 'bg-red-500 text-white',
    read: 'bg-gray-500 text-white',
    interesting: 'bg-purple-600 text-white',
    in_progress: 'bg-yellow-500 text-black',
    implemented: 'bg-green-600 text-white',
};

const formatTimeAgo = (timestamp: Timestamp): string => {
    if (!timestamp) return '';
    const now = new Date();
    const past = timestamp.toDate();
    const diffInSeconds = Math.floor((now.getTime() - past.getTime()) / 1000);
    const MINUTE = 60;
    const HOUR = 3600;
    const DAY = 86400;

    if (diffInSeconds < MINUTE) return "√Ä l'instant";
    if (diffInSeconds < HOUR) return `Il y a ${Math.floor(diffInSeconds / MINUTE)} min`;
    if (diffInSeconds < DAY) return `Il y a ${Math.floor(diffInSeconds / HOUR)} h`;
    if (diffInSeconds < DAY * 30) return `Il y a ${Math.floor(diffInSeconds / DAY)} jours`;
    return past.toLocaleDateString();
};

export default function AdminPage() {
    const { user, loading: authLoading, isAdmin } = useAuth();
    const router = useRouter();
    
    const [feedback, setFeedback] = useState<FeedbackItem[]>([]);
    const [loading, setLoading] = useState(true);
    const [filterStatus, setFilterStatus] = useState<FeedbackItem['status'] | 'all'>('new');
    const [isUpdatingAll, setIsUpdatingAll] = useState(false);

    useEffect(() => {
        if (!authLoading && user && !isAdmin) {
            router.push('/'); 
        } else if (!authLoading && !user) {
            router.push('/login');
        }
    }, [user, authLoading, isAdmin, router]);

    useEffect(() => {
        if (!user || !isAdmin) {
            if (!authLoading) setLoading(false); 
            return;
        }

        setLoading(true);
        const feedbackQuery = query(collection(db, 'app_feedback'), orderBy('createdAt', 'desc'));

        const unsubscribe = onSnapshot(feedbackQuery, (snapshot) => {
            const fetchedFeedback = snapshot.docs.map(d => ({ id: d.id, ...d.data() })) as FeedbackItem[];
            setFeedback(fetchedFeedback);
            setLoading(false);
        }, (error) => { console.error(error); setLoading(false); });

        return () => unsubscribe();
    }, [user, isAdmin, authLoading]); 

    const filteredFeedback = useMemo(() => {
        if (filterStatus === 'all') return feedback;
        return feedback.filter(item => item.status === filterStatus);
    }, [feedback, filterStatus]);

    const updateStatus = async (itemId: string, newStatus: FeedbackItem['status']) => {
        try { await updateDoc(doc(db, 'app_feedback', itemId), { status: newStatus }); toast.success(`Statut mis √† jour`); } catch (e) { console.error(e); toast.error("Erreur"); }
    };

    const deleteFeedback = async (itemId: string) => {
        if (!confirm("Supprimer ?")) return;
        try { await deleteDoc(doc(db, 'app_feedback', itemId)); toast.success("Supprim√©"); } catch (e) { console.error(e); }
    };

    const handleGlobalUpdate = async () => {
        if (!confirm("ATTENTION : Mise √† jour globale (CMC/Identit√© Couleur) pour TOUS les utilisateurs. Continuer ?")) return;
        setIsUpdatingAll(true);
        const toastId = toast.loading("Mise √† jour en cours...");
        try {
            const result = await forceUpdateAllUsersCardsAction();
            if (result.success) toast.success(result.message || "Termin√© !", { id: toastId, duration: 5000 });
            else toast.error(result.error || "Erreur", { id: toastId });
        } catch (e) { console.error(e); toast.error("Erreur fatale", { id: toastId }); }
        finally { setIsUpdatingAll(false); }
    };

    const filterTabs: (FeedbackItem['status'] | 'all')[] = ['new', 'read', 'interesting', 'in_progress', 'implemented', 'all'];

    if (authLoading || (user && !isAdmin)) return null; 

    return (
        <main className="container mx-auto p-4 max-w-6xl min-h-[80vh]">
            <div className="flex flex-col md:flex-row justify-between items-start md:items-center mb-8 border-b border-gray-200 pb-4 gap-4">
                <h1 className="text-3xl font-bold text-red-500">üëë Admin Dashboard</h1>
                <div className="bg-red-50 border border-red-200 p-4 rounded-xl flex flex-col items-end shadow-sm">
                    <h3 className="text-xs font-bold text-red-700 uppercase mb-2">Maintenance Globale</h3>
                    <button onClick={handleGlobalUpdate} disabled={isUpdatingAll} className="bg-red-600 hover:bg-red-700 text-white text-xs font-bold px-4 py-2 rounded-lg shadow-sm disabled:opacity-50 transition flex items-center gap-2">
                        {isUpdatingAll ? 'Traitement...' : 'üîÑ Forcer Update Cartes (CMC/Identit√©)'}
                    </button>
                    <p className="text-[10px] text-red-500 mt-1 max-w-[200px] text-right">Met √† jour les donn√©es (Identit√© Couleur) pour corriger les filtres.</p>
                </div>
            </div>

            <div className="bg-white p-4 rounded-xl border border-gray-200 shadow-sm mb-6 flex flex-wrap gap-2 items-center">
                <span className="text-sm font-bold text-gray-700 mr-2">Filtrer :</span>
                {filterTabs.map(status => (
                    <button key={status} onClick={() => setFilterStatus(status)} className={`text-xs font-bold px-3 py-1.5 rounded-full uppercase transition-colors ${filterStatus === status ? (status === 'all' ? 'bg-gray-800 text-white' : STATUS_COLORS[status]) : 'bg-gray-100 text-gray-500 hover:bg-gray-200'}`}>
                        {status.replace('_', ' ')} ({status === 'all' ? feedback.length : feedback.filter(f => f.status === status).length})
                    </button>
                ))}
            </div>

            {loading ? <p className="text-center p-10 text-gray-400">Chargement...</p> : filteredFeedback.length === 0 ? (
                 <div className="text-center py-16 bg-gray-50 rounded-xl border-dashed border-2 border-gray-200"><p className="text-gray-400 italic">Aucun feedback.</p></div>
            ) : (
                <div className="space-y-4">
                    {filteredFeedback.map(item => (
                        <div key={item.id} className="bg-white p-5 rounded-xl border border-gray-200 shadow-sm hover:shadow-md transition">
                            <div className="flex justify-between items-start mb-3 border-b border-gray-100 pb-2">
                                <div><span className={`text-[10px] font-bold px-2 py-1 rounded uppercase ${STATUS_COLORS[item.status]}`}>{item.status.replace('_', ' ')}</span><p className="text-sm text-gray-500 mt-2">Par <span className="font-semibold text-gray-800">@{item.username}</span></p></div>
                                <span className="text-xs text-gray-400">{formatTimeAgo(item.createdAt)}</span>
                            </div>
                            <p className="text-gray-800 font-medium mb-4 whitespace-pre-wrap">{item.suggestion}</p>
                            <div className="flex flex-wrap items-center gap-2 pt-2 w-full">
                                <div className="flex flex-wrap gap-2">
                                    <button onClick={() => updateStatus(item.id, 'read')} className="text-xs bg-gray-50 border hover:bg-gray-100 px-3 py-1.5 rounded">Lu</button>
                                    <button onClick={() => updateStatus(item.id, 'interesting')} className="text-xs bg-purple-50 border hover:bg-purple-100 text-purple-700 px-3 py-1.5 rounded font-bold">‚≠ê Int√©ressant</button>
                                    <button onClick={() => updateStatus(item.id, 'in_progress')} className="text-xs bg-yellow-50 border hover:bg-yellow-100 text-yellow-800 px-3 py-1.5 rounded">En Cours</button>
                                    <button onClick={() => updateStatus(item.id, 'implemented')} className="text-xs bg-green-50 border hover:bg-green-100 text-green-700 px-3 py-1.5 rounded font-bold">‚úÖ Fait</button>
                                </div>
                                <button onClick={() => deleteFeedback(item.id)} className="ml-auto text-xs text-red-400 hover:text-red-600 hover:bg-red-50 p-2 rounded">üóëÔ∏è</button>
                            </div>
                        </div>
                    ))}
                </div>
            )}
        </main>
    );
}
</file>

<file path="app/api/search/route.ts">
// app/api/search/route.ts
import { NextResponse } from 'next/server';

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const query = searchParams.get('q'); 

  if (!query) {
    return NextResponse.json(
      { error: 'Aucun terme de recherche fourni.' }, 
      { status: 400 } 
    );
  }

  // --- CORRECTION : Suppression des guillemets pour permettre la recherche partielle ---
  // On utilise encodeURIComponent pour g√©rer proprement les espaces et caract√®res sp√©ciaux
const scryfallUrl = `https://api.scryfall.com/cards/search?q=${encodeURIComponent(query)}%20game:paper&unique=cards`;

  try {
    const scryfallResponse = await fetch(scryfallUrl);

    if (!scryfallResponse.ok) {
      const errorData = await scryfallResponse.json();
      console.error('Erreur Scryfall:', errorData);
      return NextResponse.json(
        { error: errorData.details || 'Carte non trouv√©e' }, 
        { status: scryfallResponse.status }
      );
    }

    const data = await scryfallResponse.json();
    return NextResponse.json(data);

  } catch (error) {
    console.error('Erreur interne du serveur:', error);
    return NextResponse.json(
      { error: 'Une erreur est survenue sur le serveur.' }, 
      { status: 500 }
    );
  }
}
</file>

<file path="app/politique-confidentialite/page.tsx">
// app/politique-confidentialite/page.tsx
'use client';

import React from 'react';
import Link from 'next/link';

export default function PrivacyPolicyPage() {
    return (
        <main className="min-h-screen bg-background pb-20 pt-8">
            <div className="container mx-auto p-4 max-w-4xl">
                <h1 className="text-3xl font-bold text-foreground mb-8 border-b border-border pb-4 mt-8">
                    Politique de Confidentialit√© et Gestion des Cookies (RGPD)
                </h1>

                <div className="space-y-8 text-muted-foreground">
                    <section>
                        <h2 className="text-xl font-bold text-primary mb-3">1. Identit√© et Contact</h2>
                        <p>Le responsable du traitement des donn√©es pour l&apos;application MagicWish est :</p>
                        <ul className="list-disc list-inside ml-4 mt-2 space-y-1">
                            <li className="text-foreground font-bold">Responsable : Ga√´l Montpelier</li>
                            <li className="text-foreground font-bold">Email : magicwish.be.contact@gmail.com</li>
                        </ul>
                    </section>

                    {/* --- NOUVELLE SECTION STRIPE --- */}
                    <section className="bg-primary/5 p-6 rounded-lg border border-primary/20">
                        <h2 className="text-xl font-bold text-primary mb-3">2. Paiements et Donn√©es Bancaires (Stripe)</h2>
                        <p className="mb-4 text-foreground">
                            Pour la gestion des abonnements Premium, nous utilisons les services de paiement s√©curis√©s de <strong>Stripe</strong>.
                        </p>
                        <ul className="list-disc list-inside ml-4 space-y-3 text-sm">
                            <li>
                                <strong>S√©curit√© des donn√©es :</strong> MagicWish ne collecte, ne stocke et ne traite <strong>aucune</strong> donn√©e bancaire compl√®te (num√©ro de carte, cryptogramme). Ces donn√©es sont saisies directement dans le module s√©curis√© de Stripe.
                            </li>
                            <li>
                                <strong>Partage de donn√©es :</strong> Seules les informations strictement n√©cessaires √† la facturation et √† la gestion de l&apos;abonnement (adresse email, identifiant utilisateur, statut du paiement) sont partag√©es avec Stripe.
                            </li>
                            <li>
                                <a href="https://stripe.com/privacy" target="_blank" rel="noopener noreferrer" className="underline text-primary font-bold">Consulter la politique de confidentialit√© de Stripe</a>
                            </li>
                        </ul>
                    </section>

                    <section>
                        <h2 className="text-xl font-bold text-primary mb-3">3. Publicit√© et Cookies Google AdSense</h2>
                        <p className="mb-4 text-foreground">
                            Pour les utilisateurs de la version gratuite, nous utilisons des fournisseurs tiers, y compris Google, pour diffuser des annonces.
                        </p>
                        <ul className="list-disc list-inside ml-4 space-y-3 text-sm">
                            <li>
                                <strong>Cookies publicitaires :</strong> Google utilise des cookies pour diffuser des annonces bas√©es sur vos visites pr√©c√©dentes sur MagicWish ou sur d&apos;autres sites.
                            </li>
                            <li>
                                <strong>D√©sactivation :</strong> Vous pouvez d√©sactiver la publicit√© personnalis√©e dans les <a href="https://www.google.com/settings/ads" target="_blank" rel="noopener noreferrer" className="underline text-primary font-bold">Param√®tres des annonces Google</a>.
                            </li>
                        </ul>
                    </section>

                    <section>
                        <h2 className="text-xl font-bold text-primary mb-3">4. Donn√©es Collect√©es</h2>
                        <p>Nous collectons l&apos;email, le pseudonyme et les listes de cartes pour assurer le service de matching, de gestion de collection et d&apos;√©changes.</p>
                    </section>

                    <div className="pt-8 border-t border-border mt-8 flex flex-col md:flex-row justify-between items-center gap-4">
                        <p className="text-xs">Derni√®re mise √† jour : 24 D√©cembre 2025</p>
                        <Link href="/mentions-legales" className="text-xs text-primary hover:underline font-bold">Mentions L√©gales & CGV</Link>
                    </div>
                </div>
            </div>
        </main>
    );
}
</file>

<file path="components/chat/ChatWindow.tsx">
// components/chat/ChatWindow.tsx
'use client';

import { useState, useRef, useEffect } from 'react';
import { useAuth } from '@/lib/AuthContext'; // Chemin corrig√© selon repomix
import { useChat } from '@/hooks/useChat';
import { sendMessageAction } from '@/app/actions/chat';

export default function ChatWindow({ chatId, recipientName }: { chatId: string, recipientName: string }) {
  const { user } = useAuth();
  const { messages, loading } = useChat(chatId);
  const [inputText, setInputText] = useState('');
  const scrollRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    scrollRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages]);

  const handleSend = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!inputText.trim() || !user) return;

    const textToSend = inputText;
    setInputText(''); 
    
    // On utilise le displayName du contexte
    const name = user.displayName || "Joueur";
    await sendMessageAction(chatId, user.uid, name, textToSend);
  };

  return (
    <div className="flex flex-col h-[450px] bg-surface border border-border rounded-2xl overflow-hidden shadow-xl mb-4 animate-in fade-in slide-in-from-bottom-2">
      <div className="p-4 border-b border-border bg-secondary/10 flex justify-between items-center">
        <span className="text-[10px] font-black uppercase tracking-widest text-primary">Chat avec {recipientName}</span>
      </div>

      <div className="flex-1 overflow-y-auto p-4 space-y-3 custom-scrollbar">
        {loading ? (
          <div className="flex flex-col items-center justify-center h-full space-y-2">
            <div className="w-4 h-4 border-2 border-primary border-t-transparent rounded-full animate-spin" />
            <span className="text-[9px] font-bold text-muted uppercase">Canal s√©curis√©...</span>
          </div>
        ) : (
          messages.map((msg, i) => {
            const isMe = msg.senderId === user?.uid;
            return (
              <div key={i} className={`flex ${isMe ? 'justify-end' : 'justify-start'}`}>
                <div className={`max-w-[80%] p-3 rounded-2xl text-[11px] font-bold shadow-sm ${
                  isMe ? 'bg-primary text-white rounded-tr-none' : 'bg-background border border-border text-foreground rounded-tl-none'
                }`}>
                  <p>{msg.text}</p>
                </div>
              </div>
            );
          })
        )}
        <div ref={scrollRef} />
      </div>

      <form onSubmit={handleSend} className="p-3 bg-background border-t border-border flex gap-2">
        <input
          type="text"
          value={inputText}
          onChange={(e) => setInputText(e.target.value)}
          placeholder="√âcrire un message..."
          className="flex-1 p-2.5 bg-secondary/20 border border-border rounded-xl text-xs font-bold outline-none focus:ring-1 focus:ring-primary"
        />
        <button type="submit" className="bg-primary text-white px-4 rounded-xl font-black text-[10px] uppercase transition-transform active:scale-95">
          OK
        </button>
      </form>
    </div>
  );
}
</file>

<file path="components/collection/CollectionToolbar.tsx">
// components/collection/CollectionToolbar.tsx
'use client';

import { useState } from 'react';
import DeleteAllButton from '@/components/DeleteAllButton';

interface CollectionToolbarProps {
    isSelectMode: boolean;
    setIsSelectMode: (val: boolean) => void;
    onOpenTools: () => void;
    onOpenHub: () => void;
}

export default function CollectionToolbar({
    isSelectMode,
    setIsSelectMode,
    onOpenTools,
    onOpenHub,
}: CollectionToolbarProps) {
    // √âtat pour afficher les options suppl√©mentaires sur mobile
    const [showOptions, setShowOptions] = useState(false);

    return (
        <div className="flex flex-col gap-3 mb-6 w-full">
            {/* BARRE PRINCIPALE */}
            <div className="flex items-center gap-2 w-full">
                
                {/* Mode S√©lection : Toujours visible */}
                <button 
                    onClick={() => { 
                        setIsSelectMode(!isSelectMode);
                        if (!isSelectMode) setShowOptions(false); // Ferme les options si on entre en s√©lection
                    }}
                    className={`flex-1 md:flex-none px-4 py-2.5 rounded-xl text-sm font-bold transition-all shadow-sm border flex items-center justify-center gap-2 ${
                        isSelectMode 
                            ? 'bg-primary text-primary-foreground border-primary' 
                            : 'bg-surface hover:bg-secondary text-foreground border-border'
                    }`}
                >
                    <span>{isSelectMode ? '‚úï' : '‚úì'}</span>
                    {isSelectMode ? 'Annuler' : 'S√©lectionner'}
                </button>

                {/* Bouton Toggle Options : Uniquement sur Mobile et hors mode s√©lection */}
                {!isSelectMode && (
                    <button 
                        onClick={() => setShowOptions(!showOptions)}
                        className={`md:hidden p-2.5 rounded-xl border transition-all ${
                            showOptions ? 'bg-primary text-white border-primary' : 'bg-surface text-foreground border-border'
                        }`}
                        title="Plus d'options"
                    >
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={2.5} stroke="currentColor" className="w-5 h-5">
                            <path strokeLinecap="round" strokeLinejoin="round" d="M10.5 6h9.75M10.5 12h9.75M10.5 18h9.75M3 6h.008v.008H3V6Zm0 6h.008v.008H3V12Zm0 6h.008v.008H3V18Z" />
                        </svg>
                    </button>
                )}

                {/* VERSION DESKTOP : Boutons normaux */}
                {!isSelectMode && (
                    <div className="hidden md:flex items-center gap-2">
                        <button 
                            onClick={onOpenTools}
                            className="bg-surface hover:bg-secondary text-foreground px-4 py-2 rounded-xl text-sm font-bold border border-border flex items-center gap-2 transition-all"
                        >
                            G√©rer
                        </button>
                        <DeleteAllButton targetCollection="collection" />
                        <button 
                            onClick={onOpenHub}
                            className="bg-primary text-primary-foreground px-4 py-2 rounded-xl text-sm font-bold shadow-md hover:opacity-90 transition-all"
                        >
                            Importer / Exporter
                        </button>
                    </div>
                )}
            </div>

            {/* VERSION MOBILE : Menu d'options escamotable */}
            {!isSelectMode && showOptions && (
                <div className="md:hidden grid grid-cols-2 gap-2 animate-in fade-in slide-in-from-top-2 duration-200">
                    <button 
                        onClick={() => { onOpenTools(); setShowOptions(false); }}
                        className="flex items-center justify-center gap-2 bg-surface border border-border p-3 rounded-xl text-xs font-bold text-foreground active:bg-secondary transition-colors"
                    >
                        G√©rer la liste
                    </button>

                    <button 
                        onClick={() => { onOpenHub(); setShowOptions(false); }}
                        className="flex items-center justify-center gap-2 bg-surface border border-border p-3 rounded-xl text-xs font-bold text-foreground active:bg-secondary transition-colors"
                    >
                        Import / Export
                    </button>

                    <div className="col-span-2">
                        {/* On wrap le bouton de suppression pour qu'il prenne toute la largeur sur mobile */}
                        <div className="w-full" onClick={() => setShowOptions(false)}>
                            <DeleteAllButton targetCollection="collection" />
                        </div>
                    </div>
                </div>
            )}
        </div>
    );
}
</file>

<file path="components/ColumnSlider.tsx">
// components/ColumnSlider.tsx
'use client';

type Props = {
    columns: number;
    setColumns: (val: number) => void;
    min?: number;
    max?: number;
};

export default function ColumnSlider({ columns, setColumns, min = 2, max = 8 }: Props) {
    return (
        <div className="flex flex-col sm:flex-row items-start sm:items-center gap-2 bg-surface border border-border px-3 py-2 rounded-lg shadow-sm">
            <span className="text-[10px] uppercase font-bold text-muted whitespace-nowrap">
                Colonnes : <span className="text-primary">{columns}</span>
            </span>
            <input 
                type="range" 
                min={min} 
                max={max} 
                value={columns} 
                onChange={(e) => setColumns(parseInt(e.target.value))}
                className="w-24 h-2 bg-secondary rounded-lg appearance-none cursor-pointer accent-primary"
                title="Ajuster le nombre de colonnes"
            />
        </div>
    );
}
</file>

<file path="components/DataTransferHubModal.tsx">
// components/DataTransferHubModal.tsx
'use client';

type DataTransferHubProps = {
  isOpen: boolean;
  onClose: () => void;
  onSelectImport: () => void;
  onSelectExport: () => void;
  targetLabel: 'Collection' | 'Wishlist';
};

export default function DataTransferHubModal({ 
  isOpen, 
  onClose, 
  onSelectImport, 
  onSelectExport,
  targetLabel
}: DataTransferHubProps) {
  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black/60 flex items-center justify-center z-50 p-4 backdrop-blur-sm" onClick={onClose}>
      <div 
        className="bg-surface rounded-xl p-6 max-w-sm w-full shadow-2xl border border-border flex flex-col max-h-[90vh] animate-in fade-in duration-200"
        onClick={e => e.stopPropagation()}
      >
        <div className="flex justify-between items-center mb-6">
          <h2 className="text-xl font-bold text-foreground">
            {targetLabel}: Transf√©rer
          </h2>
          <button onClick={onClose} className="text-muted hover:text-foreground text-lg p-2">‚úï</button>
        </div>

        <p className="text-muted text-sm mb-6">
          Veuillez choisir l&apos;op√©ration √† effectuer sur votre {targetLabel.toLowerCase()}.
        </p>

        <div className="space-y-4">
          <button
            onClick={onSelectImport}
            className="w-full bg-primary hover:opacity-90 text-primary-foreground font-bold py-3 rounded-lg transition shadow-md flex items-center justify-center gap-3"
          >
            Importer des Cartes
          </button>
          
          <button
            onClick={onSelectExport}
            className="w-full bg-secondary hover:bg-border text-foreground font-bold py-3 rounded-lg transition shadow-sm flex items-center justify-center gap-3"
          >
            Exporter les Donn√©es
          </button>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="components/ExportModal.tsx">
// components/ExportModal.tsx
'use client';

import { CardType } from '@/hooks/useCardCollection';
import { useState, useMemo } from 'react';
import toast from 'react-hot-toast';
import Papa from 'papaparse'; 

type ExportType = 'text' | 'csv';

type Props = {
    isOpen: boolean;
    onClose: () => void;
    cards: CardType[];
    listName: string;
    targetType: 'collection' | 'wishlist';
    onGoBack: () => void; 
    onCloseAll: () => void; 
};

// Fonction de formatage TXT (Plain Text Import Cardmarket compatible)
const formatToText = (cards: CardType[]): string => {
    return cards
        .map(card => {
            const qty = card.quantity;
            const name = card.name.split(' // ')[0].trim();
            const setCode = card.setCode?.toUpperCase() || '';
            const foilTag = card.isFoil ? ' Foil' : '';

            // Format: Qty Name (Set Code) [Foil]
            return `${qty} ${name} (${setCode})${foilTag}`;
        })
        .join('\n');
};

// Fonction de formatage CSV (avec plus de d√©tails)
const formatToCsvData = (cards: CardType[]) => {
    const rows = cards.map(card => ({
        "Quantity": card.quantity.toString(),
        "Name": card.name.split(' // ')[0].trim(),
        "Set Code": card.setCode?.toUpperCase() || '',
        "Foil": card.isFoil ? 'True' : 'False',
        "Price (‚Ç¨)": (card.customPrice ?? card.price ?? 0).toFixed(2),
        "Tradeable": (card.quantityForTrade ?? 0).toString(),
        "Last Price Update": card.lastPriceUpdate ? new Date(card.lastPriceUpdate).toISOString() : '',
        "Scryfall ID": card.id
    }));

    return { rows };
}


export default function ExportModal({ isOpen, cards, listName, targetType, onGoBack, onCloseAll }: Props) {
    
    const [exportFormat, setExportFormat] = useState<ExportType>('text');
    const [copied, setCopied] = useState(false);

    const exportText = useMemo(() => {
        if (exportFormat === 'text') {
            return formatToText(cards);
        }
        return '';
    }, [cards, exportFormat]);

    if (!isOpen) return null;

    const handleCopyOrDownload = () => {
        if (cards.length === 0) {
            toast.error("La liste est vide !");
            return;
        }

        if (exportFormat === 'text') {
            navigator.clipboard.writeText(exportText);
            setCopied(true);
            toast.success("Texte copi√© ! Vous pouvez coller dans Cardmarket.");
            setTimeout(() => setCopied(false), 2000);
        } else {
            const { rows } = formatToCsvData(cards);
            const csv = Papa.unparse(rows, { header: true, delimiter: ',' });
            
            const filename = `${listName.replace(/\s/g, '_')}_export.csv`;
            
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            
            link.href = URL.createObjectURL(blob);
            link.setAttribute('download', filename);
            link.click();
            
            toast.success("Fichier CSV t√©l√©charg√© !");
        }
    };
    
    const instructions = exportFormat === 'text'
        ? "Copiez le texte ci-dessous pour le coller dans l'outil 'Plain Text Import' de Cardmarket."
        : "Le fichier CSV est plus d√©taill√©, id√©al pour Excel ou la sauvegarde.";

    const targetLabel = targetType === 'collection' ? 'Collection' : 'Wishlist';

    return (
        <div className="fixed inset-0 bg-black/60 flex items-center justify-center z-50 p-4 backdrop-blur-sm" onClick={onGoBack}>
            <div className="bg-surface rounded-xl p-6 max-w-lg w-full shadow-2xl border border-border flex flex-col max-h-[90vh] animate-in fade-in duration-200" onClick={e => e.stopPropagation()}>
                
                <div className="flex justify-between items-center mb-4 border-b border-border pb-3">
                    <div className="flex items-center gap-3">
                        <button onClick={onGoBack} className="text-muted hover:text-foreground text-xl p-1 rounded transition">‚Üê</button>
                        <h2 className="text-xl font-bold text-foreground">
                            üì§ Exporter : {targetLabel}
                        </h2>
                    </div>
                    <button onClick={onCloseAll} className="text-muted hover:text-danger text-lg p-2">‚úï</button>
                </div>
                
                <p className="text-sm text-muted mb-4">{instructions}</p>
                
                {/* S√©lecteur de format */}
                <div className="flex justify-center p-1 mb-4 bg-background rounded-lg border border-border">
                    <button 
                        onClick={() => setExportFormat('text')}
                        className={`flex-1 py-2 rounded-lg text-sm font-bold transition ${exportFormat === 'text' ? 'bg-primary text-primary-foreground shadow-sm' : 'text-foreground hover:bg-secondary'}`}
                    >
                        Texte (Copier/Coller)
                    </button>
                    <button 
                        onClick={() => setExportFormat('csv')}
                        className={`flex-1 py-2 rounded-lg text-sm font-bold transition ${exportFormat === 'csv' ? 'bg-primary text-primary-foreground shadow-sm' : 'text-foreground hover:bg-secondary'}`}
                    >
                        CSV (Fichier)
                    </button>
                </div>

                {/* Pr√©visualisation ou confirmation de t√©l√©chargement */}
                {exportFormat === 'text' && (
                    <textarea
                        readOnly
                        value={exportText}
                        rows={10}
                        className="w-full p-3 mb-4 rounded-lg border border-border bg-background text-foreground font-mono text-xs resize-none grow"
                    />
                )}
                {exportFormat === 'csv' && (
                    <div className="bg-secondary p-4 mb-4 rounded-lg text-center text-sm font-medium border border-border grow flex items-center justify-center">
                        Pr√™t √† t√©l√©charger **{cards.length} cartes** au format CSV.
                    </div>
                )}


                <div className="flex justify-between items-center flex-none">
                    <span className="text-xs text-muted">{cards.length} cartes pr√©par√©es.</span>
                    <button
                        onClick={handleCopyOrDownload}
                        disabled={cards.length === 0}
                        className={`px-4 py-2 rounded-lg text-sm font-bold transition shadow-md disabled:opacity-50 ${
                            exportFormat === 'text' 
                                ? (copied ? 'bg-success text-white' : 'btn-primary')
                                : 'bg-primary text-primary-foreground hover:opacity-90'
                        }`}
                    >
                        {exportFormat === 'text' ? (copied ? '‚úÖ Copi√© !' : 'üìã Copier le texte') : '‚¨áÔ∏è T√©l√©charger CSV'}
                    </button>
                </div>
            </div>
        </div>
    );
}
</file>

<file path="components/trades/TradeSourceTable.tsx">
// components/trades/TradeSourceTable.tsx
'use client';

import { CardType } from '@/hooks/useCardCollection';
import { ScryfallRawData } from '@/lib/cardUtils';

// Helper pour s'assurer que nous travaillons avec le type attendu

interface TradeSourceTableProps {
    cards: CardType[];
    onAdd: (c: CardType) => void;
    buttonColorClass: 'text-danger' | 'text-success' | 'text-blue-600';
    loading?: boolean;
}

export default function TradeSourceTable({ 
    cards, 
    onAdd, 
    buttonColorClass, 
    loading 
}: TradeSourceTableProps) {
    if (loading) return <p className="text-xs text-muted text-center py-4">Chargement...</p>;
    if (cards.length === 0) return <p className="text-xs text-muted text-center py-4">Aucune carte trouv√©e.</p>;
    
    return (
        <div className="overflow-y-auto custom-scrollbar flex-1 bg-surface">
            <table className="w-full text-xs text-left border-collapse">
                <thead className="bg-background text-muted sticky top-0 z-10 font-semibold uppercase">
                    <tr>
                        <th className="px-2 py-2 text-center w-8">Dispo</th>
                        <th className="px-2 py-2">Nom</th>
                        <th className="px-2 py-2 w-12 text-center">Set</th>
                        <th className="px-2 py-2 w-10 text-center">N¬∞</th>
                        <th className="px-2 py-2 w-10 text-center">Foil</th>
                        <th className="px-2 py-2 w-8"></th>
                    </tr>
                </thead>
                <tbody className="divide-y divide-border">
                    {cards.map((card, i) => {
                        const scryData = card.scryfallData as ScryfallRawData | undefined;
                        const collectorNum = scryData?.collector_number || '?';
                        const tradeQty = card.quantityForTrade ?? 0;
                        
                        return (
                            <tr 
                                key={`${card.id}-${i}`} 
                                className="hover:bg-secondary/50 transition-colors text-foreground cursor-pointer group select-none" 
                                onClick={() => onAdd(card)}
                            >
                                <td className="px-2 py-1.5 text-center text-muted font-mono">{tradeQty}</td>
                                <td className="px-2 py-1.5 font-medium truncate max-w-[120px]" title={card.name}>{card.name}</td>
                                <td className="px-2 py-1.5 text-center"><span className="text-[9px] font-mono bg-secondary text-muted px-1 rounded border border-border">{card.setCode?.toUpperCase()}</span></td>
                                <td className="px-2 py-1.5 text-center text-muted font-mono text-[10px]">{collectorNum}</td>
                                <td className="px-2 py-1.5 text-center">{card.isFoil && <span className="text-[9px] font-bold text-amber-600 bg-amber-100 px-1 rounded">Foil</span>}</td>
                                <td className="px-2 py-1.5 text-center">
                                    <button className={`${buttonColorClass} font-bold hover:scale-125 transition-transform`}>+</button>
                                </td>
                            </tr>
                        );
                    })}
                </tbody>
            </table>
        </div>
    );
}
</file>

<file path="hooks/useChat.ts">
// hooks/useChat.ts
import { useState, useEffect } from 'react';
import { db } from '@/lib/firebase'; // V√©rifiez bien ce chemin vers votre config client
import { collection, query, orderBy, limit, onSnapshot } from 'firebase/firestore';
import { Message } from '@/lib/types/chat';

export function useChat(chatId: string | null) {
  const [messages, setMessages] = useState<Message[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (!chatId) {
      // eslint-disable-next-line react-hooks/set-state-in-effect
      setLoading(false);
      return;
    }

    setLoading(true);
    
    // R√©f√©rence √† la sous-collection : chats/{chatId}/messages
    const messagesRef = collection(db, 'chats', chatId, 'messages');
    const q = query(messagesRef, orderBy('createdAt', 'asc'), limit(100));

    const unsubscribe = onSnapshot(q, 
      (snapshot) => {
        const msgs = snapshot.docs.map(doc => ({
          id: doc.id,
          ...doc.data()
        } as Message));
        setMessages(msgs);
        setLoading(false);
        setError(null);
      },
      (err) => {
        console.error("Erreur Firestore Chat:", err);
        setError(err.message);
        setLoading(false);
      }
    );

    return () => unsubscribe();
  }, [chatId]);

  return { messages, loading, error };
}
</file>

<file path="hooks/useCollections.ts">
// hooks/useCollections.ts
'use client';

import { useState, useEffect } from 'react';
import { useAuth } from '@/lib/AuthContext';
import { collection, onSnapshot, query, orderBy, doc, deleteDoc, writeBatch, getDocs } from 'firebase/firestore';
import { db } from '@/lib/firebase';
import { createListAction } from '@/app/actions/lists';
import toast from 'react-hot-toast';

export type CollectionMeta = {
  id: string;
  name: string;
  // AJOUT : Indispensable pour le tri dans le Header
  createdAt?: { seconds: number; nanoseconds: number };
};

export function useCollections() {
  const { user } = useAuth();
  const [lists, setLists] = useState<CollectionMeta[]>([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    if (!user) {
      setLists([]);
      setLoading(false);
      return;
    }

    // On trie directement par date de cr√©ation c√¥t√© Firestore
    const q = query(
      collection(db, 'users', user.uid, 'collections_meta'),
      orderBy('createdAt', 'asc')
    );

    const unsubscribe = onSnapshot(q, (snapshot) => {
      const data = snapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data()
      })) as CollectionMeta[];
      
      setLists(data);
      setLoading(false);
    }, (error) => {
      console.error("Erreur fetch collections:", error);
      setLoading(false);
    });

    return () => unsubscribe();
  }, [user]);

  const createList = async (name: string) => {
    if (!user) return;
    const toastId = toast.loading("Cr√©ation...");
    try {
      // Utilisation de l'action serveur pour v√©rifier les limites (Gratuit vs Premium)
      const res = await createListAction(user.uid, name, 'collection');
      
      if (res.success) {
        toast.success(`Collection "${name}" cr√©√©e`, { id: toastId });
      } else {
        toast.error(res.error || "Erreur cr√©ation", { id: toastId });
      }
    } catch (e) {
      console.error(e);
      toast.error("Erreur technique", { id: toastId });
    }
  };

  const renameList = async (listId: string, newName: string) => {
    // Note: Pour renommer, on peut utiliser updateDoc directement car pas de logique de limite ici
    // Mais on pourrait aussi cr√©er une Server Action si besoin de s√©cu suppl√©mentaire
    // Pour l'instant on garde votre logique qui fonctionnait (via import dynamique ou adaptation)
    // Comme votre code original utilisait updateDoc, je le r√©int√®gre ici :
    const { updateDoc } = await import('firebase/firestore'); // Import dynamique pour all√©ger ou standard
    
    if (!user) return;
    try {
      await updateDoc(doc(db, 'users', user.uid, 'collections_meta', listId), {
        name: newName
      });
      toast.success("Renomm√© !");
    } catch (e) {
      console.error(e);
      toast.error("Erreur renommage");
    }
  };

  const deleteList = async (listId: string) => {
    if (!user) return;
    if (!confirm("Attention : Cela supprimera TOUTES les cartes de ce classeur. Continuer ?")) return;
    
    const toastId = toast.loading("Suppression...");
    try {
      // 1. Supprimer les cartes (sous-collection)
      const cardsRef = collection(db, 'users', user.uid, 'collections', listId, 'cards');
      const cardsSnap = await getDocs(cardsRef);
      
      const batch = writeBatch(db);
      cardsSnap.docs.forEach((doc) => {
        batch.delete(doc.ref);
      });
      await batch.commit();

      // 2. Supprimer la m√©ta
      await deleteDoc(doc(db, 'users', user.uid, 'collections_meta', listId));
      
      toast.success("Classeur supprim√©", { id: toastId });
    } catch (e) {
      console.error(e);
      toast.error("Erreur suppression", { id: toastId });
    }
  };

  return { lists, createList, renameList, deleteList, loading };
}
</file>

<file path="lib/firebase-admin.ts">
// lib/firebase-admin.ts
import 'server-only';
import * as admin from 'firebase-admin';

// Fonction pour nettoyer la cl√© priv√©e (probl√®me fr√©quent avec les variables d'env)
function formatPrivateKey(key: string) {
  return key.replace(/\\n/g, '\n');
}

function initAdmin() {
  // On v√©rifie si une instance existe d√©j√† pour √©viter les erreurs de hot-reload
  if (admin.apps.length === 0) {
    admin.initializeApp({
      credential: admin.credential.cert({
        projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID,
        clientEmail: process.env.FIREBASE_CLIENT_EMAIL,
        privateKey: formatPrivateKey(process.env.FIREBASE_PRIVATE_KEY || ""),
      }),
    });
  }
}

export function getAdminFirestore() {
  initAdmin();
  return admin.firestore();
}

// NOUVELLE FONCTION EXPORT√âE
export function getAdminAuth() {
  initAdmin();
  return admin.auth();
}
</file>

<file path="lib/validators.ts">
// lib/validators.ts
import { z } from 'zod';

// Sch√©ma complet d'une carte (bas√© sur ton CardType)
export const CardSchema = z.object({
  id: z.string().min(1),
  name: z.string().min(1),
  imageUrl: z.string().url(),
  imageBackUrl: z.string().nullable().optional(),
  quantity: z.number().int().positive(),
  price: z.number().min(0).default(0),
  customPrice: z.number().min(0).optional(),
  setName: z.string().default(''),
  setCode: z.string().default(''),
  isFoil: z.boolean().default(false),
  isSpecificVersion: z.boolean().default(false),
  
  // Remplacement de isForTrade par quantityForTrade
  quantityForTrade: z.number().int().min(0).default(0).optional(), 
  
  wishlistId: z.string().nullable().optional(),
  lastPriceUpdate: z.union([z.number(), z.date()]).optional(), 
  scryfallData: z.record(z.string(), z.unknown()).nullable().optional()
});

// Sch√©ma pour l'ex√©cution d'un √©change
export const TradeExecutionSchema = z.object({
  tradeId: z.string().min(1),
  senderUid: z.string().min(1),
  receiverUid: z.string().min(1),
  itemsGiven: z.array(CardSchema),
  itemsReceived: z.array(CardSchema)
});

// Type d√©duit automatiquement pour l'usage dans TypeScript
export type ValidatedCard = z.infer<typeof CardSchema>;
</file>

<file path="next.config.ts">
// next.config.ts
import type { NextConfig } from 'next';

const nextConfig: NextConfig = {
  // CORRECTION MAJEURE: D√©sactiver reactStrictMode pour √©viter les erreurs 
  // "Firestore INTERNAL ASSERTION FAILED" dues au Hot Reload/Fast Refresh.
  reactStrictMode: false, 

  // Optimisation des images
  images: {
    formats: ['image/avif', 'image/webp'],
    remotePatterns: [
      {
        protocol: 'https',
        hostname: 'cards.scryfall.io',
        port: '',
        pathname: '/**',
      },
      {
        protocol: 'https',
        hostname: '*.googleusercontent.com',
        port: '',
        pathname: '/**',
      },
    ],
  },

  // S√©curit√© (Headers HTTP)
  async headers() {
    return [
      {
        source: '/(.*)',
        headers: [
          { key: 'X-Content-Type-Options', value: 'nosniff' },
          { key: 'X-Frame-Options', value: 'DENY' },
          { key: 'Referrer-Policy', value: 'strict-origin-when-cross-origin' },
        ],
      },
    ];
  },
};

export default nextConfig;
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "react-jsx",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": [
    "next-env.d.ts",
    "lib/globals.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts",
    ".next/dev/types/**/*.ts",
    "**/*.mts"
  ],
  "exclude": ["node_modules"]
}
</file>

<file path="app/actions/chat.ts">
// app/actions/chat.ts
'use server';

import { getAdminFirestore } from '@/lib/firebase-admin';
import { FieldValue } from 'firebase-admin/firestore';

export async function getOrCreateDirectChat(uid1: string, uid2: string) {
  const db = getAdminFirestore();
  const participants = [uid1, uid2].sort();

  try {
    const chatsRef = db.collection('chats');
    
    // On cherche un chat existant avec ces exacts participants
    const q = await chatsRef
      .where('type', '==', 'direct')
      .where('participants', '==', participants)
      .limit(1)
      .get();

    if (!q.empty) {
      return { success: true, chatId: q.docs[0].id };
    }

    // CRUCIAL : On cr√©e le document avec le champ 'participants'
    // sinon les Security Rules bloqueront la lecture c√¥t√© client.
    const newChat = await chatsRef.add({
      type: 'direct',
      participants: participants, 
      createdAt: FieldValue.serverTimestamp(),
      lastMessage: null
    });

    return { success: true, chatId: newChat.id };
  } catch (error) {
    console.error("Erreur action chat:", error);
    return { success: false };
  }
}

export async function sendMessageAction(chatId: string, senderId: string, senderName: string, text: string) {
  const db = getAdminFirestore();
  
  try {
    const chatRef = db.collection('chats').doc(chatId);
    const msgRef = chatRef.collection('messages').doc();

    const messageData = {
      senderId,
      senderName,
      text: text.trim(),
      createdAt: FieldValue.serverTimestamp(),
    };

    const batch = db.batch();
    batch.set(msgRef, messageData);
    // On met √† jour le parent pour les listes de discussion
    batch.update(chatRef, { lastMessage: messageData });

    await batch.commit();
    return { success: true };
  } catch (error) {
    console.error("Erreur envoi message:", error);
    return { success: false };
  }
}
</file>

<file path="app/actions/import.ts">
// app/actions/import.ts
'use server';

import { getAdminFirestore } from '@/lib/firebase-admin';
import { FieldValue } from 'firebase-admin/firestore';
import { updateUserStats } from '@/app/actions/stats';
import { validateImport } from '@/lib/importRules';
import { ScryfallRawData } from '@/lib/cardUtils';
import { checkAndConsumeCredits } from '@/lib/limits';

export type ImportItemInput = {
    scryfallId?: string;
    name: string;
    set: string;
    collectorNumber: string;
    quantity: number;
    isFoil: boolean;
};

interface ScryfallIdentifier {
    id?: string;
    name?: string;
    set?: string;
    collector_number?: string;
}

// Interface de r√©ponse Scryfall align√©e avec ScryfallRawData
interface ScryfallResponse {
    data: ScryfallRawData[];
    not_found?: Array<{
        set?: string;
        collector_number?: string;
        name?: string;
    }>;
}

export async function importCardsAction(
    userId: string,
    targetCollection: 'collection' | 'wishlist',
    importMode: 'add' | 'sync',
    items: ImportItemInput[],
    targetListId: string = 'default'
): Promise<{ success: boolean; count: number; error?: string; report?: { imported: number; errors: Array<{ name: string; reason: string }> } }> {
    
    // --- VERIFICATION CREDIT ---
    const creditCheck = await checkAndConsumeCredits(userId, 'IMPORT');
    if (!creditCheck.allowed) {
        return { success: false, count: 0, error: creditCheck.error };
    }
    // ---------------------------

    const db = getAdminFirestore();
    
    let collectionPath = '';
    if (targetCollection === 'collection') {
        collectionPath = targetListId === 'default' ? 'collection' : `collections_data/${targetListId}/cards`;
    } else {
        collectionPath = targetListId === 'default' ? 'wishlist' : `wishlists_data/${targetListId}/cards`;
    }

    try {
        let processedCount = 0;
        const errors: Array<{ name: string; reason: string }> = [];
        
        const chunks = [];
        for (let i = 0; i < items.length; i += 75) {
            chunks.push(items.slice(i, i + 75));
        }

        let batch = db.batch();
        let opCount = 0;

        for (const chunk of chunks) {
            const scryfallIdsToCheck = chunk.map(i => i.scryfallId).filter(id => !!id) as string[];
            const currentQuantities = new Map<string, number>();
            
            if (importMode === 'sync' && scryfallIdsToCheck.length > 0) {
                const reads = scryfallIdsToCheck.map(id => db.doc(`users/${userId}/${collectionPath}/${id}`).get());
                const snapshots = await Promise.all(reads);
                
                snapshots.forEach(snap => {
                    if (snap.exists) {
                        const data = snap.data();
                        const qty = typeof data?.quantity === 'number' ? data.quantity : 0;
                        currentQuantities.set(snap.id, qty);
                    }
                });
            }

            const identifiers: ScryfallIdentifier[] = chunk.map(item => {
                if (item.scryfallId) return { id: item.scryfallId };
                if (item.set && item.collectorNumber) {
                    return { set: item.set, collector_number: item.collectorNumber };
                }
                return { name: item.name, set: item.set || undefined };
            });

            const response = await fetch('https://api.scryfall.com/cards/collection', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ identifiers }),
                cache: 'no-store'
            });

            if (!response.ok) continue;

            const scryResult = (await response.json()) as ScryfallResponse;
            const foundCards = scryResult.data || [];

            if (scryResult.not_found) {
                scryResult.not_found.forEach((nf) => {
                    errors.push({ 
                        name: `Set: ${nf.set || '?'}, # ${nf.collector_number || '?'}`, 
                        reason: "Carte introuvable" 
                    });
                });
            }

            for (const scryCard of foundCards) {
                const originalItem = chunk.find(item => {
                    if (item.scryfallId && item.scryfallId === scryCard.id) return true;
                    
                    const itemName = item.name.toLowerCase();
                    const scryName = scryCard.name.toLowerCase().split(' // ')[0];
                    const nameMatch = itemName.includes(scryName) || scryName.includes(itemName);
                    
                    const setMatch = item.set.toLowerCase() === scryCard.set.toLowerCase();
                    const cnMatch = item.collectorNumber === scryCard.collector_number;
                    
                    if (item.set && item.collectorNumber) return setMatch && cnMatch;
                    return nameMatch && setMatch;
                });

                if (originalItem) {
                    // Appel correct avec 2 arguments : ScryfallRawData et boolean
                    const validation = validateImport(scryCard, originalItem.isFoil);
                    
                    if (!validation.isValid) {
                        errors.push({ 
                            name: scryCard.name, 
                            reason: validation.reason || "Version invalide (Foil/Non-Foil)" 
                        });
                        continue;
                    }

                    const docRef = db.doc(`users/${userId}/${collectionPath}/${scryCard.id}`);
                    
                    let quantityToAdd = 0;
                    if (importMode === 'add') {
                        quantityToAdd = originalItem.quantity;
                    } else {
                        const currentQty = currentQuantities.get(scryCard.id) || 0;
                        const targetQty = originalItem.quantity;
                        quantityToAdd = targetQty > currentQty ? targetQty - currentQty : 0;
                    }

                    if (quantityToAdd <= 0) continue;

                    let imageUrl = scryCard.image_uris?.normal;
                    let imageBackUrl: string | null = null;
                    if (scryCard.card_faces && scryCard.card_faces.length > 0) {
                        if (!imageUrl && scryCard.card_faces[0].image_uris) imageUrl = scryCard.card_faces[0].image_uris.normal;
                        if (scryCard.card_faces[1]?.image_uris) imageBackUrl = scryCard.card_faces[1].image_uris.normal || null;
                    }
                    if (!imageUrl) imageUrl = "https://cards.scryfall.io/large/front/a/6/a6984342-f723-4e80-8e69-902d287a915f.jpg";

                    const priceFoil = parseFloat(scryCard.prices?.eur_foil || "0");
                    const priceNormal = parseFloat(scryCard.prices?.eur || "0");
                    const finalPrice = originalItem.isFoil 
                        ? (priceFoil > 0 ? priceFoil : 0) 
                        : (priceNormal > 0 ? priceNormal : 0);

                    const cardData = {
                        name: scryCard.name,
                        imageUrl,
                        imageBackUrl,
                        setName: scryCard.set_name,
                        setCode: scryCard.set,
                        scryfallId: scryCard.id,
                        price: finalPrice,
                        isFoil: originalItem.isFoil,
                        scryfallData: scryCard,
                        lastPriceUpdate: new Date(),
                        wishlistId: targetCollection === 'wishlist' ? targetListId : null,
                        isSpecificVersion: targetCollection === 'wishlist',
                        quantityForTrade: 0
                    };

                    batch.set(docRef, {
                        ...cardData,
                        quantity: FieldValue.increment(quantityToAdd),
                        addedAt: (!currentQuantities.has(scryCard.id)) ? new Date() : undefined
                    }, { merge: true });

                    opCount++;
                    processedCount++;
                }
            }

            if (opCount >= 400) {
                await batch.commit();
                batch = db.batch();
                opCount = 0;
            }

            await new Promise(resolve => setTimeout(resolve, 50));
        }

        if (opCount > 0) {
            await batch.commit();
        }

        if (targetCollection === 'collection' && targetListId === 'default' && processedCount > 0) {
            await updateUserStats(userId);
        }

        return { 
            success: true, 
            count: processedCount,
            report: {
                imported: processedCount,
                errors: errors
            }
        };

    } catch (error: unknown) {
        console.error("Erreur Import Serveur:", error);
        let msg = "Erreur serveur";
        if (error instanceof Error) msg = error.message;
        return { success: false, count: 0, error: msg };
    }
}
</file>

<file path="app/actions/scanner.ts">
// app/actions/scanner.ts
'use server';

import { getAdminFirestore } from '@/lib/firebase-admin';
import { CardType } from '@/hooks/useCardCollection';
import { checkAndConsumeCredits } from '@/lib/limits';

// D√©finition stricte des types de retour
export type ScannedPartnerInfo = {
    uid: string;
    displayName: string;
    photoURL: string | null;
};

export type ScannedProposal = {
    partnerInfo: ScannedPartnerInfo;
    toGive: CardType[];
    toReceive: CardType[];
    balance: number;
};

export type ScannerResult = {
    success: boolean;
    proposals?: ScannedProposal[];
    error?: string;
};

// Interfaces internes Firestore
interface FirestoreUserData {
    displayName?: unknown;
    username?: unknown;
    photoURL?: unknown;
}

interface FirestoreGroupData {
    members?: unknown;
}

// Typage strict pour les donn√©es brutes de la carte Firestore
interface FirestoreCardData {
    name?: unknown;
    imageUrl?: unknown;
    imageBackUrl?: unknown;
    price?: unknown;
    customPrice?: unknown;
    quantityForTrade?: unknown;
    quantity?: unknown;
    setCode?: unknown;
    setName?: unknown;
    isFoil?: unknown;
    isSpecificVersion?: unknown;
    isForTrade?: unknown;
    wishlistId?: unknown;
    scryfallData?: unknown;
    
    lastPriceUpdate?: unknown;
    addedAt?: unknown;
    importedAt?: unknown;
    lastUpdated?: unknown;
    
    [key: string]: unknown;
}

// --- FONCTION DE S√âRIALISATION AVEC V√âRIFICATION DES TYPES ---
const serializeCard = (docId: string, data: FirestoreCardData, forceIsWishlist: boolean): CardType => {
    
    const toDate = (val: unknown): Date | null => {
        if (val && typeof val === 'object' && 'toDate' in val && typeof (val as { toDate: () => Date }).toDate === 'function') {
            return (val as { toDate: () => Date }).toDate();
        }
        if (val instanceof Date) return val;
        return null;
    };
    
    const isString = (val: unknown): string | undefined => typeof val === 'string' ? val : undefined;
    const isNumber = (val: unknown): number | undefined => typeof val === 'number' ? val : undefined;
    const isBoolean = (val: unknown): boolean => typeof val === 'boolean' ? val : false;

    // Pr√©-calcul pour √©viter les assertions non nulles (!) plus bas
    const rawQuantity = isNumber(data.quantity);
    const rawQuantityForTrade = isNumber(data.quantityForTrade);
    const isForTradeBool = isBoolean(data.isForTrade);

    return {
        id: docId,
        name: isString(data.name) || 'Carte Inconnue',
        imageUrl: isString(data.imageUrl) || '',
        imageBackUrl: isString(data.imageBackUrl) ?? null,
        
        quantity: rawQuantity !== undefined ? rawQuantity : 1,
        price: isNumber(data.price) || 0,
        customPrice: isNumber(data.customPrice),
        
        setName: isString(data.setName) || '',
        setCode: isString(data.setCode) || '',
        
        isFoil: isBoolean(data.isFoil),
        isSpecificVersion: isBoolean(data.isSpecificVersion),
        
        // Logique stricte pour la quantit√© d'√©change sans "any" ni "!"
        quantityForTrade: rawQuantityForTrade !== undefined
            ? rawQuantityForTrade
            : (isForTradeBool && rawQuantity !== undefined ? rawQuantity : 0),
        
        wishlistId: forceIsWishlist ? (isString(data.wishlistId) || 'default') : null,
        
        // On s'assure que c'est un objet Record<string, unknown> si non null
        scryfallData: (typeof data.scryfallData === 'object' && data.scryfallData !== null) 
            ? data.scryfallData as Record<string, unknown> : null,
            
        lastPriceUpdate: toDate(data.lastPriceUpdate)
    };
};

export async function runServerScan(userId: string): Promise<ScannerResult> {
    const db = getAdminFirestore();

    // --- VERIFICATION CREDIT ---
    // On v√©rifie et consomme le cr√©dit AVANT de lancer les requ√™tes lourdes
    const creditCheck = await checkAndConsumeCredits(userId, 'TRADE_MATCH');
    if (!creditCheck.allowed) {
        return { success: false, error: creditCheck.error };
    }
    // ---------------------------

    try {
        // 1. Identifier tous les partenaires (Amis + Groupes)
        const partnersMap = new Map<string, ScannedPartnerInfo>();

        // A. R√©cup√©rer les Amis
        const friendsSnap = await db.collection(`users/${userId}/friends`).get();
        friendsSnap.forEach(doc => {
            const d = doc.data() as FirestoreUserData;
            partnersMap.set(doc.id, { 
                uid: doc.id, 
                displayName: typeof d.displayName === 'string' ? d.displayName : 'Ami inconnu', 
                photoURL: typeof d.photoURL === 'string' ? d.photoURL : null 
            });
        });

        // B. R√©cup√©rer les Groupes
        const groupsSnap = await db.collection('groups').where('members', 'array-contains', userId).get();
        const memberUids = new Set<string>();
        
        groupsSnap.forEach(g => {
            const d = g.data() as FirestoreGroupData;
            const members = Array.isArray(d.members) ? d.members : [];
            members.forEach((m: unknown) => {
                if (typeof m === 'string' && m !== userId && !partnersMap.has(m)) {
                    memberUids.add(m);
                }
            });
        });

        // C. R√©cup√©rer les infos des inconnus du groupe
        if (memberUids.size > 0) {
            const unknownUids = Array.from(memberUids);
            await Promise.all(unknownUids.map(async (uid) => {
                const p = await db.doc(`users/${uid}/public_profile/info`).get();
                if (p.exists) {
                    const d = p.data() as FirestoreUserData;
                    partnersMap.set(uid, { 
                        uid, 
                        displayName: typeof d.displayName === 'string' ? d.displayName : (typeof d.username === 'string' ? d.username : 'Membre Groupe'),
                        photoURL: typeof d.photoURL === 'string' ? d.photoURL : null 
                    });
                }
            }));
        }

        if (partnersMap.size === 0) return { success: true, proposals: [] };

        // 2. Charger MES donn√©es (pour l'ajustement de la quantit√© re√ßue)
        const myCollectionSnap = await db.collection(`users/${userId}/collection`).where('quantityForTrade', '>', 0).get();
        const myWishlistSnap = await db.collection(`users/${userId}/wishlist`).get();

        // Indexation de MA Wishlist par Nom -> Quantit√© d√©sir√©e
        const myWishlistDetails = new Map<string, { quantity: number, card: CardType }>();
        myWishlistSnap.forEach(d => {
            const card = serializeCard(d.id, d.data() as FirestoreCardData, true);
            if (card.name) {
                myWishlistDetails.set(card.name, {
                    quantity: card.quantity, 
                    card
                });
            }
        });

        // Pour le matching "Je donne"
        const myTradeCards = myCollectionSnap.docs.map(d => serializeCard(d.id, d.data() as FirestoreCardData, false));

        // 3. Scanner chaque partenaire
        const proposals: ScannedProposal[] = [];

        await Promise.all(Array.from(partnersMap.values()).map(async (partner) => {
            // Lecture Collection & Wishlist Partenaire
            const pColSnap = await db.collection(`users/${partner.uid}/collection`).where('quantityForTrade', '>', 0).get();
            const pWishSnap = await db.collection(`users/${partner.uid}/wishlist`).get();

            const pTradeCards = pColSnap.docs.map(d => serializeCard(d.id, d.data() as FirestoreCardData, false));
            
            // Pour la wishlist du partenaire (pour le matching "Je donne")
            const pWishListDetails = new Map<string, { quantity: number, card: CardType }>();
            pWishSnap.forEach(d => {
                const card = serializeCard(d.id, d.data() as FirestoreCardData, true);
                if (card.name) {
                    pWishListDetails.set(card.name, { 
                        quantity: card.quantity, 
                        card
                    });
                }
            });

            const toReceive: CardType[] = [];
            const toGive: CardType[] = [];

            // MATCH: Je re√ßois (Sa collection -> Ma Wishlist)
            pTradeCards.forEach(card => {
                const myWish = myWishlistDetails.get(card.name);
                if (myWish) {
                    
                    const neededQty = myWish.quantity; 
                    const friendTradeQty = card.quantityForTrade; 
                    
                    const finalReceiveQty = Math.min(neededQty, friendTradeQty);

                    if (finalReceiveQty > 0) {
                        const cardToReceive: CardType = { ...card, quantity: finalReceiveQty, quantityForTrade: finalReceiveQty };
                        toReceive.push(cardToReceive);
                    }
                }
            });

            // MATCH: Je donne (Ma collection -> Sa Wishlist)
            myTradeCards.forEach(card => {
                const partnerWish = pWishListDetails.get(card.name);
                if (partnerWish) {
                    
                    const neededQty = partnerWish.quantity; 
                    const myTradeQty = card.quantityForTrade; 

                    const finalGiveQty = Math.min(neededQty, myTradeQty);
                    
                    if (finalGiveQty > 0) {
                        const cardToGive: CardType = { ...card, quantity: finalGiveQty, quantityForTrade: finalGiveQty };
                        toGive.push(cardToGive);
                    }
                }
            });

            if (toReceive.length > 0 || toGive.length > 0) {
                const valReceive = toReceive.reduce((acc, c) => acc + (c.price || 0) * (c.quantityForTrade || 1), 0);
                const valGive = toGive.reduce((acc, c) => acc + (c.price || 0) * (c.quantityForTrade || 1), 0);

                proposals.push({
                    partnerInfo: partner,
                    toReceive,
                    toGive,
                    balance: valGive - valReceive
                });
            }
        }));

        return { 
            success: true, 
            proposals: proposals.sort((a, b) => b.balance - a.balance)
        };

    } catch (error: unknown) {
        console.error("Erreur Scan Serveur:", error);
        let message = "Erreur serveur inconnue";
        if (error instanceof Error) message = error.message;
        else if (typeof error === "string") message = error;
        
        return { success: false, error: message };
    }
}
</file>

<file path="app/api/portal/route.ts">
// app/api/portal/route.ts
import { NextResponse } from 'next/server';
import Stripe from 'stripe';

export async function POST(req: Request) {
    try {
        // On initialise Stripe ICI, √† l'int√©rieur de la fonction
        // Cela √©vite de faire planter le build si la cl√© n'est pas encore l√†
        const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {
            apiVersion: '2025-11-17.clover', 
        });

        const body = await req.json();
        const { customerId } = body; 

        if (!customerId) {
             return NextResponse.json({ error: "Customer ID manquant" }, { status: 400 });
        }

        const session = await stripe.billingPortal.sessions.create({
            customer: customerId,
            return_url: `${process.env.NEXT_PUBLIC_BASE_URL}/premium`,
        });

        return NextResponse.json({ url: session.url });
        
    } catch (err: unknown) {
        console.error("Erreur cr√©ation portail Stripe:", err);
        let errorMessage = "Erreur serveur";
        if (err instanceof Error) errorMessage = err.message;
        else if (typeof err === 'string') errorMessage = err;
        return NextResponse.json({ error: errorMessage }, { status: 500 });
    }
}
</file>

<file path="app/api/webhook/stripe/route.ts">
// app/api/webhook/stripe/route.ts
import { NextResponse } from 'next/server';
import { headers } from 'next/headers';
import Stripe from 'stripe';
import { getAdminFirestore } from '@/lib/firebase-admin';
import { FieldValue } from 'firebase-admin/firestore';

export async function POST(req: Request) {
  const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {
    apiVersion: '2025-11-17.clover', 
  });

  const body = await req.text();
  const headerList = await headers();
  const signature = headerList.get('Stripe-Signature') as string;

  let event: Stripe.Event;

  try {
    event = stripe.webhooks.constructEvent(
        body, 
        signature, 
        process.env.STRIPE_WEBHOOK_SECRET!
    );
  } catch (error: unknown) {
    const errorMessage = error instanceof Error ? error.message : "Unknown error";
    console.error("Webhook signature failed", errorMessage);
    return new NextResponse(`Webhook Error: ${errorMessage}`, { status: 400 });
  }

  const db = getAdminFirestore();

  try {
      switch (event.type) {
        case 'checkout.session.completed': {
          const session = event.data.object as Stripe.Checkout.Session;
          const userId = session.client_reference_id; 
          
          if (userId) {
            await db.collection('users').doc(userId).set({
              isPremium: true,
              stripeCustomerId: session.customer as string,
              stripeSubscriptionId: session.subscription as string,
              premiumSince: FieldValue.serverTimestamp(),
            }, { merge: true });
            console.log(`‚úÖ User ${userId} passed Premium`);
          }
          break;
        }

        case 'customer.subscription.deleted': {
          const subscription = event.data.object as Stripe.Subscription;
          const stripeSubId = subscription.id;

          const snapshot = await db.collection('users')
            .where('stripeSubscriptionId', '==', stripeSubId)
            .get();

          if (!snapshot.empty) {
            const batch = db.batch();
            snapshot.docs.forEach(doc => {
                batch.update(doc.ref, { 
                    isPremium: false,
                    premiumEndedAt: FieldValue.serverTimestamp()
                });
            });
            await batch.commit();
            console.log(`Subscription ${stripeSubId} deleted. User downgraded.`);
          }
          break;
        }
      }
  } catch (err) {
      console.error("Firebase update error", err);
      return new NextResponse("Server Error", { status: 500 });
  }

  return NextResponse.json({ received: true });
}
</file>

<file path="app/mentions-legales/page.tsx">
// app/mentions-legales/page.tsx
'use client';

import React from 'react';

export default function MentionsLegales() {
    return (
        <main className="min-h-screen bg-background pb-20 pt-8">
            <div className="max-w-4xl mx-auto px-4 py-8">
                <h1 className="text-3xl font-bold mb-8 text-foreground border-b border-border pb-4 mt-8">
                    Mentions L√©gales & CGV
                </h1>

                <section className="mb-8 p-6 bg-surface rounded-xl border border-border shadow-sm">
                    <h2 className="text-xl font-bold mb-4 text-primary">1. √âdition du site</h2>
                    <p className="text-muted-foreground mb-4">
                        En vertu de l&apos;article 6 de la loi n¬∞ 2004-575 du 21 juin 2004 pour la confiance dans l&apos;√©conomie num√©rique, 
                        il est pr√©cis√© aux utilisateurs du site <strong>www.magicwish.be</strong> (l&apos;application) l&apos;identit√© des diff√©rents intervenants :
                    </p>
                    <ul className="list-disc pl-6 text-muted-foreground space-y-2">
                        <li><strong>URL du site :</strong> https://www.magicwish.be</li>
                        <li><strong>Propri√©taire / √âditeur :</strong> Ga√´l Montpelier</li>
                        <li><strong>Contact :</strong> magicwish.be.contact@gmail.com</li>
                    </ul>
                </section>

                <section className="mb-8 p-6 bg-surface rounded-xl border border-border shadow-sm">
                    <h2 className="text-xl font-bold mb-4 text-primary">2. H√©bergement</h2>
                    <p className="text-muted-foreground">
                        Le site est h√©berg√© par la soci√©t√© <strong>Vercel Inc.</strong>, situ√©e au 340 S Lemon Ave #1192, Walnut, CA 91789, USA. 
                        <br />Contact : https://vercel.com.
                    </p>
                </section>

                {/* SECTION OBLIGATOIRE SI TU VENDS DU PREMIUM */}
                <section className="mb-8 p-6 bg-surface rounded-xl border border-border shadow-sm">
                    <h2 className="text-xl font-bold mb-4 text-primary">3. Conditions G√©n√©rales de Vente (Service Premium)</h2>
                    <div className="text-muted-foreground space-y-4">
                        <p>
                            MagicWish propose un abonnement optionnel &quot;Premium&quot; permettant de lever les limites de cr√©ation de listes et d&apos;acc√©der aux outils de mani√®re illimit√©e.
                        </p>
                        <ul className="list-disc pl-6 space-y-2">
                            <li><strong>Prix :</strong> 1,00 ‚Ç¨ TTC par mois.</li>
                            <li><strong>Paiement :</strong> S√©curis√© via Stripe. Aucune donn√©e bancaire n&apos;est conserv√©e par MagicWish.</li>
                            <li><strong>Dur√©e et R√©siliation :</strong> Abonnement mensuel sans engagement, renouvelable tacitement. L&apos;utilisateur peut r√©silier √† tout moment depuis son espace Stripe (accessible via les param√®tres ou le mail de confirmation), l&apos;acc√®s Premium restant actif jusqu&apos;√† la fin de la p√©riode pay√©e.</li>
                            <li><strong>Remboursement :</strong> Compte tenu de la nature num√©rique imm√©diate du service, aucun remboursement n&apos;est effectu√© pour le mois entam√©, sauf obligation l√©gale contraire.</li>
                        </ul>
                    </div>
                </section>

                <section className="mb-8 p-6 bg-surface rounded-xl border border-border shadow-sm">
                    <h2 className="text-xl font-bold mb-4 text-primary">4. Propri√©t√© intellectuelle</h2>
                    <p className="text-muted-foreground mb-4">
                        MagicWish est une application ind√©pendante. Les visuels des cartes, les noms, les symboles de raret√© et 
                        les textes des cartes sont la propri√©t√© de <strong>Wizards of the Coast LLC</strong> (filiale de Hasbro, Inc.). 
                        MagicWish n&apos;est pas affili√©, approuv√© ou parrain√© par Wizards of the Coast.
                    </p>
                    <p className="text-muted-foreground">
                        La structure g√©n√©rale, les textes, les logos propres √† MagicWish et le code source de l&apos;application 
                        sont la propri√©t√© exclusive de l&apos;√©diteur. Toute reproduction totale ou partielle est interdite.
                    </p>
                </section>

                <section className="mb-8 p-6 bg-surface rounded-xl border border-border shadow-sm">
                    <h2 className="text-xl font-bold mb-4 text-primary">5. Limitation de responsabilit√©</h2>
                    <p className="text-muted-foreground">
                        MagicWish s&apos;efforce de fournir des informations pr√©cises (prix Scryfall, base de donn√©es). Cependant, 
                        l&apos;√©diteur ne pourra √™tre tenu responsable des omissions ou des lacunes dans la mise √† jour des prix 
                        ou des donn√©es de cartes provenant de sources tierces.
                    </p>
                </section>
                
                <p className="text-xs text-muted-foreground text-center mt-12">
                    Derni√®re mise √† jour : 24 D√©cembre 2025
                </p>
            </div>
        </main>
    );
}
</file>

<file path="app/premium/page.tsx">
// app/mentions-legales/page.tsx
'use client';

import React from 'react';
import Header from '@/components/Header';

export default function MentionsLegales() {
    return (
        <main className="min-h-screen bg-background pb-20">
            <Header />
            <div className="max-w-4xl mx-auto px-4 py-8">
                <h1 className="text-3xl font-bold mb-8 text-foreground border-b border-border pb-4 mt-8">
                    Mentions L√©gales
                </h1>

                <section className="mb-8 p-6 bg-surface rounded-xl border border-border shadow-sm">
                    <h2 className="text-xl font-bold mb-4 text-primary">1. √âdition du site</h2>
                    <p className="text-muted-foreground mb-4">
                        En vertu de l&apos;article 6 de la loi n¬∞ 2004-575 du 21 juin 2004 pour la confiance dans l&apos;√©conomie num√©rique, 
                        il est pr√©cis√© aux utilisateurs de l&apos;application MagicWish l&apos;identit√© des diff√©rents intervenants dans 
                        le cadre de sa r√©alisation et de son suivi :
                    </p>
                    <ul className="list-disc pl-6 text-muted-foreground space-y-2">
                        <li><strong>Propri√©taire / √âditeur :</strong> Ga√´l Montpelier</li>
                        <li><strong>Responsable de la publication :</strong> Ga√´l Montpelier</li>
                        <li><strong>Contact :</strong> magicwish.be.contact@gmail.com</li>
                        <li><strong>Webmaster :</strong> MagicWish Tech Team</li>
                    </ul>
                </section>

                <section className="mb-8 p-6 bg-surface rounded-xl border border-border shadow-sm">
                    <h2 className="text-xl font-bold mb-4 text-primary">2. H√©bergement</h2>
                    <p className="text-muted-foreground">
                        Le site est h√©berg√© par la soci√©t√© <strong>Vercel Inc.</strong>, situ√©e au 340 S Lemon Ave #1192, Walnut, CA 91789, USA. 
                        Contact : https://vercel.com.
                    </p>
                </section>

                <section className="mb-8 p-6 bg-surface rounded-xl border border-border shadow-sm">
                    <h2 className="text-xl font-bold mb-4 text-primary">3. Propri√©t√© intellectuelle</h2>
                    <p className="text-muted-foreground mb-4">
                        MagicWish est une application ind√©pendante. Les visuels des cartes, les noms, les symboles de raret√© et 
                        les textes des cartes sont la propri√©t√© de <strong>Wizards of the Coast LLC</strong> (filiale de Hasbro, Inc.). 
                        MagicWish n&apos;est pas affili√©, approuv√© ou parrain√© par Wizards of the Coast.
                    </p>
                    <p className="text-muted-foreground">
                        La structure g√©n√©rale, les textes, les logos propres √† MagicWish et le code source de l&apos;application 
                        sont la propri√©t√© exclusive de l&apos;√©diteur. Toute reproduction totale ou partielle est interdite.
                    </p>
                </section>

                <section className="mb-8 p-6 bg-surface rounded-xl border border-border shadow-sm">
                    <h2 className="text-xl font-bold mb-4 text-primary">4. Limitation de responsabilit√©</h2>
                    <p className="text-muted-foreground">
                        MagicWish s&apos;efforce de fournir des informations pr√©cises (prix Scryfall, base de donn√©es). Cependant, 
                        l&apos;√©diteur ne pourra √™tre tenu responsable des omissions ou des lacunes dans la mise √† jour des prix 
                        ou des donn√©es de cartes provenant de sources tierces.
                    </p>
                </section>
                
                <p className="text-xs text-muted-foreground text-center mt-12">
                    Derni√®re mise √† jour : 19 D√©cembre 2025
                </p>
            </div>
        </main>
    );
}
</file>

<file path="app/stats/page.tsx">
'use client';

import { useState, useEffect, useMemo, useCallback } from 'react';
import { useAuth } from '@/lib/AuthContext';
import { db } from '@/lib/firebase';
// eslint-disable-next-line @typescript-eslint/no-unused-vars
import { collection, getDocs, query, where, doc, getDoc, documentId } from 'firebase/firestore';
import { useFriends } from '@/hooks/useFriends';
import Image from 'next/image';

// --- TYPES STRICTS ---

type StatProfile = {
    uid: string;
    displayName: string;
    username: string;
    photoURL: string | null;
    totalValue: number;
    totalCards: number;
    uniqueCards: number;
    foilCount: number;
    avgPrice: number;
};

type GroupOption = {
    id: string;
    name: string;
    members: string[];
};

// Interface pour les donn√©es brutes Firestore
interface FirestoreStats {
    totalValue?: number;
    totalCards?: number;
    uniqueCards?: number;
    foilCount?: number;
    avgPrice?: number;
}

// --- COMPOSANTS DE PR√âSENTATION ---

const StatCard = ({ 
    title, 
    winner, 
    value, 
    colorClass,
    valueColor 
}: { 
    title: string, 
    winner?: StatProfile, 
    value: string, 
    colorClass: string,
    valueColor: string 
}) => (
    <div className={`bg-surface border-l-4 ${colorClass} rounded-xl p-4 shadow-sm flex flex-col justify-between h-full`}>
        <div>
            <h3 className="text-xs font-bold text-muted uppercase tracking-wider mb-2">{title}</h3>
            {winner ? (
                <div className="flex items-center gap-3 mb-2">
                    <div className="w-10 h-10 rounded-full bg-secondary overflow-hidden shrink-0 border border-border relative">
                        {winner.photoURL ? (
                            <Image src={winner.photoURL} alt={winner.username} fill className="object-cover" />
                        ) : (
                            <div className="w-full h-full flex items-center justify-center font-bold text-muted text-xs">
                                {winner.username[0]?.toUpperCase()}
                            </div>
                        )}
                    </div>
                    <div className="min-w-0">
                        <p className="font-bold text-foreground truncate">{winner.displayName}</p>
                        <p className="text-xs text-muted">@{winner.username}</p>
                    </div>
                </div>
            ) : (
                <p className="text-sm text-muted italic">En attente...</p>
            )}
        </div>
        <div className="text-right">
            <span className={`text-2xl font-black ${valueColor}`}>
                {winner ? value : '-'}
            </span>
        </div>
    </div>
);

const LeaderboardRow = ({ rank, profile }: { rank: number, profile: StatProfile }) => {
    let rankStyle = "bg-secondary text-muted";
    if (rank === 1) rankStyle = "bg-yellow-100 text-yellow-700 border-yellow-200";
    if (rank === 2) rankStyle = "bg-gray-100 text-gray-700 border-gray-200";
    if (rank === 3) rankStyle = "bg-orange-100 text-orange-700 border-orange-200";

    return (
        <div className="flex items-center gap-4 p-3 border-b border-border last:border-0 hover:bg-secondary/20 transition">
            <div className={`w-8 h-8 rounded-full flex items-center justify-center font-bold text-sm border shrink-0 ${rankStyle}`}>
                {rank}
            </div>
            
            <div className="w-10 h-10 rounded-full bg-secondary overflow-hidden shrink-0 border border-border relative">
                {profile.photoURL ? (
                    <Image src={profile.photoURL} alt={profile.username} fill className="object-cover" />
                ) : (
                    <div className="w-full h-full flex items-center justify-center font-bold text-muted text-xs">
                        {profile.username[0]?.toUpperCase()}
                    </div>
                )}
            </div>

            <div className="grow min-w-0">
                <p className="font-bold text-foreground truncate">{profile.displayName}</p>
                <div className="flex gap-2 text-xs text-muted items-center">
                    <span>@{profile.username}</span>
                    <span className="hidden sm:inline">‚Ä¢ {profile.totalCards} cartes</span>
                </div>
            </div>
            <div className="text-right">
                <p className="font-bold text-primary">{profile.totalValue.toFixed(0)} ‚Ç¨</p>
                <p className="text-xs text-muted">Moy. {profile.avgPrice.toFixed(1)} ‚Ç¨</p>
            </div>
        </div>
    );
};

export default function StatsPage() {
    const { user } = useAuth();
    const { friends } = useFriends();
    
    const [scope, setScope] = useState<'friends' | 'group'>('friends');
    const [myGroups, setMyGroups] = useState<GroupOption[]>([]);
    const [selectedGroupId, setSelectedGroupId] = useState<string>('');
    
    const [stats, setStats] = useState<StatProfile[]>([]);
    const [loading, setLoading] = useState(false);

    // 1. Charger les groupes
    useEffect(() => {
        if (!user) return;
        const fetchGroups = async () => {
            try {
                const q = query(collection(db, 'groups'), where('members', 'array-contains', user.uid));
                const snap = await getDocs(q);
                const groupsList = snap.docs.map(d => ({ id: d.id, ...d.data() } as GroupOption));
                setMyGroups(groupsList);
                if (groupsList.length > 0) setSelectedGroupId(groupsList[0].id);
            } catch (e) {
                console.error("Erreur chargement groupes", e);
            }
        };
        fetchGroups();
    }, [user]);

    // 2. Fonction de calcul OPTIMIS√âE (Parall√®le)
    const calculateStats = useCallback(async () => {
        if (!user) return;
        setLoading(true);
        
        let targetUids: string[] = [];

        if (scope === 'friends') {
            // On inclut l'utilisateur courant + ses amis
            targetUids = [user.uid, ...friends.map(f => f.uid)];
        } else {
            const group = myGroups.find(g => g.id === selectedGroupId);
            if (group) targetUids = group.members;
        }

        // D√©doublonnage au cas o√π
        targetUids = Array.from(new Set(targetUids));

        if (targetUids.length === 0) {
            setStats([]);
            setLoading(false);
            return;
        }

        try {
            // Lancement de TOUTES les requ√™tes en parall√®le
            const promises = targetUids.map(async (uid) => {
                try {
                    // A. R√©cup√©ration Profil (Optimis√©: on utilise les donn√©es locales si ami/soi-m√™me)
                    let profileData = { 
                        displayName: 'Inconnu', 
                        username: '?', 
                        photoURL: null as string | null 
                    };

                    if (uid === user.uid) {
                        profileData = { 
                            displayName: user.displayName || 'Moi', 
                            username: 'moi', 
                            photoURL: user.photoURL 
                        };
                    } else {
                        const friend = friends.find(f => f.uid === uid);
                        if (friend) {
                            profileData = { 
                                displayName: friend.displayName, 
                                username: friend.username, 
                                photoURL: friend.photoURL || null 
                            };
                        } else {
                            // Si pas ami direct (membre de groupe), on fetch le profil
                            const userSnap = await getDoc(doc(db, 'users', uid, 'public_profile', 'info'));
                            if (userSnap.exists()) {
                                const d = userSnap.data();
                                profileData = {
                                    displayName: d.displayName || 'Sans nom',
                                    username: d.username || '?',
                                    photoURL: d.photoURL || null
                                };
                            }
                        }
                    }

                    // B. R√©cup√©ration Stats (Lecture seule du document cach√©)
                    // On ne recalcule PAS (updateUserStats) ici pour la vitesse.
                    const statsSnap = await getDoc(doc(db, 'users', uid, 'public_profile', 'stats'));
                    const userStats = statsSnap.exists() ? (statsSnap.data() as FirestoreStats) : {};

                    return {
                        uid,
                        ...profileData,
                        totalValue: userStats.totalValue || 0,
                        totalCards: userStats.totalCards || 0,
                        uniqueCards: userStats.uniqueCards || 0,
                        foilCount: userStats.foilCount || 0,
                        avgPrice: userStats.avgPrice || 0
                    };
                } catch (err) {
                    console.error(`Erreur pour ${uid}`, err);
                    return null;
                }
            });

            // Attente de tous les r√©sultats
            const results = await Promise.all(promises);
            
            // Filtrage des erreurs (null) et tri
            const validResults = results.filter((r): r is StatProfile => r !== null);
            setStats(validResults.sort((a, b) => b.totalValue - a.totalValue));

        } catch (error) {
            console.error("Erreur globale stats", error);
        } finally {
            setLoading(false);
        }
    }, [user, friends, scope, selectedGroupId, myGroups]);

    // 3. Trigger automatique
    useEffect(() => {
        calculateStats();
    }, [calculateStats]);

    // --- CALCUL DES GAGNANTS ---
    const topValue = useMemo(() => [...stats].sort((a, b) => b.totalValue - a.totalValue)[0], [stats]);
    const topUnique = useMemo(() => [...stats].sort((a, b) => b.uniqueCards - a.uniqueCards)[0], [stats]);
    const topFoil = useMemo(() => [...stats].sort((a, b) => b.foilCount - a.foilCount)[0], [stats]);
    const topWhale = useMemo(() => [...stats].sort((a, b) => b.avgPrice - a.avgPrice)[0], [stats]);

    if (!user) return <div className="p-10 text-center text-muted">Veuillez vous connecter.</div>;

    return (
        <main className="container mx-auto p-4 max-w-5xl min-h-[85vh]">
            <div className="flex flex-col md:flex-row justify-between items-end mb-8 border-b border-border pb-4 gap-4">
                <div>
                    <h1 className="text-3xl font-black text-primary tracking-tight">Panth√©on</h1>
                    <p className="text-muted text-sm">Le classement en temps r√©el de votre communaut√©.</p>
                </div>
                
                <div className="flex items-center gap-2 bg-surface p-1 rounded-lg border border-border shadow-sm">
                    <button 
                        onClick={() => setScope('friends')}
                        className={`px-4 py-2 text-sm font-bold rounded-md transition ${scope === 'friends' ? 'bg-primary text-primary-foreground shadow-sm' : 'text-muted hover:text-foreground'}`}
                    >
                        Amis
                    </button>
                    {myGroups.length > 0 && (
                        <button 
                            onClick={() => setScope('group')}
                            className={`px-4 py-2 text-sm font-bold rounded-md transition ${scope === 'group' ? 'bg-primary text-primary-foreground shadow-sm' : 'text-muted hover:text-foreground'}`}
                        >
                            Playgroups
                        </button>
                    )}
                </div>
            </div>

            {/* S√âLECTEUR DE GROUPE */}
            {scope === 'group' && (
                <div className="mb-6 flex gap-4 items-center animate-in fade-in">
                    <select 
                        value={selectedGroupId} 
                        onChange={(e) => setSelectedGroupId(e.target.value)}
                        className="p-3 bg-surface border border-border rounded-xl text-foreground font-medium outline-none focus:ring-2 focus:ring-primary min-w-[250px]"
                    >
                        {myGroups.map(g => <option key={g.id} value={g.id}>{g.name} ({g.members.length} membres)</option>)}
                    </select>
                </div>
            )}

            {/* CHARGEMENT */}
            {loading && (
                <div className="text-center py-20 animate-pulse">
                    <div className="w-12 h-12 border-4 border-primary/30 border-t-primary rounded-full animate-spin mx-auto mb-4"></div>
                    <p className="text-muted font-medium">R√©cup√©ration des scores...</p>
                </div>
            )}

            {/* R√âSULTATS */}
            {!loading && stats.length > 0 && (
                <div className="space-y-8 animate-in slide-in-from-bottom-8 duration-500">
                    
                    {/* PODIUM */}
                    <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
                        <StatCard 
                            title="Grand Tr√©sorier" 
                            winner={topValue} 
                            value={`${topValue?.totalValue.toFixed(0)} ‚Ç¨`} 
                            colorClass="border-yellow-500 bg-yellow-50 dark:bg-yellow-900/10" 
                            valueColor="text-yellow-600 dark:text-yellow-400"
                        />
                        <StatCard 
                            title="Archiviste" 
                            winner={topUnique} 
                            value={`${topUnique?.uniqueCards}`} 
                            colorClass="border-blue-500 bg-blue-50 dark:bg-blue-900/10"
                            valueColor="text-blue-600 dark:text-blue-400"
                        />
                        <StatCard 
                            title="Seigneur Foil" 
                            winner={topFoil} 
                            value={`${topFoil?.foilCount}`} 
                            colorClass="border-purple-500 bg-purple-50 dark:bg-purple-900/10"
                            valueColor="text-purple-600 dark:text-purple-400"
                        />
                        <StatCard 
                            title="La Baleine" 
                            winner={topWhale} 
                            value={`${topWhale?.avgPrice.toFixed(1)} ‚Ç¨`} 
                            colorClass="border-green-500 bg-green-50 dark:bg-green-900/10"
                            valueColor="text-green-600 dark:text-green-400"
                        />
                    </div>

                    {/* CLASSEMENT */}
                    <div className="bg-surface rounded-2xl border border-border shadow-sm overflow-hidden">
                        <div className="p-4 border-b border-border bg-secondary/30">
                            <h3 className="font-bold text-foreground">Classement G√©n√©ral (Valeur)</h3>
                        </div>
                        <div className="divide-y divide-border">
                            {stats.map((profile, index) => (
                                <LeaderboardRow key={profile.uid} rank={index + 1} profile={profile} />
                            ))}
                        </div>
                    </div>
                </div>
            )}
        </main>
    );
}
</file>

<file path="components/card-page/DualQuantityManager.tsx">
// components/card-page/DualQuantityManager.tsx
'use client';

import { useState, useEffect, useRef } from 'react';
import { db } from '@/lib/firebase';
import { collection, query, where, getDocs, doc, deleteDoc, updateDoc, setDoc, serverTimestamp } from 'firebase/firestore';
import { CardType } from '@/hooks/useCardCollection';
import { ScryfallRawData } from '@/lib/cardUtils';
import { useAuth } from '@/lib/AuthContext';
import { checkAutoMatch, removeAutoMatchNotification } from '@/app/actions/matching';
import { useDebouncedUpdate } from '@/hooks/useDebounceUpdate';
import toast from 'react-hot-toast';

type Props = {
    card: CardType;
    onUpdate?: () => void;
};

// Interface pour l'√©tat local optimiste
type VariantState = {
    qty: number;
    trade: number;
    docId: string | null;
    exists: boolean;
};

// Interface minimale pour une erreur Firestore
interface FirestoreError {
    code?: string;
    message?: string;
}

// Interface pour typage s√©curis√© de 'finishes'
interface ScryfallWithFinishes {
    finishes?: string[];
}

export default function DualQuantityManager({ card, onUpdate }: Props) {
    const { user } = useAuth();
    
    // --- √âTATS OPTIMISTES ---
    const [normalState, setNormalState] = useState<VariantState>({ qty: 0, trade: 0, docId: null, exists: false });
    const [foilState, setFoilState] = useState<VariantState>({ qty: 0, trade: 0, docId: null, exists: false });
    const [loading, setLoading] = useState(true);

    const cardDataRef = useRef(card);
    cardDataRef.current = card;

    const scryfallData = card.scryfallData as ScryfallRawData | undefined;
    const scryfallId = scryfallData?.id || card.id; 

    // --- VERIFICATION DES FINITIONS ---
    const detailedData = scryfallData as unknown as ScryfallWithFinishes | undefined;
    const finishes = detailedData?.finishes || [];
    
    // Si la liste est vide, on affiche tout par pr√©caution
    const hasNonFoil = finishes.length === 0 || finishes.includes('nonfoil');
    const hasFoil = finishes.length === 0 || finishes.includes('foil') || finishes.includes('etched');

    // 1. CHARGEMENT INITIAL
    useEffect(() => {
        const fetchVariants = async () => {
            if (!user || !scryfallId) return;
            setLoading(true);
            try {
                const q = query(
                    collection(db, 'users', user.uid, 'collection'),
                    where('scryfallData.id', '==', scryfallId)
                );
                
                const snap = await getDocs(q);
                
                const newNormal: VariantState = { qty: 0, trade: 0, docId: null, exists: false };
                const newFoil: VariantState = { qty: 0, trade: 0, docId: null, exists: false };

                snap.forEach(d => {
                    const data = d.data() as CardType;
                    if (data.isFoil) {
                        newFoil.qty = data.quantity;
                        newFoil.trade = data.quantityForTrade || 0;
                        newFoil.docId = d.id;
                        newFoil.exists = true;
                    } else {
                        newNormal.qty = data.quantity;
                        newNormal.trade = data.quantityForTrade || 0;
                        newNormal.docId = d.id;
                        newNormal.exists = true;
                    }
                });

                setNormalState(newNormal);
                setFoilState(newFoil);

            } catch (e) {
                console.error("Erreur chargement variantes", e);
            } finally {
                setLoading(false);
            }
        };

        fetchVariants();
    }, [user, scryfallId]); 

    // 2. FONCTION D'√âCRITURE EN BASE (Debounced)
    const performDatabaseUpdate = async (isFoil: boolean, finalQty: number, finalTrade: number, currentDocId: string | null) => {
        if (!user) return;

        try {
            // CAS A : SUPPRESSION
            if (finalQty <= 0) {
                if (currentDocId) {
                    await deleteDoc(doc(db, 'users', user.uid, 'collection', currentDocId));
                    removeAutoMatchNotification(user.uid, [currentDocId]);
                    if (onUpdate) onUpdate();
                }
                return;
            }

            // CAS B : MISE √Ä JOUR
            if (currentDocId) {
                try {
                    await updateDoc(doc(db, 'users', user.uid, 'collection', currentDocId), {
                        quantity: finalQty,
                        quantityForTrade: finalTrade,
                        isForTrade: finalTrade > 0,
                        lastPriceUpdate: new Date().toISOString()
                    });
                } catch (err: unknown) {
                    const firestoreError = err as FirestoreError;
                    if (firestoreError.code === 'not-found') {
                        console.warn("Tentative de mise √† jour sur un document supprim√© (ignor√©).");
                        return;
                    }
                    throw err; 
                }
                
                if (finalTrade > 0) {
                    checkAutoMatch(user.uid, [{ id: currentDocId, name: cardDataRef.current.name, isFoil }]);
                }
            } 
            // CAS C : CR√âATION
            else {
                const newId = `${scryfallId}_${isFoil ? 'foil' : 'normal'}`;
                const newDocRef = doc(db, 'users', user.uid, 'collection', newId);
                
                let initialPrice = cardDataRef.current.price || 0;
                const sData = cardDataRef.current.scryfallData as ScryfallRawData;
                if (sData && sData.prices) {
                    const pNormal = parseFloat(sData.prices.eur || "0");
                    const pFoil = parseFloat(sData.prices.eur_foil || "0");
                    if (isFoil) initialPrice = pFoil > 0 ? pFoil : (pNormal > 0 ? pNormal : initialPrice);
                    else initialPrice = pNormal > 0 ? pNormal : (pFoil > 0 ? pFoil : initialPrice);
                }

                const newCardData = {
                    ...cardDataRef.current,
                    id: newId,
                    price: initialPrice,
                    quantity: finalQty,
                    quantityForTrade: finalTrade,
                    isForTrade: finalTrade > 0,
                    isFoil: isFoil,
                    addedAt: serverTimestamp(),
                    scryfallData: sData ? { ...sData, id: scryfallId } : null,
                    wishlistId: null
                };

                // Nettoyage
                Object.keys(newCardData).forEach(key => 
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    (newCardData as any)[key] === undefined && delete (newCardData as any)[key]
                );

                await setDoc(newDocRef, newCardData);
                toast.success(`Version ${isFoil ? 'Foil' : 'Normal'} cr√©√©e !`);
                
                if (isFoil) setFoilState(prev => ({ ...prev, docId: newId, exists: true }));
                else setNormalState(prev => ({ ...prev, docId: newId, exists: true }));
            }

            if (onUpdate) onUpdate();

        } catch (e) {
            console.error("Erreur sauvegarde DB", e);
        }
    };

    const debouncedUpdateNormal = useDebouncedUpdate(performDatabaseUpdate, 600);
    const debouncedUpdateFoil = useDebouncedUpdate(performDatabaseUpdate, 600);

    // 3. HANDLERS
    const handleUpdate = (isFoil: boolean, type: 'qty' | 'trade', delta: number) => {
        const currentState = isFoil ? foilState : normalState;
        const setState = isFoil ? setFoilState : setNormalState;
        const debouncer = isFoil ? debouncedUpdateFoil : debouncedUpdateNormal;

        let newQty = currentState.qty;
        let newTrade = currentState.trade;

        if (type === 'qty') {
            newQty += delta;
            if (newQty < 0) return;

            if (newQty === 0 && currentState.exists) {
                if (confirm(`Retirer la version ${isFoil ? 'Foil' : 'Normal'} ?`)) {
                    setState({ ...currentState, qty: 0, trade: 0, exists: false });
                    performDatabaseUpdate(isFoil, 0, 0, currentState.docId);
                }
                return;
            }
            
            if (newTrade > newQty) newTrade = newQty;
        } 
        else if (type === 'trade') {
            newTrade += delta;
            if (newTrade < 0 || newTrade > newQty) return;
        }

        setState({ ...currentState, qty: newQty, trade: newTrade });

        if (newQty > 0) {
            debouncer(isFoil, newQty, newTrade, currentState.docId);
        }
    };

    if (loading) return <div className="p-4 text-center text-muted text-xs">Chargement...</div>;

    // --- RENDU UI ---
    const renderVariantBlock = (title: string, isFoil: boolean, state: VariantState) => {
        const isOwned = state.qty > 0;
        
        const containerClass = `rounded-xl border overflow-hidden flex flex-col h-full transition-all duration-200 
            ${isOwned 
                ? (isFoil ? 'bg-surface border-primary/30 ring-1 ring-primary/20' : 'bg-surface border-border shadow-sm') 
                : 'bg-secondary/30 border-border opacity-70 hover:opacity-100'}`;

        const headerClass = `px-4 py-3 border-b flex justify-between items-center 
            ${isOwned ? 'bg-secondary/20' : 'bg-transparent'} border-border`;

        return (
            <div className={containerClass}>
                
                <div className={headerClass}>
                    <span className={`font-bold text-sm flex items-center gap-2 ${isFoil ? 'text-primary' : 'text-foreground'}`}>
                        {isFoil && <span>‚ú®</span>}
                        {title}
                    </span>
                    {isOwned ? (
                        <span className="text-[10px] font-bold text-muted bg-background px-2 py-0.5 rounded border border-border">
                            {state.exists ? 'En stock' : 'Ajout...'}
                        </span>
                    ) : (
                        <span className="text-[10px] uppercase font-bold text-muted bg-background px-2 py-0.5 rounded border border-border">Absent</span>
                    )}
                </div>

                <div className="p-4 space-y-4 grow flex flex-col justify-center">
                    
                    {/* Collection */}
                    <div className="flex items-center justify-between">
                        <span className="text-xs font-bold text-muted uppercase tracking-wide">Collection</span>
                        <div className="flex items-center bg-background rounded-lg border border-border shadow-sm h-9">
                            <button 
                                onClick={() => handleUpdate(isFoil, 'qty', -1)} 
                                className="w-9 h-full flex items-center justify-center hover:bg-secondary text-muted hover:text-danger font-bold transition rounded-l-lg border-r border-border"
                            >
                                -
                            </button>
                            <span className="font-bold text-lg w-10 text-center tabular-nums text-foreground">{state.qty}</span>
                            <button 
                                onClick={() => handleUpdate(isFoil, 'qty', 1)} 
                                className="w-9 h-full flex items-center justify-center hover:bg-primary/10 text-primary font-bold transition rounded-r-lg border-l border-border"
                            >
                                +
                            </button>
                        </div>
                    </div>

                    {isOwned && <div className="h-px bg-border w-full"></div>}

                    {/* Echange */}
                    <div className={`flex items-center justify-between transition-opacity duration-200 ${!isOwned ? 'opacity-40 pointer-events-none' : 'opacity-100'}`}>
                        <div className="flex flex-col">
                            <span className="text-xs font-bold text-success uppercase tracking-wide">√Ä l&apos;√©change</span>
                            <span className="text-[10px] text-muted">Disponible</span>
                        </div>
                        
                        <div className="flex items-center bg-success/5 border border-success/20 rounded-lg shadow-sm h-9">
                            <button 
                                onClick={() => handleUpdate(isFoil, 'trade', -1)} 
                                disabled={state.trade <= 0}
                                className="w-9 h-full flex items-center justify-center hover:bg-success/20 text-success font-bold transition rounded-l-lg disabled:opacity-30 border-r border-success/20"
                            >
                                -
                            </button>
                            <span className={`font-bold text-lg w-10 text-center tabular-nums ${state.trade > 0 ? 'text-success' : 'text-muted'}`}>{state.trade}</span>
                            <button 
                                onClick={() => handleUpdate(isFoil, 'trade', 1)} 
                                disabled={state.trade >= state.qty}
                                className="w-9 h-full flex items-center justify-center hover:bg-success/20 text-success font-bold transition rounded-r-lg disabled:opacity-30 border-l border-success/20"
                            >
                                +
                            </button>
                        </div>
                    </div>

                </div>
            </div>
        );
    };

    return (
        <div className="space-y-4">
            <h2 className="text-lg font-bold text-foreground flex items-center gap-2 px-1">
                <svg className="w-5 h-5 text-primary" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10" />
                </svg>
                Gestion du Stock
            </h2>
            
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                {/* Condition d'affichage bas√©e sur l'existence des finitions */}
                {hasNonFoil && renderVariantBlock("Version Normale", false, normalState)}
                {hasFoil && renderVariantBlock("Version Foil", true, foilState)}
            </div>
            
            <p className="text-[11px] text-muted text-center pt-2 italic">
                Ajustez les quantit√©s pour que vos amis puissent vous proposer des deals automatiquement.
            </p>
        </div>
    );
}
</file>

<file path="components/common/CardListFilterBar.tsx">
// components/common/CardListFilterBar.tsx
'use client';

import { useMemo, useState } from 'react';
import { CardType } from '@/hooks/useCardCollection';
import { SortOption } from '@/hooks/useSortPreference';
import ColumnSlider from '@/components/ColumnSlider'; 

const MANA_COLORS = [
    { code: 'W', label: 'Blanc', bg: 'bg-yellow-100', border: 'border-yellow-300', text: 'text-yellow-700' },
    { code: 'U', label: 'Bleu', bg: 'bg-blue-100', border: 'border-blue-300', text: 'text-blue-700' },
    { code: 'B', label: 'Noir', bg: 'bg-gray-300', border: 'border-gray-500', text: 'text-gray-800' },
    { code: 'R', label: 'Rouge', bg: 'bg-red-100', border: 'border-red-300', text: 'text-red-700' },
    { code: 'G', label: 'Vert', bg: 'bg-green-100', border: 'border-green-300', text: 'text-green-700' },
    { code: 'C', label: 'Incolore', bg: 'bg-gray-100', border: 'border-gray-300', text: 'text-gray-500' },
];

interface CardMinimalInfo {
    setName?: string;
}

export type CardContext = 'collection' | 'wishlist' | 'friend-collection' | 'friend-wishlist' | 'wishlist-global' | 'search';

interface CardListFilterBarProps {
    cards: CardType[] | CardMinimalInfo[]; 
    context: CardContext;
    searchQuery: string;
    setSearchQuery: (val: string) => void;
    sortBy: SortOption;
    setSortBy: (val: SortOption) => void;
    filterSet: string;
    setFilterSet: (val: string) => void;
    filterTrade: boolean;
    setFilterTrade: (val: boolean) => void;
    filterFoil: boolean;
    setFilterFoil: (val: boolean) => void;
    minPriceFilter: string;
    setMinPriceFilter: (val: string) => void;
    maxPriceFilter: string;
    setMaxPriceFilter: (val: string) => void;
    filterCMC?: string;
    setFilterCMC?: (val: string) => void;
    filterColors?: string[];
    setFilterColors?: (val: string[]) => void;
    filterMatch?: boolean;
    setFilterMatch?: (val: boolean) => void;
    filterFullCollection?: boolean;
    setFilterFullCollection?: (val: boolean) => void;
    columns: number; 
    setColumns: (val: number) => void;
    onSearch?: () => void;
    hideSliderOnMobile?: boolean;
}

export default function CardListFilterBar({
    cards,
    context,
    searchQuery,
    setSearchQuery,
    sortBy,
    setSortBy,
    filterSet,
    setFilterSet,
    filterTrade,
    setFilterTrade,
    filterFoil,
    setFilterFoil,
    minPriceFilter,
    setMinPriceFilter,
    maxPriceFilter,
    setMaxPriceFilter,
    filterCMC,
    setFilterCMC,
    filterColors,
    setFilterColors,
    filterMatch,
    setFilterMatch,
    filterFullCollection,
    setFilterFullCollection,
    columns,
    setColumns,
    onSearch,
    hideSliderOnMobile = false
}: CardListFilterBarProps) {
    
    const [showAdvanced, setShowAdvanced] = useState(false);

    const isOwnerCollection = context === 'collection';
    const isFriendView = context.startsWith('friend');
    const isSearchPage = context === 'search';
    const isTradeFilterApplicable = context === 'collection' || context === 'friend-collection'; 
    const isMatchFilterApplicable = isFriendView && setFilterMatch !== undefined; 
    
    const availableSets: string[] = useMemo(() => {
        if (!cards) return [];
        const sets = new Set(
            cards
                .map((c: CardMinimalInfo) => c.setName)
                .filter((s): s is string => !!s)
        );
        return Array.from(sets).sort();
    }, [cards]);
    
    const sortOptions: { value: SortOption; label: string; }[] = useMemo(() => {
        const options: { value: SortOption; label: string; }[] = [
            { value: 'date_desc', label: "R√©cent ‚Üí Ancien" },
            { value: 'date_asc', label: "Ancien ‚Üí R√©cent" },
            { value: 'price_desc', label: "Prix (D√©croissant)" },
            { value: 'price_asc', label: "Prix (Croissant)" },
            { value: 'name_asc', label: "Nom (A ‚Üí Z)" },
            { value: 'name_desc', label: "Nom (Z ‚Üí A)" },
            { value: 'cmc_desc', label: "Mana (√âlev√© ‚Üí Faible)" },
            { value: 'cmc_asc', label: "Mana (Faible ‚Üí √âlev√©)" },
        ];

        if (isOwnerCollection) {
            options.push(
                { value: 'quantity_desc', label: "Quantit√© (Plus ‚Üí Moins)" },
                { value: 'quantity_asc', label: "Quantit√© (Moins ‚Üí Plus)" }
            );
        }
        return options;
    }, [isOwnerCollection]);

    const toggleColor = (code: string) => {
        if (!filterColors || !setFilterColors) return;
        if (filterColors.includes(code)) {
            setFilterColors(filterColors.filter(c => c !== code));
        } else {
            setFilterColors([...filterColors, code]);
        }
    };

    const hasActiveFilters = useMemo(() => {
        return filterSet !== 'all' || 
               minPriceFilter !== '' || 
               maxPriceFilter !== '' || 
               (filterCMC && filterCMC !== '') || 
               (filterColors && filterColors.length > 0) ||
               filterFoil ||
               filterTrade ||
               filterMatch ||
               filterFullCollection;
    }, [filterSet, minPriceFilter, maxPriceFilter, filterCMC, filterColors, filterFoil, filterTrade, filterMatch, filterFullCollection]);

    return (
        <div className="bg-surface p-3 md:p-4 rounded-xl border border-border shadow-sm flex flex-col gap-3 mb-6 w-full overflow-hidden">
            
            <div className="flex gap-2 items-center w-full">
                <div className="relative flex-1 min-w-0">
                    <input 
                        type="text" 
                        placeholder={isSearchPage ? "Rechercher sur Scryfall..." : "Filtrer..."}
                        value={searchQuery}
                        onChange={(e) => setSearchQuery(e.target.value)}
                        onKeyDown={(e) => e.key === 'Enter' && onSearch && onSearch()}
                        className="w-full p-2.5 pr-10 rounded-xl border border-border bg-background text-foreground text-sm focus:ring-2 focus:ring-primary outline-none"
                    />
                    {onSearch && (
                        <button onClick={onSearch} className="absolute right-1 top-1 bottom-1 px-3 text-muted hover:text-primary transition">
                            
                        </button>
                    )}
                </div>

                <button 
                    onClick={() => setShowAdvanced(!showAdvanced)}
                    className={`md:hidden relative p-2.5 rounded-xl border transition-all shrink-0 ${
                        showAdvanced ? 'bg-primary text-white border-primary' : 'bg-surface text-foreground border-border'
                    }`}
                >
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={2.5} stroke="currentColor" className="w-5 h-5">
                        <path strokeLinecap="round" strokeLinejoin="round" d="M10.5 6h9.75M10.5 12h9.75M10.5 18h9.75M3 6h.008v.008H3V6Zm0 6h.008v.008H3V12Zm0 6h.008v.008H3V18Z" />
                    </svg>
                    {hasActiveFilters && !showAdvanced && (
                        <span className="absolute -top-1 -right-1 w-3 h-3 bg-primary border-2 border-surface rounded-full"></span>
                    )}
                </button>
            </div>

            <div className={`${showAdvanced ? 'flex' : 'hidden md:flex'} flex-col gap-4 animate-in fade-in slide-in-from-top-2 duration-200`}>
                
                <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
                    <div className="min-w-0">
                        <label className="block text-[10px] font-bold text-muted mb-1 uppercase tracking-wider">Trier</label>
                        <select 
                            value={sortBy} 
                            onChange={(e) => setSortBy(e.target.value as SortOption)} 
                            className="w-full p-2 rounded-lg border border-border bg-background text-foreground text-sm cursor-pointer outline-none focus:ring-2 focus:ring-primary"
                        >
                            {sortOptions.map(opt => <option key={opt.value} value={opt.value}>{opt.label}</option>)}
                        </select>
                    </div>
                    
                    <div className="min-w-0">
                        <label className="block text-[10px] font-bold text-muted mb-1 uppercase tracking-wider">√âdition</label>
                        <select 
                            value={filterSet} 
                            onChange={(e) => setFilterSet(e.target.value)} 
                            className="w-full p-2 rounded-lg border border-border bg-background text-foreground text-sm cursor-pointer outline-none focus:ring-2 focus:ring-primary"
                        >
                            <option value="all">Toutes</option>
                            {availableSets.map(set => <option key={set} value={set}>{set}</option>)}
                        </select>
                    </div>
                </div>

                <div className="flex flex-col gap-4">
                    <div className="flex flex-wrap items-end gap-3">
                        <div className="flex gap-2">
                            <div className="shrink-0">
                                <label className="block text-[10px] font-bold text-muted mb-1 uppercase">Min ‚Ç¨</label>
                                <input type="number" className="w-16 p-2 rounded-lg border border-border bg-background text-sm outline-none focus:ring-2 focus:ring-primary" placeholder="0" value={minPriceFilter} onChange={e => setMinPriceFilter(e.target.value)} />
                            </div>
                            <div className="shrink-0">
                                <label className="block text-[10px] font-bold text-muted mb-1 uppercase">Max ‚Ç¨</label>
                                <input type="number" className="w-16 p-2 rounded-lg border border-border bg-background text-sm outline-none focus:ring-2 focus:ring-primary" placeholder="Max" value={maxPriceFilter} onChange={e => setMaxPriceFilter(e.target.value)} />
                            </div>
                        </div>

                        {setFilterCMC && (
                            <div className="shrink-0">
                                <label className="block text-[10px] font-bold text-muted mb-1 uppercase">CMC</label>
                                <input type="number" className="w-14 p-2 rounded-lg border border-border bg-background text-sm outline-none focus:ring-2 focus:ring-primary" placeholder="=" value={filterCMC || ''} onChange={e => setFilterCMC(e.target.value)} />
                            </div>
                        )}
                    </div>

                    {setFilterColors && (
                        <div className="w-full">
                            <label className="block text-[10px] font-bold text-muted mb-2 uppercase tracking-wider">Couleurs</label>
                            {/* Correction ici : flex-wrap pour mobile, centr√©, avec gap propre */}
                            <div className="flex flex-wrap items-center gap-2">
                                {MANA_COLORS.map(color => {
                                    const isSelected = filterColors?.includes(color.code);
                                    return (
                                        <button
                                            key={color.code}
                                            onClick={() => toggleColor(color.code)}
                                            className={`w-9 h-9 rounded-full border-2 flex items-center justify-center transition-all shrink-0 shadow-sm ${color.bg} ${color.border} ${
                                                isSelected 
                                                    ? 'ring-2 ring-primary ring-offset-2 scale-110 opacity-100 z-10' 
                                                    : 'opacity-50 hover:opacity-100'
                                            }`}
                                            title={color.label}
                                        >
                                            <span className={`text-xs font-black ${color.text}`}>{color.code}</span>
                                        </button>
                                    );
                                })}
                            </div>
                        </div>
                    )}
                </div>

                <div className="flex flex-wrap gap-y-3 gap-x-4 items-center justify-between pt-3 border-t border-border mt-1">
                    <div className="flex flex-wrap items-center gap-x-4 gap-y-2">
                        {setFilterFullCollection && (
                            <label className="flex items-center gap-2 cursor-pointer select-none">
                                <input type="checkbox" checked={filterFullCollection || false} onChange={(e) => setFilterFullCollection(e.target.checked)} className="w-4 h-4 text-primary rounded border-border focus:ring-primary accent-primary" />
                                <span className="text-[11px] font-bold text-primary">Ma collection</span>
                            </label>
                        )}
                        {isMatchFilterApplicable && setFilterMatch && (
                            <label className="flex items-center gap-2 cursor-pointer select-none">
                                <input type="checkbox" checked={filterMatch || false} onChange={(e) => setFilterMatch(e.target.checked)} className="w-4 h-4 text-success rounded border-border" />
                                <span className="text-[11px] font-medium text-foreground">Matchs</span>
                            </label>
                        )}
                        {isTradeFilterApplicable && setFilterTrade && (
                            <label className="flex items-center gap-2 cursor-pointer select-none">
                                <input type="checkbox" checked={filterTrade || false} onChange={(e) => setFilterTrade(e.target.checked)} className="w-4 h-4 text-primary rounded border-border" />
                                <span className="text-[11px] font-medium text-foreground">√âchange</span>
                            </label>
                        )}
                        {!isSearchPage && (
                            <label className="flex items-center gap-2 cursor-pointer select-none">
                                <input type="checkbox" checked={filterFoil || false} onChange={(e) => setFilterFoil(e.target.checked)} className="w-4 h-4 text-primary rounded border-border" />
                                <span className="text-[11px] font-medium text-foreground">Foil</span>
                            </label>
                        )}
                    </div>

                    <div className={hideSliderOnMobile ? "hidden md:block" : "block"}>
                        <ColumnSlider columns={columns} setColumns={setColumns} min={2} max={7} />
                    </div>
                </div>
            </div>
        </div>
    );
}
</file>

<file path="components/user-profile/FriendCollectionDisplay.tsx">
// components/user-profile/FriendCollectionDisplay.tsx
'use client';

import { useState, useMemo } from 'react';
import MagicCard from '@/components/MagicCard';
import { CardType } from '@/hooks/useCardCollection';
import { SortOption } from '@/hooks/useSortPreference';
import CardListFilterBar from '@/components/common/CardListFilterBar'; 

interface CardWithMatchStatus extends CardType {
    isMatch?: boolean;
}

interface FriendCollectionDisplayProps {
    cards: CardType[];
    loading: boolean;
    totalPrice: number; 
    targetUid: string;
    myWishlistMap: Map<string, CardType>; 
    myTradeBinderMap: Map<string, CardType>;
    columns: number;
    setColumns: (val: number) => void;
    sortBy: SortOption;
    setSortBy: (val: SortOption) => void;
}

const getMatchStatus = (card: CardType, myWishlistMap: Map<string, CardType>): boolean => {
    if (myWishlistMap.has(card.id)) return true; 
    if (!card.isSpecificVersion && myWishlistMap.has(card.name.toLowerCase())) return true;
    return false;
};

export default function FriendCollectionDisplay({
    cards, loading, targetUid, myWishlistMap, columns, setColumns, sortBy, setSortBy,
}: FriendCollectionDisplayProps) {
    
    const [searchQuery, setSearchQuery] = useState('');
    const [filterSet, setFilterSet] = useState<string>('all');
    const [filterTrade, setFilterTrade] = useState(false);
    const [filterFoil, setFilterFoil] = useState(false);
    const [filterMatch, setFilterMatch] = useState(false);
    const [minPriceFilter, setMinPriceFilter] = useState<string>('');
    const [maxPriceFilter, setMaxPriceFilter] = useState<string>('');
    const [filterCMC, setFilterCMC] = useState<string>('');
    const [filterColors, setFilterColors] = useState<string[]>([]);

    const filteredAndSortedCards = useMemo(() => {
        if (!cards) return [];
        let result: CardWithMatchStatus[] = cards.map((card) => ({
            ...card,
            isMatch: getMatchStatus(card, myWishlistMap) 
        }));
        
        const minPrice = parseFloat(minPriceFilter);
        const maxPrice = parseFloat(maxPriceFilter);

        if (searchQuery) result = result.filter(c => c.name.toLowerCase().includes(searchQuery.toLowerCase()));
        if (filterSet !== 'all') result = result.filter(c => c.setName === filterSet);
        if (filterTrade) result = result.filter(c => (c.quantityForTrade ?? 0) > 0);
        if (filterFoil) result = result.filter(c => c.isFoil);
        if (filterMatch) result = result.filter(c => c.isMatch);
        if (!isNaN(minPrice) || !isNaN(maxPrice)) {
            result = result.filter(c => {
                const p = c.customPrice ?? c.price ?? 0;
                return (isNaN(minPrice) || p >= minPrice) && (isNaN(maxPrice) || p <= maxPrice);
            });
        }
        if (filterCMC) { const t = parseFloat(filterCMC); if (!isNaN(t)) result = result.filter(c => c.cmc === t); }
        if (filterColors.length > 0) {
            result = result.filter(c => {
                if (!c.colors || c.colors.length === 0) return filterColors.includes('C');
                return c.colors.every(col => filterColors.includes(col));
            });
        }

        result.sort((a, b) => {
            const priceA = a.customPrice ?? a.price ?? 0;
            const priceB = b.customPrice ?? b.price ?? 0;
            switch (sortBy) {
                case 'name_asc': return a.name.localeCompare(b.name);
                case 'name_desc': return b.name.localeCompare(a.name);
                case 'price_asc': return priceA - priceB;
                case 'price_desc': return priceB - priceA;
                case 'quantity_asc': return a.quantity - b.quantity;
                case 'quantity_desc': return b.quantity - a.quantity;
                case 'cmc_asc': return (a.cmc ?? 0) - (b.cmc ?? 0);
                case 'cmc_desc': return (b.cmc ?? 0) - (a.cmc ?? 0);
                case 'set_asc': return (a.setName || '').localeCompare(b.setName || '');
                case 'set_desc': return (b.setName || '').localeCompare(a.setName || '');
                default: return 0;
            }
        });
        return result;
    }, [cards, searchQuery, sortBy, filterSet, filterTrade, filterFoil, filterMatch, myWishlistMap, minPriceFilter, maxPriceFilter, filterCMC, filterColors]);
    
    if (loading) return <p className="text-center p-10 text-muted font-bold uppercase text-xs animate-pulse">Chargement...</p>;
    
    return (
        <div className="space-y-6">
            <CardListFilterBar
                context="friend-collection"
                cards={cards}
                searchQuery={searchQuery} setSearchQuery={setSearchQuery}
                sortBy={sortBy} setSortBy={setSortBy}
                filterSet={filterSet} setFilterSet={setFilterSet}
                filterTrade={filterTrade} setFilterTrade={setFilterTrade}
                filterFoil={filterFoil} setFilterFoil={setFilterFoil}
                filterMatch={filterMatch} setFilterMatch={setFilterMatch}
                minPriceFilter={minPriceFilter} setMinPriceFilter={setMinPriceFilter}
                maxPriceFilter={maxPriceFilter} setMaxPriceFilter={setMaxPriceFilter}
                filterCMC={filterCMC} setFilterCMC={setFilterCMC}
                filterColors={filterColors} setFilterColors={setFilterColors}
                columns={columns} setColumns={setColumns}
                hideSliderOnMobile={true}
            />

            {filteredAndSortedCards.length === 0 ? (
                <div className="text-center py-16 bg-surface rounded-3xl border-dashed border-2 border-border shadow-inner"><p className="text-muted italic font-medium uppercase text-xs">Aucun r√©sultat.</p></div>
            ) : (
                <div 
                    className="grid gap-4 md:gap-6 animate-in fade-in grid-cols-2 md:grid-cols-[repeat(var(--cols),minmax(0,1fr))]" 
                    style={{ '--cols': columns } as React.CSSProperties}
                >
                    {filteredAndSortedCards.map((card) => (
                        <MagicCard key={card.id} {...card} readOnly={true} returnTo={`/user/${targetUid}`} matchStatus={card.isMatch ? 'my_wishlist' : undefined} />
                    ))}
                </div>
            )}
        </div>
    );
}
</file>

<file path="components/user-profile/FriendWishlistDisplay.tsx">
// components/user-profile/FriendWishlistDisplay.tsx
'use client';

import { useState, useMemo } from 'react';
import { CardType } from '@/hooks/useCardCollection';
import { WishlistMeta } from '@/hooks/useWishlists';
import { SortOption } from '@/hooks/useSortPreference'; 
import MagicCard from '@/components/MagicCard';
import { useCardCollection } from '@/hooks/useCardCollection';
import CardListFilterBar from '@/components/common/CardListFilterBar';

interface CardWithMatchStatus extends CardType {
    isMatch?: boolean;
}

interface FriendWishlistDisplayProps {
    targetUid: string;
    wishlistsMeta: WishlistMeta[];
    myTradeBinderMap: Map<string, CardType>;
    myWishlistMap: Map<string, CardType>;
    columns: number;
    setColumns: (val: number) => void;
}

const getMatchStatus = (card: CardType, myTradeBinderMap: Map<string, CardType>): boolean => {
    if (myTradeBinderMap.has(card.id)) return true; 
    if (!card.isSpecificVersion && myTradeBinderMap.has(card.name.toLowerCase())) return true;
    return false;
};

export default function FriendWishlistDisplay({
    targetUid,
    wishlistsMeta,
    myTradeBinderMap,
    columns,
    setColumns,
}: FriendWishlistDisplayProps) {
    const [selectedListId, setSelectedListId] = useState('default');
    
    // --- √âTATS DE FILTRE ET TRI ---
    const [searchQuery, setSearchQuery] = useState('');
    const [sortBy, setSortBy] = useState<SortOption>('name_asc');
    const [filterSet, setFilterSet] = useState<string>('all');
    const [filterFoil, setFilterFoil] = useState(false);
    const [filterMatch, setFilterMatch] = useState(false);
    const [minPriceFilter, setMinPriceFilter] = useState<string>('');
    const [maxPriceFilter, setMaxPriceFilter] = useState<string>('');
    // ----------------------------

    const { cards, loading, totalPrice } = useCardCollection('wishlist', selectedListId, targetUid);
    
    const currentListName = wishlistsMeta.find(l => l.id === selectedListId)?.name || 'Liste Principale';
    
    const filteredAndSortedCards = useMemo(() => {
        
        if (!cards) return [];
        
        let result: CardWithMatchStatus[] = cards.map((card: CardType) => ({
            ...card,
            isMatch: getMatchStatus(card, myTradeBinderMap) 
        }));
        
        const minPrice = parseFloat(minPriceFilter);
        const maxPrice = parseFloat(maxPriceFilter);
        
        // 1. Filtrage par recherche
        if (searchQuery) {
            const lowerQ = searchQuery.toLowerCase();
            result = result.filter((c: CardWithMatchStatus) => c.name.toLowerCase().includes(lowerQ));
        }
        
        if (filterSet !== 'all') {
            result = result.filter((c: CardWithMatchStatus) => c.setName === filterSet);
        }

        if (filterFoil) {
            result = result.filter((c: CardWithMatchStatus) => c.isFoil);
        }

        if (filterMatch) {
            result = result.filter((c: CardWithMatchStatus) => c.isMatch);
        }
        
        if (!isNaN(minPrice) || !isNaN(maxPrice)) {
            result = result.filter((c: CardWithMatchStatus) => {
                const cardPrice = c.price ?? 0;
                const isAboveMin = isNaN(minPrice) || cardPrice >= minPrice;
                const isBelowMax = isNaN(maxPrice) || cardPrice <= maxPrice;
                return isAboveMin && isBelowMax;
            });
        }

        // --- TRI MIS A JOUR ---
        result.sort((a: CardWithMatchStatus, b: CardWithMatchStatus) => {
            const priceA = a.price ?? 0;
            const priceB = b.price ?? 0;
            const cmcA = a.cmc ?? 0;
            const cmcB = b.cmc ?? 0;

            switch (sortBy) {
                case 'name_asc': return a.name.localeCompare(b.name);
                case 'name_desc': return b.name.localeCompare(a.name);
                
                case 'price_asc': return priceA - priceB;
                case 'price_desc': return priceB - priceA;
                
                case 'cmc_asc': return cmcA - cmcB;
                case 'cmc_desc': return cmcB - cmcA;

                case 'set_asc': return (a.setName || '').localeCompare(b.setName || '');
                case 'set_desc': return (b.setName || '').localeCompare(a.setName || '');

                default: return 0;
            }
        });

        return result;
    }, [cards, searchQuery, sortBy, filterSet, filterFoil, filterMatch, myTradeBinderMap, minPriceFilter, maxPriceFilter]);

    return (
        <div className="space-y-6">
            
            <div className="bg-surface p-4 rounded-xl border border-border shadow-sm flex flex-col gap-4">
                
                {/* LIGNE SELECTION + TOTAL */}
                <div className="flex flex-wrap gap-4 items-center border-b border-border/50 pb-3">
                     <div className="min-w-[200px] grow">
                        <label className="block text-xs font-bold text-muted mb-1 uppercase">Liste de Souhaits</label>
                        <select 
                            value={selectedListId} 
                            onChange={(e) => setSelectedListId(e.target.value)} 
                            className="w-full p-2.5 rounded-lg border border-border bg-background text-foreground text-sm cursor-pointer focus:ring-2 focus:ring-purple-600 outline-none"
                        >
                            {wishlistsMeta.map((list: WishlistMeta) => (
                                <option key={list.id} value={list.id}>{list.name}</option>
                            ))}
                        </select>
                    </div>
                    
                     <div className="text-right ml-auto">
                        <span className="text-xs text-muted uppercase font-semibold">Total estim√©</span>
                        <p className="text-2xl font-bold text-success">{totalPrice.toFixed(2)} ‚Ç¨</p>
                    </div>
                </div>
                
                {/* UTILISATION DU COMPOSANT R√âUTILISABLE */}
                <CardListFilterBar
                    context="friend-wishlist"
                    cards={cards}
                    searchQuery={searchQuery}
                    setSearchQuery={setSearchQuery}
                    sortBy={sortBy}
                    setSortBy={setSortBy}
                    filterSet={filterSet}
                    setFilterSet={setFilterSet}
                    filterTrade={false} // Non pertinent pour la wishlist
                    setFilterTrade={() => {}}
                    filterFoil={filterFoil}
                    setFilterFoil={setFilterFoil}
                    filterMatch={filterMatch}
                    setFilterMatch={setFilterMatch}
                    minPriceFilter={minPriceFilter}
                    setMinPriceFilter={setMinPriceFilter}
                    maxPriceFilter={maxPriceFilter}
                    setMaxPriceFilter={setMaxPriceFilter}
                    columns={columns}
                    setColumns={setColumns}
                    hideSliderOnMobile={true}
                />
            </div>

            {/* Grille des cartes */}
            {loading ? (
                <p className="text-center p-10 text-muted">Chargement de la wishlist...</p>
            ) : filteredAndSortedCards.length === 0 ? (
                 <div className="text-center py-16 bg-secondary/30 rounded-xl border-dashed border-2 border-border">
                    <p className="text-muted italic">La liste &apos;{currentListName}&apos; est vide ou ne correspond pas aux filtres.</p>
                </div>
            ) : (
                <div 
                    /* MODIFICATION ICI : grid-cols-2 par d√©faut (mobile) et md:grid-cols-[repeat(...)] pour PC */
                    className="grid gap-4 animate-in fade-in slide-in-from-bottom-4 duration-500 grid-cols-2 md:grid-cols-[repeat(var(--cols),minmax(0,1fr))]"
                    style={{ '--cols': columns } as React.CSSProperties}
                >
                    {filteredAndSortedCards.map((card: CardWithMatchStatus) => (
                        <MagicCard 
                            key={card.id} 
                            {...card} 
                            readOnly={true}
                            returnTo={`/user/${targetUid}`}
                            isWishlist={true}
                            matchStatus={card.isMatch ? 'my_trade_binder' : undefined} 
                        />
                    ))}
                </div>
            )}
        </div>
    );
}
</file>

<file path="firestore.indexes.json">
{
  "indexes": [
    {
      "collectionGroup": "trades",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "receiverUid", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" },
        { "fieldPath": "__name__", "order": "DESCENDING" }
      ],
      "density": "SPARSE_ALL"
    },
    {
      "collectionGroup": "trades",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "senderUid", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" },
        { "fieldPath": "__name__", "order": "DESCENDING" }
      ],
      "density": "SPARSE_ALL"
    },
    {
      "collectionGroup": "groups",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "members", "arrayConfig": "CONTAINS" }
      ]
    }
  ],
  "fieldOverrides": [
    {
      "collectionGroup": "public_profile",
      "fieldPath": "username",
      "ttl": false,
      "indexes": [
        { "order": "ASCENDING", "queryScope": "COLLECTION" },
        { "order": "DESCENDING", "queryScope": "COLLECTION" },
        { "arrayConfig": "CONTAINS", "queryScope": "COLLECTION" },
        { "order": "ASCENDING", "queryScope": "COLLECTION_GROUP" }
      ]
    }
  ]
}
</file>

<file path="hooks/usePremium.ts">
// hooks/usePremium.ts
import { useAuth } from '@/lib/AuthContext';
import { db } from '@/lib/firebase';
import { doc, onSnapshot } from 'firebase/firestore';
import { useState, useEffect } from 'react';

export function usePremium() {
  const { user } = useAuth();
  const [isPremium, setIsPremium] = useState(false);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    if (!user) {
        // eslint-disable-next-line react-hooks/set-state-in-effect
        setIsPremium(false);
        setLoading(false);
        return; // Stoppe l'ex√©cution si pas d'utilisateur
    }
    setLoading(true);

    // √âcoute en temps r√©el les changements sur le document utilisateur
    const unsub = onSnapshot(doc(db, 'users', user.uid), (docSnap) => {
        // Le Webhook Stripe met √† jour ce champ
        setIsPremium(docSnap.data()?.isPremium === true);
        setLoading(false);
    }, (error) => {
        // Ajout d'un gestionnaire d'erreur pour intercepter les erreurs de permission
        if (error.code === 'permission-denied') {
            console.warn("usePremium: Permission refus√©e. Arr√™t de l'√©coute.");
            setIsPremium(false);
            setLoading(false);
        } else {
             console.error("Erreur check premium", error);
             setLoading(false);
        }
    });

    return () => unsub();
  }, [user]);

  return { isPremium, loading };
}
</file>

<file path="hooks/useSortPreference.ts">
import { useState, useEffect } from 'react';

// D√©finition compl√®te et exhaustive des options de tri
export type SortOption = 
    // Options Temporelles
    | 'date_desc' 
    | 'date_asc'
    | 'date' // Legacy (gard√© pour compatibilit√© avec vos anciennes donn√©es)

    // Options Prix
    | 'price_desc' 
    | 'price_asc'

    // Options Nom
    | 'name_asc'
    | 'name_desc'
    | 'name' // Legacy

    // Options Quantit√©
    | 'quantity_desc' 
    | 'quantity_asc'
    | 'quantity' // Legacy

    // Options Mana (CMC) - NOUVEAU
    | 'cmc_desc'
    | 'cmc_asc'

    // Options √âdition (Set) - NOUVEAU (C'est ce qui vous manque)
    | 'set_asc'
    | 'set_desc';

const useSortPreference = (key: string, defaultValue: SortOption = 'date_desc') => {
    // La valeur par d√©faut doit √™tre une nouvelle valeur valide
    const [sort, setSort] = useState<SortOption>(() => {
        if (typeof window === 'undefined') {
            return defaultValue;
        }
        try {
            const storedValue = localStorage.getItem(key);
            if (storedValue) {
                // On pourrait ajouter une validation ici pour v√©rifier si c'est une option valide
                // Mais pour l'instant on fait confiance au stockage
                return storedValue as SortOption; 
            }
            return defaultValue;
        } catch (error) {
            console.error("Error reading localStorage key:", key, error);
            return defaultValue;
        }
    });

    // Mise √† jour de localStorage lorsque l'√©tat change
    useEffect(() => {
        try {
            localStorage.setItem(key, sort);
        } catch (error) {
            console.error("Error setting localStorage key:", key, error);
        }
    }, [key, sort]);

    return { sortBy: sort, setSortBy: setSort };
};

export { useSortPreference };
</file>

<file path="components/card-page/CardVersionsGrid.tsx">
// components/card-page/CardVersionsGrid.tsx
'use client';

import { useState, useEffect, useMemo } from 'react';
import { normalizeCardData, ScryfallRawData } from '@/lib/cardUtils';
import { CardType } from '@/hooks/useCardCollection';
import toast from 'react-hot-toast';
import Image from 'next/image';

type Props = {
    oracleId: string;
    currentCardId: string;
    onVersionSelect: (rawCard: ScryfallRawData) => void;
    collectionMap: Map<string, CardType>;
};

export default function CardVersionsGrid({ oracleId, currentCardId, onVersionSelect, collectionMap }: Props) {
    const [allVersions, setAllVersions] = useState<ScryfallRawData[]>([]);
    const [loading, setLoading] = useState(true);
    const [selectedRawCard, setSelectedRawCard] = useState<ScryfallRawData | null>(null);
    const [isFlipped, setIsFlipped] = useState(false);
    const [showOwnedOnly, setShowOwnedOnly] = useState(false);

    useEffect(() => {
        const fetchAllVersions = async () => {
            setLoading(true);
            try {
                const res = await fetch(`https://api.scryfall.com/cards/search?q=oracle_id:${oracleId}&unique=prints&order=released`);
                const data = await res.json();
                
                if (data.data && data.data.length > 0) {
                    setAllVersions(data.data);
                    const current = data.data.find((v: ScryfallRawData) => v.id === currentCardId);
                    if (current) setSelectedRawCard(current);
                    else setSelectedRawCard(data.data[0]); 
                } else {
                    toast.error("Aucune version trouv√©e sur Scryfall.");
                }
            } catch (e) {
                console.error("Erreur chargement versions Scryfall", e);
            } finally {
                setLoading(false);
            }
        };

        if (oracleId) {
            fetchAllVersions();
        }
    }, [oracleId, currentCardId]);

    const cardToDisplay = useMemo(() => {
        if (selectedRawCard) return normalizeCardData(selectedRawCard);
        if (allVersions.length > 0) return normalizeCardData(allVersions[0]);
        return null;
    }, [selectedRawCard, allVersions]);
    
    const filteredVersions = useMemo(() => {
        if (!showOwnedOnly) return allVersions;
        return allVersions.filter(v => collectionMap.has(v.id));
    }, [allVersions, showOwnedOnly, collectionMap]);

    if (loading) {
        return <div className="p-10 text-center text-muted animate-pulse">Chargement des √©ditions...</div>;
    }
    if (allVersions.length === 0 || !cardToDisplay) {
        return <p className="p-10 text-center text-danger">Liste des √©ditions non disponible.</p>;
    }
    
    const isDoubleSided = !!cardToDisplay.imageBackUrl;
    const displayImage = isFlipped && cardToDisplay.imageBackUrl ? cardToDisplay.imageBackUrl : cardToDisplay.imageUrl;

    return (
        <div className="flex flex-col md:grid md:grid-cols-3 gap-6 md:gap-8">
            {/* GAUCHE : IMAGE - Centr√©e sur mobile, sticky sur desktop */}
            <div className="md:col-span-1 flex flex-col items-center md:sticky md:top-24 self-start w-full">
                 <div 
                    className="w-full max-w-[280px] md:max-w-sm aspect-[2.5/3.5] rounded-xl overflow-hidden shadow-2xl ring-4 ring-primary/20 cursor-pointer relative transition-transform active:scale-95"
                    onClick={() => isDoubleSided && setIsFlipped(!isFlipped)}
                >
                    <Image 
                        src={displayImage} 
                        alt={cardToDisplay.name} 
                        fill
                        className="object-cover"
                        sizes="(max-width: 768px) 280px, 400px"
                        priority
                    />
                </div>
                {isDoubleSided && (
                    <button 
                        onClick={() => setIsFlipped(!isFlipped)} 
                        className="mt-4 text-sm text-primary hover:underline font-bold bg-primary/10 px-4 py-2 rounded-full"
                    >
                        {isFlipped ? 'Voir le Recto' : 'Voir le Verso'}
                    </button>
                )}
            </div>

            {/* DROITE : LISTE DES IMPRESSIONS */}
            <div className="md:col-span-2 space-y-4">
                <div className="flex justify-between items-center bg-secondary/50 p-3 rounded-xl border border-border">
                    <h2 className="text-lg md:text-xl font-bold text-foreground">
                        Impressions ({filteredVersions.length})
                    </h2>
                    <label className="flex items-center gap-2 cursor-pointer select-none bg-surface px-3 py-1.5 rounded-lg border border-border hover:border-primary transition">
                        <input 
                            type="checkbox" 
                            checked={showOwnedOnly} 
                            onChange={(e) => setShowOwnedOnly(e.target.checked)} 
                            className="w-4 h-4 text-primary rounded border-border focus:ring-primary accent-primary" 
                        />
                        <span className="text-xs md:text-sm font-medium text-foreground">Mes versions</span>
                    </label>
                </div>
                
                <div className="space-y-2 max-h-[50vh] md:max-h-[70vh] overflow-y-auto pr-2 custom-scrollbar">
                    {filteredVersions.map(v => {
                        const normalized = normalizeCardData(v);
                        const isCurrentInCollection = v.id === currentCardId; 
                        const ownedCard = collectionMap.get(v.id);
                        const isOwned = !!ownedCard;
                        const ownedQty = ownedCard?.quantity || 0;

                        const priceNormal = parseFloat(v.prices?.eur || "0");
                        const priceFoil = parseFloat(v.prices?.eur_foil || "0");
                        const displayPrice = priceNormal > 0 ? priceNormal : priceFoil;
                        
                        return (
                            <div 
                                key={v.id} 
                                onClick={() => { setSelectedRawCard(v); setIsFlipped(false); }} 
                                onDoubleClick={() => onVersionSelect(v)} 
                                className={`flex items-center gap-3 p-2 md:p-3 rounded-xl border cursor-pointer transition-all active:scale-[0.98] ${
                                    v.id === selectedRawCard?.id
                                        ? 'bg-primary/10 border-primary shadow-md ring-2 ring-primary/30' 
                                        : isOwned 
                                            ? 'bg-success/5 border-success/30 hover:bg-success/10' 
                                            : 'bg-surface border-border hover:border-primary/50' 
                                }`}
                            >
                                <div className="w-10 h-14 md:w-12 md:h-16 rounded overflow-hidden shrink-0 relative border border-border/50">
                                    <Image 
                                        src={normalized.imageUrl} 
                                        alt={normalized.setName} 
                                        fill
                                        className="object-cover"
                                        sizes="48px"
                                    />
                                </div>
                                <div className="grow min-w-0">
                                    <p className="font-bold text-foreground text-xs md:text-sm truncate flex items-center gap-2">
                                        {v.set_name} 
                                        {isOwned && <span className="text-[10px] bg-success text-white px-1.5 py-0.5 rounded-full font-black">{ownedQty}x</span>} 
                                    </p>
                                    <p className="text-[10px] text-muted truncate uppercase font-mono">
                                        {v.set} ‚Ä¢ #{v.collector_number}
                                    </p>
                                </div>
                                <div className="text-right shrink-0 flex flex-col items-end gap-1">
                                    <span className={`font-bold text-xs md:text-sm ${isCurrentInCollection ? 'text-primary' : 'text-foreground'}`}>
                                        {displayPrice > 0 ? `${displayPrice.toFixed(2)} ‚Ç¨` : '-- ‚Ç¨'}
                                    </span>
                                    <button 
                                        onClick={(e) => { e.stopPropagation(); onVersionSelect(v); }} 
                                        className="text-[10px] bg-primary text-primary-foreground px-2 py-1 rounded font-bold hover:opacity-80"
                                    >
                                        VOIR
                                    </button>
                                </div>
                            </div>
                        );
                    })}
                </div>

                <div className="pt-2">
                    <button 
                        onClick={() => selectedRawCard && onVersionSelect(selectedRawCard)}
                        disabled={!selectedRawCard}
                        className="btn-primary w-full py-3 text-sm md:text-base font-bold shadow-lg disabled:opacity-50 active:scale-95 transition-transform"
                    >
                        Afficher les D√©tails de cette Impression
                    </button>
                </div>
            </div>
        </div>
    );
}
</file>

<file path="components/CollectionToolsModal.tsx">
// components/CollectionToolsModal.tsx
'use client';

import { useState } from 'react';
import AdContainer from './AdContainer';

type CollectionToolsModalProps = {
  isOpen: boolean;
  onClose: () => void;
  onRefreshPrices: () => Promise<void>;
  onBulkTrade: (action: 'excess' | 'all' | 'reset', threshold?: number) => void;
  totalCards: number;
};

export default function CollectionToolsModal({ 
    isOpen, onClose, onRefreshPrices, onBulkTrade, totalCards 
}: CollectionToolsModalProps) {
  
  const [threshold, setThreshold] = useState(4);
  const [isRefreshing, setIsRefreshing] = useState(false);

  if (!isOpen) return null;

  const handleRefresh = async () => {
      setIsRefreshing(true);
      await onRefreshPrices();
      setIsRefreshing(false);
  };

  return (
    <div className="fixed inset-0 bg-black/60 flex items-center justify-center z-50 p-4 backdrop-blur-sm" onClick={onClose}>
      <div className="bg-white dark:bg-gray-800 rounded-2xl p-6 max-w-md w-full shadow-2xl border border-gray-200 dark:border-gray-700" onClick={e => e.stopPropagation()}>
        
        <div className="flex justify-between items-center mb-6">
            <h2 className="text-xl font-bold flex items-center gap-2 text-gray-900 dark:text-white">
                ‚öôÔ∏è Gestion Collection
            </h2>
            <button onClick={onClose} className="text-gray-400 hover:text-gray-600 dark:hover:text-gray-200">‚úï</button>
        </div>

        <div className="space-y-8">
            
            {/* SECTION 1 : CLASSEUR D'√âCHANGE */}
            <div>
                <h3 className="text-sm font-bold text-gray-500 uppercase mb-3 border-b border-gray-200 dark:border-gray-700 pb-1">Automatisations √âchange</h3>
                
                {/* Option Playset */}
                <div className="bg-green-50 dark:bg-green-900/10 p-3 rounded-xl border border-green-100 dark:border-green-800 mb-3">
                    <label className="text-sm font-medium text-gray-800 dark:text-gray-200 mb-2 block">
                        Mettre en √©change le surplus (Playset)
                    </label>
                    <div className="flex gap-2">
                        <div className="flex items-center bg-white dark:bg-gray-900 border border-gray-300 dark:border-gray-600 rounded-lg px-2">
                            <span className="text-xs text-gray-500 mr-2">Qt√© &gt;</span>
                            <input 
                                type="number" 
                                min="1" 
                                max="100" 
                                value={threshold} 
                                onChange={(e) => setThreshold(parseInt(e.target.value) || 4)}
                                className="w-10 text-center font-bold outline-none bg-transparent text-gray-900 dark:text-white"
                            />
                        </div>
                        <button 
                            onClick={() => onBulkTrade('excess', threshold)}
                            className="grow bg-green-600 hover:bg-green-700 text-white text-sm font-bold py-2 rounded-lg transition"
                        >
                            Appliquer
                        </button>
                    </div>
                    <p className="text-[10px] text-gray-500 mt-2">
                        Exemple : Si Qt√© &gt; 4, la carte est marqu√©e &quot;Disponible √† l&apos;√©change&quot;.
                    </p>
                </div>

                {/* Actions Rapides */}
                <div className="grid grid-cols-2 gap-3">
                    <button 
                        onClick={() => onBulkTrade('all')}
                        className="px-4 py-2 bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 text-gray-700 dark:text-gray-200 rounded-lg text-xs font-bold transition"
                    >
                        Tout mettre en Trade
                    </button>
                    <button 
                        onClick={() => onBulkTrade('reset')}
                        className="px-4 py-2 bg-gray-100 dark:bg-gray-700 hover:bg-red-100 hover:text-red-600 text-gray-700 dark:text-gray-200 rounded-lg text-xs font-bold transition"
                    >
                        Tout retirer (Reset)
                    </button>
                </div>
            </div>

            {/* SECTION 2 : ACTUALISATION */}
            <div>
                <h3 className="text-sm font-bold text-gray-500 uppercase mb-3 border-b border-gray-200 dark:border-gray-700 pb-1">Donn√©es & Prix</h3>
                
                {isRefreshing && (
                    <div className="mb-4">
                        {/* CORRECTION : On passe uniquement 'slot' qui est la prop attendue par AdContainerProps.
                            Remplacez "1234567890" par le 'data-ad-slot' fourni par Google AdSense.
                        */}
                        <AdContainer slot="1234567890" />
                        <p className="text-center text-sm text-blue-600 animate-pulse mt-2">
                            Analyse des prix en cours...
                        </p>
                    </div>
                )}
                
                <button 
                    onClick={handleRefresh}
                    disabled={isRefreshing}
                    className="w-full bg-blue-50 hover:bg-blue-100 dark:bg-blue-900/20 dark:hover:bg-blue-900/40 text-blue-700 dark:text-blue-300 border border-blue-200 dark:border-blue-800 font-bold py-3 rounded-xl transition flex items-center justify-center gap-2"
                >
                    {isRefreshing ? 'Mise √† jour en cours...' : 'üîÑ Actualiser Scryfall (Prix)'}
                </button>
                <p className="text-[10px] text-gray-400 text-center mt-2">
                    Met √† jour les prix et informations de vos {totalCards} cartes.
                </p>
            </div>

        </div>
      </div>
    </div>
  );
}
</file>

<file path="components/ThemeToggle.tsx">
// components/ThemeToggle.tsx
'use client';

import { useState, useEffect } from 'react';
import { useTheme } from 'next-themes';

export default function ThemeToggle() {
  const [mounted, setMounted] = useState(false);
  const { theme, setTheme } = useTheme();

  useEffect(() => {
    const timer = setTimeout(() => {
        setMounted(true);
    }, 0);
    return () => clearTimeout(timer);
  }, []);

  if (!mounted) {
    return <div className="w-9 h-9 p-2" />; 
  }

  return (
    <button
      onClick={() => setTheme(theme === 'dark' ? 'light' : 'dark')}
      // CORRECTION : Suppression du fond par d√©faut (bg-gray-100) pour un style plus "clair"
      className="p-2 rounded-lg text-zinc-500 hover:bg-zinc-100 dark:text-yellow-400 dark:hover:bg-zinc-800 transition-colors"
      title={theme === 'dark' ? "Passer en mode clair" : "Passer en mode sombre"}
      aria-label="Changer de th√®me"
    >
      {theme === 'dark' ? (
        // Mode Sombre (Lune affich√©e)
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-5 h-5">
          <path strokeLinecap="round" strokeLinejoin="round" d="M21.752 15.002A9.72 9.72 0 0 1 18 15.75c-5.385 0-9.75-4.365-9.75-9.75 0-1.33.266-2.597.748-3.752A9.753 9.753 0 0 0 3 11.25C3 16.635 7.365 21 12.75 21a9.753 9.753 0 0 0 9.002-5.998Z" />
        </svg>
      ) : (
        // Mode Clair (Soleil affich√©)
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-5 h-5 text-orange-500">
          <path strokeLinecap="round" strokeLinejoin="round" d="M12 3v2.25m6.364.386-1.591 1.591M21 12h-2.25m-.386 6.364-1.591-1.591M12 18.75V21m-4.773-4.227-1.591 1.591M5.25 12H3m4.227-4.773L5.636 5.636M15.75 12a3.75 3.75 0 1 1-7.5 0 3.75 3.75 0 0 1 7.5 0Z" />
        </svg>
      )}
    </button>
  );
}
</file>

<file path="components/UsernameSetupModal.tsx">
// components/UsernameSetupModal.tsx
'use client';

import { useState, useEffect } from 'react';
import { useAuth } from '@/lib/AuthContext';
import { db } from '@/lib/firebase';
import { doc, getDoc, writeBatch, serverTimestamp } from 'firebase/firestore';
import toast from 'react-hot-toast';

export default function UsernameSetupModal() {
  const { user, username, loading } = useAuth();
  const [isOpen, setIsOpen] = useState(false);
  
  const [inputVal, setInputVal] = useState('');
  const [isChecking, setIsChecking] = useState(false);

  // On ouvre la modale SI : user connect√©, chargement fini, ET pas de username
  useEffect(() => {
    if (!loading && user && !username) {
      setIsOpen(true);
    } else {
      setIsOpen(false);
    }
  }, [user, username, loading]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!user || !inputVal) return;

    // 1. Nettoyage et Validation basique
    const cleanUsername = inputVal.trim().toLowerCase().replace(/[^a-z0-9_]/g, '');

    if (cleanUsername.length < 3) {
      toast.error("Le pseudo doit faire au moins 3 caract√®res.");
      return;
    }
    
    if (cleanUsername !== inputVal.trim().toLowerCase()) {
        toast.error("Caract√®res sp√©ciaux interdits (sauf _ )");
        return;
    }

    setIsChecking(true);

    try {
      // 2. V√©rification d'unicit√© (On check la collection 'usernames')
      const usernameRef = doc(db, 'usernames', cleanUsername);
      const usernameSnap = await getDoc(usernameRef);

      if (usernameSnap.exists()) {
        toast.error(`Le pseudo "@${cleanUsername}" est d√©j√† pris.`);
        setIsChecking(false);
        return;
      }

      // 3. Cr√©ation atomique (Tout ou rien) via Batch
      const batch = writeBatch(db);

      // A. R√©server le pseudo dans la collection globale
      batch.set(usernameRef, { uid: user.uid });

      // B. Cr√©er le profil public de l'utilisateur
      const profileRef = doc(db, 'users', user.uid, 'public_profile', 'info');
      batch.set(profileRef, {
        username: cleanUsername,
        displayName: user.displayName || 'Joueur Inconnu',
        photoURL: user.photoURL || null,
        createdAt: serverTimestamp(),
        bio: "Nouveau membre MagicWish"
      });

      await batch.commit();

      toast.success(`Bienvenue, @${cleanUsername} !`);
      setIsOpen(false); 

    } catch (error) {
      console.error(error);
      toast.error("Erreur lors de la cr√©ation du profil.");
    } finally {
      setIsChecking(false);
    }
  };

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black/80 flex items-center justify-center z-100 p-4 backdrop-blur-md">
      <div className="bg-surface rounded-2xl p-8 max-w-md w-full shadow-2xl border border-border animate-in zoom-in duration-300">
        <div className="text-center mb-6">
          <div className="text-4xl mb-2 text-primary">üëã</div>
          <h2 className="text-2xl font-bold text-foreground">Bienvenue sur MagicWish !</h2>
          <p className="text-muted mt-2">
            Pour permettre √† vos amis de vous trouver, veuillez choisir un <span className="font-bold text-primary">nom d&apos;utilisateur unique</span>.
          </p>
        </div>

        <form onSubmit={handleSubmit} className="space-y-4">
          <div>
            <label className="block text-sm font-medium text-muted mb-1">
              Votre pseudo (ex: jace_beleren)
            </label>
            <div className="relative">
              <span className="absolute left-3 top-1/2 -translate-y-1/2 text-muted font-bold">@</span>
              <input
                type="text"
                value={inputVal}
                onChange={(e) => setInputVal(e.target.value.toLowerCase())}
                className="w-full pl-8 p-3 border rounded-lg bg-background text-foreground border-border focus:ring-2 focus:ring-primary outline-none lowercase"
                placeholder="pseudo_unique"
                disabled={isChecking}
                autoFocus
              />
            </div>
            <p className="text-xs text-muted mt-1">Lettres minuscules, chiffres et underscore (_) uniquement.</p>
          </div>

          <button
            type="submit"
            disabled={isChecking || inputVal.length < 3}
            className="w-full bg-primary hover:opacity-90 text-primary-foreground font-bold py-3 rounded-xl transition shadow-lg disabled:opacity-50 disabled:cursor-not-allowed"
          >
            {isChecking ? 'V√©rification...' : 'Valider mon profil'}
          </button>
        </form>
      </div>
    </div>
  );
}
</file>

<file path="hooks/useWishlists.ts">
// hooks/useWishlists.ts
'use client';

import { useState, useEffect, useCallback } from 'react';
import { useAuth } from '@/lib/AuthContext';
import { collection, onSnapshot, query, orderBy, doc, deleteDoc, updateDoc, writeBatch, getDocs } from 'firebase/firestore';
import { db } from '@/lib/firebase';
import { createListAction } from '@/app/actions/lists';
import toast from 'react-hot-toast';

export type WishlistMeta = {
  id: string;
  name: string;
  // AJOUT : Indispensable pour le tri
  createdAt?: { seconds: number; nanoseconds: number };
};

export function useWishlists() {
  const { user } = useAuth();
  const [lists, setLists] = useState<WishlistMeta[]>([]);
  const [loading, setLoading] = useState(true);

  // Utilisation de l'action serveur pour la cr√©ation
  const createList = useCallback(async (name: string) => {
    if (!user) return;
    const toastId = toast.loading("Cr√©ation...");
    try {
      const res = await createListAction(user.uid, name, 'wishlist');
      
      if (res.success) {
        toast.success(`Liste "${name}" cr√©√©e`, { id: toastId });
      } else {
        toast.error(res.error || "Erreur cr√©ation", { id: toastId });
      }
    } catch (e) {
      console.error(e);
      toast.error("Erreur technique", { id: toastId });
    }
  }, [user]);

  useEffect(() => {
    if (!user) {
      // eslint-disable-next-line react-hooks/set-state-in-effect
      setLists([]);
      setLoading(false);
      return;
    }

    const q = query(
      collection(db, 'users', user.uid, 'wishlists_meta'),
      orderBy('createdAt', 'asc')
    );

    const unsubscribe = onSnapshot(q, (snapshot) => {
      const fetchedLists = snapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data()
      })) as WishlistMeta[];
      
      // Auto-cr√©ation de la premi√®re liste si aucune n'existe
      if (fetchedLists.length === 0 && !snapshot.metadata.fromCache) {
         // On appelle l'action, pas besoin d'ID "default" forc√©, 
         // la premi√®re cr√©√©e sera la plus ancienne donc la "gratuite"
         createList("Liste principale");
      } else {
         setLists(fetchedLists);
      }
      
      setLoading(false);
    }, (error) => {
      console.error("Erreur fetch wishlists:", error);
      setLoading(false);
    });

    return () => unsubscribe();
  }, [user, createList]);

  const renameList = async (listId: string, newName: string) => {
    if (!user) return;
    try {
      await updateDoc(doc(db, 'users', user.uid, 'wishlists_meta', listId), {
        name: newName
      });
      toast.success("Renomm√© !");
    } catch (e) {
      console.error(e);
      toast.error("Erreur renommage");
    }
  };

  const deleteList = async (listId: string) => {
    if (!user) return;
    if (!confirm("Supprimer cette liste et toutes ses cartes ?")) return;
    
    const toastId = toast.loading("Suppression...");
    try {
      // 1. Supprimer les cartes
      const cardsRef = collection(db, 'users', user.uid, 'wishlists', listId, 'cards');
      const cardsSnap = await getDocs(cardsRef);
      
      const batch = writeBatch(db);
      cardsSnap.docs.forEach((doc) => {
        batch.delete(doc.ref);
      });
      await batch.commit();

      // 2. Supprimer la m√©ta
      await deleteDoc(doc(db, 'users', user.uid, 'wishlists_meta', listId));
      
      toast.success("Liste supprim√©e", { id: toastId });
    } catch (e) {
      console.error(e);
      toast.error("Erreur suppression", { id: toastId });
    }
  };

  return { lists, createList, renameList, deleteList, loading };
}
</file>

<file path="app/settings/page.tsx">
// app/settings/page.tsx
'use client';

import { useAuth } from '@/lib/AuthContext';
import { useRouter } from 'next/navigation';
import { usePremium } from '@/hooks/usePremium';
import { useState, useTransition, useEffect } from 'react';
import toast from 'react-hot-toast';
import { doc, getDoc, updateDoc, setDoc, DocumentData } from 'firebase/firestore'; 
import { db } from '@/lib/firebase';
import { updateProfile, sendPasswordResetEmail, getAuth, Auth } from 'firebase/auth'; 

// --- Typage pour la r√©ponse de l'API Portal ---
interface PortalResponse {
    url?: string;
    error?: string;
}

// Fonction utilitaire pour obtenir l'instance d'authentification
const getFirebaseAuthInstance = (): Auth => {
    return getAuth(); 
};

// --- Composant sp√©cifique pour la gestion Premium (inchang√©) ---
const PremiumSettingsCard = () => {
    const { user } = useAuth();
    const { isPremium, loading } = usePremium();
    const [isRedirecting, setIsRedirecting] = useState(false);
    const [isPending, startTransition] = useTransition();

    if (!user) return null; 
    if (loading) return <div className="p-4 text-center text-muted">Chargement...</div>;

    const paymentLink = `${process.env.NEXT_PUBLIC_STRIPE_PAYMENT_LINK}?client_reference_id=${user.uid}`;

    const handleManageSubscription = async () => {
        if (isPending) return;
        setIsRedirecting(true);
        startTransition(async () => {
            try {
                const docRef = await getDoc(doc(db, 'users', user.uid));
                const customerData = docRef.data() as DocumentData | undefined; 
                const customerId = customerData?.stripeCustomerId as string | undefined;
    
                if (!customerId) {
                    toast.error("Abonnement non trouve. Reesayez plus tard.");
                    setIsRedirecting(false);
                    return;
                }
    
                const res = await fetch('/api/portal', { 
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ customerId })
                });
                
                const data: PortalResponse = await res.json();

                if (data.url) {
                    window.location.href = data.url; 
                } else {
                    throw new Error(data.error || "Erreur redirection Stripe inconnue."); 
                }
            } catch (e) {
                console.error(e);
                toast.error("Erreur gestion d'abonnement. Verifiez la console.");
            } finally {
                setIsRedirecting(false);
            }
        });
    };

    return (
        <div className={`p-5 rounded-xl border transition-all ${isPremium ? 'bg-success/10 border-success/30' : 'bg-surface border-border'}`}>
            <h3 className="text-lg font-bold text-foreground mb-3 flex justify-between items-center">
                Statut Premium
                <span className={`text-xs font-bold px-2 py-1 rounded-full ${isPremium ? 'bg-success text-primary-foreground' : 'bg-muted/20 text-muted'}`}>
                    {isPremium ? 'ACTIF' : 'INACTIF'}
                </span>
            </h3>

            {isPremium ? (
                <>
                    <p className="text-muted text-sm mb-4">
                        Merci pour votre soutien. Vous profitez d&apos;une application sans publicite.
                    </p>
                    <button 
                        onClick={handleManageSubscription}
                        disabled={isRedirecting || isPending}
                        className="text-sm text-primary hover:underline font-medium"
                    >
                        {isRedirecting || isPending ? 'Redirection...' : 'Gerer mon abonnement Stripe'}
                    </button>
                </>
            ) : (
                <>
                    <p className="text-muted text-sm mb-4">
                        Passez Premium pour 1 EUR/mois et retirez toutes les publicites.
                    </p>
                    <a 
                        href={paymentLink} 
                        className="bg-primary hover:opacity-90 text-primary-foreground px-4 py-2 rounded-lg text-sm font-bold shadow-sm transition inline-block"
                    >
                        Activer le Premium
                    </a>
                </>
            )}
        </div>
    );
};

// --- COMPOSANT : Gestion du Profil (Pseudo) (inchang√©) ---
const ProfileSettingsCard = () => {
    const { user, logOut } = useAuth();
    const initialPseudo = user?.displayName || user?.email?.split('@')[0] || ''; 
    const [isEditing, setIsEditing] = useState(false);
    const [pseudo, setPseudo] = useState(initialPseudo);
    const [isLoading, setIsLoading] = useState(false);
    
    if (!user) return null;

    const handleSavePseudo = async () => {
        const trimmedPseudo = pseudo.trim();
        
        if (trimmedPseudo === '' || trimmedPseudo === initialPseudo) {
            setIsEditing(false);
            return;
        }

        setIsLoading(true);
        try {
            await updateProfile(user, {
                displayName: trimmedPseudo
            });

            const profileInfoRef = doc(db, 'users', user.uid, 'public_profile', 'info');
            
            await updateDoc(profileInfoRef, {
                username: trimmedPseudo,
                updatedAt: new Date(),
            });

            toast.success("Pseudo mis a jour !");
            setIsEditing(false);
        } catch (error) {
            console.error("Erreur lors de la mise a jour du pseudo:", error);
            toast.error("Echec de la mise a jour du pseudo. Reesayez.");
        } finally {
            setIsLoading(false);
        }
    };
    
    return (
        <div className="bg-surface p-5 rounded-xl shadow-sm border border-border">
            <h3 className="text-lg font-bold text-foreground mb-3">Informations de base</h3>
            
            <div className="mb-4">
                <p className="text-sm font-medium text-muted mb-1">Pseudo:</p>
                {isEditing ? (
                    <div className="flex items-center gap-2">
                        <input 
                            type="text"
                            value={pseudo}
                            onChange={(e) => setPseudo(e.target.value)}
                            className="grow p-2 border border-border rounded-lg bg-background text-foreground"
                            disabled={isLoading}
                        />
                        <button 
                            onClick={handleSavePseudo} 
                            disabled={isLoading || pseudo.trim() === ''}
                            className="bg-primary hover:opacity-90 text-primary-foreground px-3 py-2 rounded-lg text-sm font-bold transition"
                        >
                            {isLoading ? 'Sauvegarde...' : 'Enregistrer'}
                        </button>
                        <button 
                            onClick={() => { setPseudo(initialPseudo); setIsEditing(false); }}
                            disabled={isLoading}
                            className="text-sm text-muted hover:text-foreground p-2"
                        >
                            Annuler
                        </button>
                    </div>
                ) : (
                    <div className="flex items-center justify-between">
                        <span className="text-primary font-bold text-base">@{user.displayName || initialPseudo}</span>
                        <button 
                            onClick={() => setIsEditing(true)} 
                            className="text-sm text-primary hover:underline font-medium"
                        >
                            Modifier
                        </button>
                    </div>
                )}
            </div>

            <p className="text-sm mb-4"><span className="font-medium text-muted">Email:</span> {user.email}</p>
            
            <button onClick={logOut} className="text-sm text-danger hover:underline">
                Deconnexion
            </button>
        </div>
    );
};

// --- NOUVEAU COMPOSANT : V√©rification Email ---
const EmailVerificationCard = () => {
    const { user, sendVerificationEmail, reloadUser } = useAuth();
    const [isSending, setIsSending] = useState(false);
    const [isChecking, setIsChecking] = useState(false);

    // Si pas d'user ou si d√©j√† v√©rifi√©, on n'affiche rien (ou un badge succ√®s si on veut)
    if (!user) return null;
    if (user.emailVerified) return null;

    const handleSend = async () => {
        setIsSending(true);
        await sendVerificationEmail();
        setIsSending(false);
    };

    const handleCheck = async () => {
        setIsChecking(true);
        await reloadUser();
        setIsChecking(false);
    };

    return (
        <div className="bg-amber-50 dark:bg-amber-900/20 p-5 rounded-xl border border-amber-200 dark:border-amber-800">
            <h3 className="text-lg font-bold text-amber-800 dark:text-amber-400 mb-2 flex items-center gap-2">
                ‚ö†Ô∏è Email non verifie
            </h3>
            <p className="text-sm text-amber-700 dark:text-amber-300 mb-4">
                Veuillez verifier votre adresse email ({user.email}) pour securiser votre compte.
            </p>
            
            <div className="flex gap-3">
                <button 
                    onClick={handleSend}
                    disabled={isSending}
                    className="bg-amber-600 hover:bg-amber-700 text-white px-3 py-2 rounded-lg text-sm font-bold transition disabled:opacity-50"
                >
                    {isSending ? 'Envoi...' : 'Envoyer le lien'}
                </button>
                <button 
                    onClick={handleCheck}
                    disabled={isChecking}
                    className="bg-surface hover:bg-secondary text-foreground border border-border px-3 py-2 rounded-lg text-sm font-bold transition disabled:opacity-50"
                >
                    {isChecking ? '...' : 'J\'ai clique sur le lien'}
                </button>
            </div>
        </div>
    );
};

// --- COMPOSANT : S√©curit√© (Changement de MDP) (inchang√©) ---
const SecuritySettingsCard = () => {
    const { user } = useAuth(); 
    const [isLoading, setIsLoading] = useState(false); 
    
    if (!user) return null; 
    
    if (!user.email) return (
        <div className="bg-surface p-5 rounded-xl shadow-sm border border-border">
             <h3 className="text-lg font-bold text-foreground mb-3">Securite</h3>
             <p className="text-danger text-sm">
                 Votre compte n&apos;a pas d&apos;adresse email enregistree.
             </p>
        </div>
    );
    
    const handlePasswordChange = async () => {
        setIsLoading(true);
        try {
            const authInstance = getFirebaseAuthInstance();
            await sendPasswordResetEmail(authInstance, user.email!); 
            toast.success("Email envoye !");
        } catch (error) {
            console.error("Erreur lors de l'envoi de l'email:", error);
            toast.error("Erreur technique.");
        } finally {
            setIsLoading(false);
        }
    };
    
    return (
        <div className="bg-surface p-5 rounded-xl shadow-sm border border-border">
            <h3 className="text-lg font-bold text-foreground mb-3">Securite</h3>
            <p className="text-muted text-sm mb-4">
                Changer votre mot de passe par email.
            </p>
            <button 
                onClick={handlePasswordChange}
                disabled={isLoading}
                className="bg-secondary hover:bg-secondary/80 text-foreground px-4 py-2 rounded-lg text-sm font-bold shadow-sm transition inline-block"
            >
                {isLoading ? 'Envoi...' : 'Reinitialiser le mot de passe'}
            </button>
        </div>
    );
};

// --- NOUVEAU COMPOSANT : Confidentialit√© & √âchanges ---
const PrivacySettingsCard = () => {
    const { user } = useAuth();
    const [allowFull, setAllowFull] = useState(false);
    const [isLoading, setIsLoading] = useState(true);

    useEffect(() => {
        if (!user) return;
        const fetchSettings = async () => {
            try {
                const docRef = doc(db, 'users', user.uid, 'public_profile', 'info');
                const snap = await getDoc(docRef);
                if (snap.exists()) {
                    setAllowFull(snap.data().allowFullCollectionInTrade || false);
                }
            } catch (e) {
                console.error(e);
            } finally {
                setIsLoading(false);
            }
        };
        fetchSettings();
    }, [user]);

    const handleToggle = async (e: React.ChangeEvent<HTMLInputElement>) => {
        const newValue = e.target.checked;
        setAllowFull(newValue); // Optimistic update
        
        if (!user) return;
        try {
            const docRef = doc(db, 'users', user.uid, 'public_profile', 'info');
            await setDoc(docRef, { allowFullCollectionInTrade: newValue }, { merge: true });
            toast.success("Preference mise a jour");
        } catch (error) {
            console.error(error);
            toast.error("Erreur de sauvegarde");
            setAllowFull(!newValue); // Rollback
        }
    };

    if (!user) return null;

    return (
        <div className="bg-surface p-5 rounded-xl shadow-sm border border-border">
            <h3 className="text-lg font-bold text-foreground mb-3">Confidentialite & Echanges</h3>
            
            <div className="flex items-start gap-3">
                <div className="relative flex items-center pt-1">
                    <input 
                        type="checkbox"
                        id="privacy-collection"
                        checked={allowFull}
                        disabled={isLoading}
                        onChange={handleToggle}
                        className="w-5 h-5 text-primary border-border rounded focus:ring-primary cursor-pointer accent-primary"
                    />
                </div>
                <label htmlFor="privacy-collection" className="cursor-pointer">
                    <span className="block font-bold text-foreground text-sm">Partager ma collection complete</span>
                    <span className="block text-xs text-muted mt-1 leading-relaxed">
                        Par defaut, les autres utilisateurs ne voient que votre <strong>Classeur d&apos;echange</strong>.
                        <br/>
                        Cochez cette case pour autoriser vos partenaires d&apos;echange a consulter <strong>toute votre collection</strong> (lecture seule).
                    </span>
                </label>
            </div>
        </div>
    );
};

// --- COMPOSANT : Suggestions d'Am√©lioration (inchang√©) ---
const SuggestionsCard = () => {
    const { user, username } = useAuth();
    const [suggestionText, setSuggestionText] = useState('');
    const [isLoading, setIsLoading] = useState(false);
    
    if (!user) return null;

    const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();
        const trimmedSuggestion = suggestionText.trim();

        if (trimmedSuggestion.length < 10) {
            toast.error("La suggestion doit contenir au moins 10 caracteres.");
            return;
        }

        setIsLoading(true);
        try {
            const payload = {
                userId: user.uid,
                username: username || user.displayName || 'Joueur Inconnu',
                suggestion: trimmedSuggestion,
                context: 'settings-page'
            };

            const res = await fetch('/api/feedback', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (res.ok) {
                toast.success("Suggestion envoyee ! Merci pour votre idee.");
                setSuggestionText('');
            } else {
                const data = await res.json() as { error?: string };
                toast.error(data.error || "Echec de l'envoi.");
            }
        } catch (error) {
            console.error("Erreur d'envoi de feedback:", error);
            toast.error("Erreur reseau ou serveur.");
        } finally {
            setIsLoading(false);
        }
    };

    return (
        <div className="bg-surface p-5 rounded-xl shadow-sm border border-border">
            <h3 className="text-lg font-bold text-primary mb-3">
                Idees & Suggestions
            </h3>
            <p className="text-muted text-sm mb-4">
                Aidez-nous a ameliorer MagicWish. Votre feedback sera enregistre directement.
            </p>

            <form onSubmit={handleSubmit} className="space-y-4">
                <textarea
                    value={suggestionText}
                    onChange={(e) => setSuggestionText(e.target.value)}
                    rows={4}
                    placeholder="Entrez votre idee d'amelioration ici (10 caracteres minimum)..."
                    className="w-full p-3 border border-border rounded-lg bg-background text-foreground resize-none focus:ring-2 focus:ring-primary outline-none"
                    disabled={isLoading}
                />
                <button
                    type="submit"
                    disabled={isLoading || suggestionText.trim().length < 10}
                    className="w-full bg-primary hover:opacity-90 disabled:opacity-50 text-primary-foreground font-bold py-3 rounded-xl transition shadow-sm"
                >
                    {isLoading ? 'Envoi en cours...' : 'Soumettre mon idee'}
                </button>
            </form>
        </div>
    );
};


// --- Page principale des param√®tres (Mise √† jour Finale) ---
export default function SettingsPage() {
    const { user, loading: authLoading } = useAuth();
    const router = useRouter();

    useEffect(() => {
        if (!authLoading && !user) {
            router.push('/login');
        }
    }, [user, authLoading, router]);

    if (authLoading || !user) {
        return null;
    }
    
    return (
        <main className="container mx-auto p-4 max-w-4xl min-h-[80vh]">
            <h1 className="text-3xl font-bold text-foreground mb-8 border-b border-border pb-4">
                Parametres du compte
            </h1>

            <div className="grid md:grid-cols-2 gap-8">
                
                <div className="space-y-6">
                    <h2 className="text-xl font-bold text-primary mb-3">Mon Profil</h2>
                    
                    {/* Bloc V√©rification Email (S'affiche seulement si non v√©rifi√©) */}
                    <EmailVerificationCard />

                    <ProfileSettingsCard />

                    <SecuritySettingsCard />

                    <PrivacySettingsCard />
                </div>

                <div className="space-y-6">
                    <h2 className="text-xl font-bold text-primary mb-3">Abonnement & Feedback</h2>
                    
                    <PremiumSettingsCard />
                    
                    <SuggestionsCard /> 
                </div>

            </div>
        </main>
    );
}
</file>

<file path="components/AdContainer.tsx">
'use client';

import React, { useEffect } from 'react';
import { useAuth } from '@/lib/AuthContext';

/**
 * 1. D√©finition de l'objet qu'on pousse dans le tableau.
 * Record<string, unknown> remplace 'any' pour un objet g√©n√©rique.
 */
type AdSenseItem = Record<string, unknown>;

/**
 * 2. CORRECTION : On utilise 'type' au lieu d'une interface vide qui √©tend Array.
 * Cela r√©sout l'erreur "An interface declaring no members is equivalent to its supertype".
 */
type AdSenseArray = AdSenseItem[];

/**
 * 3. Extension de l'objet Window pour inclure AdSense.
 */
interface AdSenseWindow extends Window {
    adsbygoogle?: AdSenseArray;
}

/**
 * 4. Extension locale du type User pour inclure isPremium.
 * Cela permet de typer le cast proprement.
 */
interface UserWithPremium {
    isPremium?: boolean;
}

interface AdContainerProps {
    slot: string;
    format?: 'auto' | 'fluid' | 'rectangle';
    style?: React.CSSProperties;
    isLoading?: boolean;
}

export default function AdContainer({ slot, format = 'auto', style, isLoading }: AdContainerProps) {
    const { user } = useAuth();

    // On utilise un cast s√©curis√© (via unknown) vers notre type √©tendu localement
    const isPremium = (user as unknown as UserWithPremium)?.isPremium ?? false;

    useEffect(() => {
        if (!isPremium) {
            try {
                // On caste window proprement
                const adsWindow = window as unknown as AdSenseWindow;
                
                // Si le tableau n'existe pas, on le cr√©e
                if (!adsWindow.adsbygoogle) {
                    adsWindow.adsbygoogle = [];
                }

                // On pousse l'objet vide {}.
                adsWindow.adsbygoogle.push({});
            } catch (err) {
                if (err instanceof Error) {
                    console.error('AdSense error:', err.message);
                }
            }
        }
    }, [isPremium, slot]);

    if (isPremium) {
        return null;
    }

    return (
        <div 
            className={`my-4 flex flex-col items-center w-full overflow-hidden ${
                isLoading 
                ? 'p-4 bg-zinc-50 dark:bg-zinc-900 border border-zinc-200 dark:border-zinc-800 rounded-xl shadow-sm' 
                : ''
            }`}
        >
            {isLoading && (
                <p className="text-xs text-muted-foreground mb-3 italic">
                    Traitement en cours... Merci de patienter durant cette courte publicit√©.
                </p>
            )}
            <ins
                className="adsbygoogle"
                style={style || { display: 'block' }}
                data-ad-client="ca-pub-5492732016245735"
                data-ad-slot={slot}
                data-ad-format={format}
                data-full-width-responsive="true"
            />
        </div>
    );
}
</file>

<file path="components/card-page/CardMainDetails.tsx">
// components/card-page/CardMainDetails.tsx
'use client';

import { useState } from 'react';
import Link from 'next/link';
import Image from 'next/image';
import { CardType } from '@/hooks/useCardCollection';
import { normalizeCardData, ScryfallRawData } from '@/lib/cardUtils';
import { useAuth } from '@/lib/AuthContext';
import { db } from '@/lib/firebase';
import { doc, updateDoc } from 'firebase/firestore';
import toast from 'react-hot-toast';

type Props = {
    card: CardType;
    showAllVersions: boolean;
    setShowAllVersions: (val: boolean) => void;
    backLink: string;
};

// Interface locale pour typer le champ finishes
interface ScryfallWithFinishes {
    finishes?: string[];
    purchase_uris?: { cardmarket?: string };
    oracle_id?: string;
    type_line?: string;
    oracle_text?: string;
    flavor_text?: string;
    collector_number?: string;
}

export default function CardMainDetails({ 
    card, 
    showAllVersions, 
    setShowAllVersions, 
    backLink 
}: Props) {
    const { user } = useAuth();
    
    // --- ETATS LOCAUX ---
    const [isFlipped, setIsFlipped] = useState(false);
    const [isEditingPurchase, setIsEditingPurchase] = useState(false);
    const [purchaseValue, setPurchaseValue] = useState<string>(card.purchasePrice?.toString() || "");
    const [isSaving, setIsSaving] = useState(false);

    // --- PREPARATION DONNEES AFFICHAGE ---
    const rawScryData = card.scryfallData as ScryfallRawData | null;
    // Conversion s√©curis√©e pour acc√©der aux champs optionnels
    const detailedData = rawScryData as unknown as ScryfallWithFinishes | null;
    
    const displayData = rawScryData 
        ? normalizeCardData(rawScryData) 
        : {
            name: card.name,
            imageUrl: card.imageUrl,
            imageBackUrl: card.imageBackUrl,
            setName: card.setName,
            setCode: card.setCode,
            price: card.customPrice ?? card.price ?? 0,
            scryfallData: null
        };

    const displayName = displayData.name;
    const currentImage = (isFlipped && displayData.imageBackUrl) ? displayData.imageBackUrl : displayData.imageUrl;
    const isDoubleSided = !!displayData.imageBackUrl;
    
    // --- VERIFICATION DES FINITIONS ---
    const finishes = detailedData?.finishes || [];
    // Si pas d'info (carte manuelle), on suppose que tout existe par d√©faut
    const hasNonFoil = finishes.length === 0 || finishes.includes('nonfoil');
    const hasFoil = finishes.length === 0 || finishes.includes('foil') || finishes.includes('etched');

    // --- ACC√àS S√âCURIS√â AUX CHAMPS ---
    const oracleId = detailedData?.oracle_id;
    const typeLine = detailedData?.type_line;
    const oracleText = detailedData?.oracle_text;
    const flavorText = detailedData?.flavor_text;
    const collectorNumber = detailedData?.collector_number; 

    // --- CALCULS FINANCIERS ---
    const currentPrice = displayData.price;
    const purchasePrice = card.purchasePrice;
    let profitLoss = null;
    let profitLossPercent = null;
    
    if (purchasePrice !== undefined && purchasePrice > 0 && currentPrice > 0) {
        profitLoss = currentPrice - purchasePrice;
        profitLossPercent = (profitLoss / purchasePrice) * 100;
    }

    // --- LOGIQUE SAUVEGARDE PRIX ---
    const handleSavePurchasePrice = async () => {
        if (!user) return;
        const val = parseFloat(purchaseValue);
        const finalVal = isNaN(val) ? 0 : val;

        setIsSaving(true);
        try {
            await updateDoc(doc(db, 'users', user.uid, 'collection', card.id), { 
                purchasePrice: finalVal > 0 ? finalVal : 0 
            });
            toast.success("Historique mis √† jour !");
            setIsEditingPurchase(false);
        } catch (error) {
            console.error(error);
            toast.error("Erreur sauvegarde.");
        } finally {
            setIsSaving(false);
        }
    };

    // --- LIENS CARDMARKET ---
    const baseCardmarketUrl = detailedData?.purchase_uris?.cardmarket 
        || `https://www.cardmarket.com/en/Magic/Products/Search?searchString=${encodeURIComponent(displayName)}`;

    const getPreciseUrl = (isFoilVersion: boolean) => {
        const separator = baseCardmarketUrl.includes('?') ? '&' : '?';
        return `${baseCardmarketUrl}${separator}isFoil=${isFoilVersion ? 'Y' : 'N'}`;
    };

    return (
        <div className="flex flex-col lg:flex-row gap-8 animate-in fade-in slide-in-from-bottom-4 duration-500">
            
            {/* --- COLONNE GAUCHE : VISUEL --- */}
            <div className="w-full lg:w-1/3 xl:w-1/4 flex flex-col gap-4">
                <div className="relative aspect-[2.5/3.5] w-full max-w-sm mx-auto bg-secondary rounded-xl shadow-2xl overflow-hidden group">
                    <Image
                        src={currentImage}
                        alt={displayName}
                        fill
                        priority
                        className="object-cover transition-transform duration-700 group-hover:scale-105"
                        sizes="(max-width: 768px) 100vw, 300px"
                    />
                    
                    {card.isFoil && (
                        <div className="absolute top-4 right-4 bg-amber-500/90 text-white px-3 py-1 rounded-full text-xs font-bold shadow-lg backdrop-blur-sm border border-amber-400/50 z-10">
                            FOIL
                        </div>
                    )}

                    {isDoubleSided && (
                        <button
                            type="button"
                            onClick={() => setIsFlipped(!isFlipped)}
                            className="absolute bottom-4 right-4 bg-black/60 text-white p-3 rounded-full hover:bg-black/80 transition backdrop-blur-md border border-white/10 z-20"
                            title="Retourner la carte"
                        >
                            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={2} stroke="currentColor" className="w-6 h-6">
                                <path strokeLinecap="round" strokeLinejoin="round" d="M16.023 9.348h4.992v-.001M2.985 19.644v-4.992m0 0h4.992m-4.993 0 3.181 3.183a8.25 8.25 0 0 0 13.803-3.7M4.031 9.865a8.25 8.25 0 0 1 13.803-3.7l3.181 3.182m0-4.991v4.99" />
                            </svg>
                        </button>
                    )}
                </div>
            </div>

            {/* --- COLONNE DROITE : DETAILS & GESTION --- */}
            <div className="flex-1 space-y-6">
                
                {/* 1. EN-T√äTE */}
                <div>
                    <div className="flex justify-between items-start mb-2">
                        <h2 className="text-3xl md:text-4xl font-black text-foreground leading-tight">{displayName}</h2>
                        <div className="flex flex-col items-end gap-2 shrink-0">
                            <Link href={backLink} className="text-sm font-medium text-muted hover:text-primary transition flex items-center gap-1">
                                ‚Üê Retour
                            </Link>
                            {oracleId && (
                                <button 
                                    type="button"
                                    onClick={() => setShowAllVersions(!showAllVersions)}
                                    className="text-primary hover:text-primary/80 font-semibold text-sm underline-offset-4 hover:underline transition-colors"
                                >
                                    {showAllVersions ? 'Masquer versions' : 'Autres versions'}
                                </button>
                            )}
                        </div>
                    </div>
                    <div className="flex items-center gap-3 text-lg text-muted-foreground">
                        <span className="bg-secondary dark:bg-gray-800 px-2 py-1 rounded text-sm font-mono border border-border uppercase">
                            {displayData.setCode}
                        </span>
                        <span>{displayData.setName}</span>
                        {collectorNumber && <span className="text-sm opacity-60">#{collectorNumber}</span>}
                    </div>
                </div>

                {/* 2. BLOC FINANCIER (PRIX & ACHAT) */}
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                    {/* Bloc Prix Actuel */}
                    <div className="bg-surface dark:bg-gray-800 p-5 rounded-xl border border-border dark:border-gray-700 shadow-sm flex flex-col justify-between">
                        <p className="text-xs font-bold text-muted uppercase tracking-wider mb-2">Valeur March√©</p>
                        <div className="flex items-baseline gap-2 mb-2">
                            <span className="text-3xl font-bold text-success">{currentPrice.toFixed(2)} ‚Ç¨</span>
                            {card.isFoil && <span className="text-[10px] font-bold text-amber-700 dark:text-amber-400 bg-amber-50 dark:bg-amber-900/30 px-1.5 py-0.5 rounded border border-amber-100 dark:border-amber-800">FOIL</span>}
                        </div>
                        
                        {/* LIENS CARDMARKET CONDITIONNELS */}
                        <div className="flex gap-2 mt-auto pt-2">
                            {hasNonFoil && (
                                <a href={getPreciseUrl(false)} target="_blank" rel="noreferrer" className="text-xs text-blue-600 dark:text-blue-400 hover:underline flex items-center gap-1">
                                    Acheter Normal ‚Üó
                                </a>
                            )}
                            
                            {hasNonFoil && hasFoil && (
                                <div className="w-px bg-border dark:bg-gray-700 h-4"></div>
                            )}
                            
                            {hasFoil && (
                                <a href={getPreciseUrl(true)} target="_blank" rel="noreferrer" className="text-xs text-amber-600 dark:text-amber-400 hover:underline flex items-center gap-1">
                                    Acheter Foil ‚Üó
                                </a>
                            )}
                        </div>
                    </div>

                    {/* Bloc Historique Achat */}
                    <div className="bg-surface dark:bg-gray-800 p-5 rounded-xl border border-border dark:border-gray-700 shadow-sm">
                        <div className="flex justify-between items-start mb-2">
                            <p className="text-xs font-bold text-muted uppercase tracking-wider">Mon Achat</p>
                            {!isEditingPurchase && (
                                <button onClick={() => setIsEditingPurchase(true)} className="text-xs font-bold text-primary hover:underline">
                                    {purchasePrice ? "Modifier" : "D√©finir"}
                                </button>
                            )}
                        </div>

                        {isEditingPurchase ? (
                            <div className="flex items-center gap-2 mt-1">
                                <input 
                                    type="number" step="0.01" placeholder="0.00" autoFocus
                                    value={purchaseValue} onChange={(e) => setPurchaseValue(e.target.value)}
                                    className="w-24 p-1.5 rounded border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-900 text-gray-900 dark:text-white font-bold text-sm focus:ring-2 focus:ring-primary outline-none"
                                />
                                <button onClick={handleSavePurchasePrice} disabled={isSaving} className="bg-primary text-white px-3 py-1.5 rounded text-xs font-bold hover:bg-primary/90">OK</button>
                                <button onClick={() => setIsEditingPurchase(false)} className="text-muted text-xs hover:text-foreground">X</button>
                            </div>
                        ) : (
                            <div>
                                {purchasePrice ? (
                                    <>
                                        <p className="text-xl font-bold text-foreground mb-1">{purchasePrice.toFixed(2)} ‚Ç¨</p>
                                        {profitLoss !== null && (
                                            <p className={`text-xs font-bold ${profitLoss >= 0 ? 'text-success' : 'text-danger'}`}>
                                                {profitLoss >= 0 ? '+' : ''}{profitLoss.toFixed(2)} ‚Ç¨ ({profitLoss >= 0 ? '+' : ''}{profitLossPercent?.toFixed(0)}%)
                                            </p>
                                        )}
                                    </>
                                ) : (
                                    <p className="text-sm text-muted italic mt-1">Non renseign√©</p>
                                )}
                            </div>
                        )}
                    </div>
                </div>

                {/* 3. DETAILS TECHNIQUES (Oracle) */}
                {rawScryData && (
                    <div className="space-y-4 text-foreground/90 pt-2">
                        {typeLine && (
                            <div className="border-l-4 border-primary/50 pl-4 py-1">
                                <p className="font-bold text-lg text-foreground">{typeLine}</p>
                            </div>
                        )}
                        {oracleText && (
                            <div className="bg-secondary/30 dark:bg-gray-800/50 p-4 rounded-lg border border-border dark:border-gray-700 font-serif text-sm leading-relaxed whitespace-pre-line text-foreground/90">
                                {oracleText}
                            </div>
                        )}
                        {flavorText && (
                            <p className="text-sm italic text-muted-foreground border-l-2 border-border dark:border-gray-700 pl-4">
                                {flavorText}
                            </p>
                        )}
                    </div>
                )}
            </div>
        </div>
    );
}
</file>

<file path="lib/cardUtils.ts">
// lib/cardUtils.ts

export type ScryfallRawData = {
  id: string;
  name: string;
  set: string;
  set_name: string;
  collector_number: string;
  released_at?: string;
  image_uris?: {
    small?: string;
    normal?: string;
    large?: string;
    png?: string;
  };
  card_faces?: Array<{
    name: string;
    image_uris?: {
      normal?: string;
    };
    colors?: string[]; 
  }>;
  prices?: {
    eur?: string;
    eur_foil?: string;
    usd?: string;
  };
  finishes?: string[];
  cmc?: number;
  colors?: string[]; 
  color_identity?: string[]; // <-- LE CHAMP IMPORTANT
  [key: string]: unknown;
};

export const normalizeCardData = (data: ScryfallRawData) => {
  const rawName = data.name;
  const name = rawName.split(' // ')[0]; 

  let imageUrl = "";
  let imageBackUrl: string | null = null;

  if (data.image_uris?.normal) {
    imageUrl = data.image_uris.normal;
  } 
  else if (data.card_faces && data.card_faces.length > 0) {
    if (data.card_faces[0].image_uris?.normal) {
      imageUrl = data.card_faces[0].image_uris.normal;
    }
    if (data.card_faces[1] && data.card_faces[1].image_uris?.normal) {
      imageBackUrl = data.card_faces[1].image_uris.normal;
    }
  }

  if (!imageUrl) {
    imageUrl = "https://cards.scryfall.io/large/front/a/6/a6984342-f723-4e80-8e69-902d287a915f.jpg";
  }

  // --- CORRECTION : PRIORIT√â √Ä L'IDENTIT√â COULEUR ---
  let finalColors = data.color_identity || [];
  
  if ((!finalColors || finalColors.length === 0) && data.colors) {
      finalColors = data.colors;
  }
  
  if ((!finalColors || finalColors.length === 0) && data.card_faces) {
      const combined = new Set<string>();
      data.card_faces.forEach(face => {
          face.colors?.forEach(c => combined.add(c));
      });
      finalColors = Array.from(combined);
  }

  return {
    id: data.id,
    scryfallId: data.id,
    name,
    imageUrl,
    imageBackUrl, 
    setName: data.set_name,
    setCode: data.set,
    price: parseFloat(data.prices?.eur || "0"),
    scryfallData: data,
    
    cmc: data.cmc !== undefined ? data.cmc : 0,
    colors: finalColors 
  };
};
</file>

<file path="app/groups/page.tsx">
'use client';

import { useState, useEffect } from 'react';
import { useAuth } from '@/lib/AuthContext'; // Ajust√© selon votre repomix
import { db } from '@/lib/firebase';
import { collection, query, where, onSnapshot, doc, getDoc } from 'firebase/firestore';
import { createGroupAction, addMemberAction, promoteMemberAction, removeMemberAction } from '@/app/actions/groups';
import toast from 'react-hot-toast';
import { FriendProfile, useFriends } from '@/hooks/useFriends'; 
import Image from 'next/image';
import Link from 'next/link';
import { Shield, X, Users, ArrowRight, MessageSquare } from 'lucide-react'; // Ajout MessageSquare
import { getOrCreateDirectChat } from '@/app/actions/chat'; // Import Action Chat
import ChatWindow from '@/components/chat/ChatWindow'; // Import Composant Chat

type Group = {
    id: string;
    name: string;
    members: string[];
    admins: string[];
    ownerUid: string;
};

export default function GroupsPage() {
    const { user } = useAuth();
    const { friends } = useFriends(); 
    
    const [groups, setGroups] = useState<Group[]>([]);
    const [loading, setLoading] = useState(true);
    
    const [newGroupName, setNewGroupName] = useState('');
    const [isSubmitting, setIsSubmitting] = useState(false);

    const [selectedGroup, setSelectedGroup] = useState<Group | null>(null);
    const [groupMembersData, setGroupMembersData] = useState<FriendProfile[]>([]);
    
    const [isInviteOpen, setIsInviteOpen] = useState(false);

    // √âTAT : Chat actif pour l'int√©gration
    const [activeChat, setActiveChat] = useState<{ chatId: string; recipientName: string } | null>(null);

    // √âcoute des groupes auxquels l'utilisateur appartient
    useEffect(() => {
        if (!user) return;
        const q = query(collection(db, 'groups'), where('members', 'array-contains', user.uid));
        const unsub = onSnapshot(q, (snap) => {
            const list = snap.docs.map(d => ({ id: d.id, ...d.data() } as Group));
            setGroups(list);
            
            if (selectedGroup) {
                const updated = list.find(g => g.id === selectedGroup.id);
                if (updated) setSelectedGroup(updated);
            }
            setLoading(false);
        });
        return () => unsub();
    }, [user, selectedGroup]);

    // Chargement des profils d√©taill√©s des membres du groupe
    useEffect(() => {
        const fetchMembers = async () => {
            if (!selectedGroup) return;
            const profiles: FriendProfile[] = [];
            for (const uid of selectedGroup.members) {
                try {
                    const friend = friends.find(f => f.uid === uid);
                    if (friend) {
                        profiles.push(friend);
                    } else {
                        const snap = await getDoc(doc(db, 'users', uid, 'public_profile', 'info'));
                        if (snap.exists()) {
                            const data = snap.data();
                            profiles.push({ 
                                uid, 
                                username: typeof data.username === 'string' ? data.username : '?', 
                                displayName: typeof data.displayName === 'string' ? data.displayName : 'Joueur', 
                                photoURL: typeof data.photoURL === 'string' ? data.photoURL : undefined
                            });
                        }
                    }
                } catch (e) { console.error(e); }
            }
            setGroupMembersData(profiles);
        };
        fetchMembers();
    }, [selectedGroup, friends]);

    const handleOpenChat = async (targetUid: string, targetName: string) => {
        if (!user) return toast.error("Connectez-vous pour discuter");
        if (user.uid === targetUid) return;

        try {
            const res = await getOrCreateDirectChat(user.uid, targetUid);
            if (res.success && res.chatId) {
                setActiveChat({ chatId: res.chatId, recipientName: targetName });
            }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        } catch (error) {
            toast.error("Erreur lors de l'ouverture du chat");
        }
    };

    const handleCreate = async () => {
        if (!user || !newGroupName.trim()) return;
        setIsSubmitting(true);
        const res = await createGroupAction(user.uid, newGroupName);
        if (res.success) {
            toast.success("Playgroup cr√©√© !");
            setNewGroupName('');
        } else {
            toast.error("Erreur cr√©ation");
        }
        setIsSubmitting(false);
    };

    const handleInvite = async (friendUid: string) => {
        if (!user || !selectedGroup) return;
        const res = await addMemberAction(user.uid, selectedGroup.id, friendUid);
        if (res.success) {
            toast.success("Membre ajout√© !");
            setIsInviteOpen(false);
        } else {
            toast.error(res.error || "Erreur");
        }
    };

    const handlePromote = async (targetUid: string) => {
        if (!user || !selectedGroup) return;
        if (!confirm("Donner les droits Admin √† ce membre ?")) return;
        const res = await promoteMemberAction(user.uid, selectedGroup.id, targetUid);
        if (res.success) toast.success("Membre promu Admin");
        else toast.error("Erreur promotion");
    };

    const handleKickOrLeave = async (targetUid: string) => {
        if (!user || !selectedGroup) return;
        const isSelf = targetUid === user.uid;
        if (!confirm(isSelf ? "Quitter ce playgroup ?" : "Exclure ce membre ?")) return;
        const res = await removeMemberAction(user.uid, selectedGroup.id, targetUid);
        if (res.success) {
            toast.success(isSelf ? "Vous avez quitt√© le playgroup" : "Membre exclu");
            if (isSelf) setSelectedGroup(null);
        } else {
            toast.error(res.error || "Erreur");
        }
    };

    if (!user) return <div className="p-10 text-center text-muted">Veuillez vous connecter.</div>;
    const isAdmin = selectedGroup?.admins.includes(user.uid);

    return (
        <main className="container mx-auto p-4 max-w-5xl min-h-[85vh] flex flex-col md:flex-row gap-8 pb-32">
            
            {/* GAUCHE : LISTE & CR√âATION */}
            <div className="w-full md:w-1/3 space-y-6">
                <h1 className="text-3xl font-black text-foreground uppercase tracking-tighter">Playgroups</h1>

                {/* Bloc Chat Actif si ouvert */}
                {activeChat && (
                    <div className="animate-in slide-in-from-top-2 duration-300">
                        <div className="flex justify-end mb-2">
                            <button onClick={() => setActiveChat(null)} className="text-[9px] font-black uppercase text-muted hover:text-danger flex items-center gap-1">
                                <X className="w-3 h-3" /> Fermer le chat
                            </button>
                        </div>
                        <ChatWindow chatId={activeChat.chatId} recipientName={activeChat.recipientName} />
                    </div>
                )}

                <div className="bg-surface p-5 rounded-2xl border border-border shadow-sm">
                    <h3 className="text-[10px] font-black text-muted uppercase tracking-widest mb-4">Nouveau Groupe</h3>
                    <div className="flex gap-2">
                        <input 
                            type="text" 
                            placeholder="Nom du groupe..." 
                            className="w-full p-3 bg-background border border-border rounded-xl text-sm font-bold text-foreground outline-none focus:ring-2 focus:ring-primary"
                            value={newGroupName}
                            onChange={e => setNewGroupName(e.target.value)}
                        />
                        <button onClick={handleCreate} disabled={isSubmitting} className="bg-primary text-white px-4 rounded-xl font-black text-lg transition active:scale-95">+</button>
                    </div>
                </div>

                <div className="grid gap-2">
                    {loading ? (
                        <p className="text-muted text-xs font-bold uppercase animate-pulse">Chargement...</p>
                    ) : groups.map(group => (
                        <div 
                            key={group.id}
                            onClick={() => setSelectedGroup(group)}
                            className={`p-4 rounded-2xl border cursor-pointer transition-all flex justify-between items-center ${
                                selectedGroup?.id === group.id 
                                ? 'bg-primary/10 border-primary ring-1 ring-primary/20' 
                                : 'bg-surface border-border hover:border-primary/40'
                            }`}
                        >
                            <div className="min-w-0">
                                <p className="font-black text-sm text-foreground truncate uppercase tracking-tight">{group.name}</p>
                                <p className="text-[10px] text-muted font-bold uppercase">
                                    {group.members.length} membre(s) 
                                    {group.admins.includes(user.uid) && <span className="ml-2 text-primary">‚Ä¢ Admin</span>}
                                </p>
                            </div>
                            <ArrowRight className={`w-4 h-4 text-primary transition-transform ${selectedGroup?.id === group.id ? 'translate-x-1' : ''}`} />
                        </div>
                    ))}
                    {!loading && groups.length === 0 && (
                        <p className="text-[10px] text-muted font-black uppercase text-center py-8 bg-background rounded-2xl border border-dashed border-border tracking-widest">Aucun playgroup.</p>
                    )}
                </div>
            </div>

            {/* DROITE : D√âTAILS */}
            <div className="w-full md:w-2/3 bg-surface border border-border rounded-3xl p-5 md:p-8 shadow-sm min-h-[500px] flex flex-col overflow-hidden">
                {selectedGroup ? (
                    <div className="animate-in fade-in slide-in-from-right-4 duration-300 grow flex flex-col">
                        
                        <div className="flex flex-col sm:flex-row justify-between items-start gap-4 mb-8 border-b border-border pb-6">
                            <div>
                                <h2 className="text-3xl font-black text-foreground uppercase tracking-tighter leading-none mb-2">{selectedGroup.name}</h2>
                                <p className="text-xs font-bold text-muted uppercase tracking-widest">{selectedGroup.members.length} joueurs actifs</p>
                            </div>
                            <div className="flex gap-2 w-full sm:w-auto">
                                {isAdmin && (
                                    <button onClick={() => setIsInviteOpen(true)} className="flex-1 sm:flex-none bg-primary text-white px-4 py-2.5 rounded-xl font-black uppercase text-[10px] tracking-widest shadow-sm">Inviter</button>
                                )}
                                <button onClick={() => handleKickOrLeave(user.uid)} className="flex-1 sm:flex-none text-[10px] font-black uppercase tracking-widest text-danger border border-danger/20 bg-danger/5 px-4 py-2.5 rounded-xl hover:bg-danger/10">Quitter</button>
                            </div>
                        </div>

                        <h3 className="text-[10px] font-black text-muted uppercase tracking-[0.2em] mb-4">Membres du groupe</h3>
                        
                        <div className="grid gap-3 overflow-y-auto custom-scrollbar pr-1">
                            {groupMembersData.map(member => {
                                const isMemberAdmin = selectedGroup.admins.includes(member.uid);
                                return (
                                    <div key={member.uid} className="flex flex-col p-4 bg-background rounded-2xl border border-border hover:border-primary/20 transition-all gap-4">
                                        
                                        <div className="flex items-center justify-between">
                                            <div className="flex items-center gap-3 min-w-0">
                                                <div className="w-10 h-10 rounded-full bg-secondary border border-border shrink-0 overflow-hidden relative shadow-sm">
                                                    {member.photoURL && <Image src={member.photoURL} alt="" fill className="object-cover" sizes="40px" />}
                                                </div>
                                                <div className="min-w-0">
                                                    <p className="font-black text-sm text-foreground truncate tracking-tight">{member.displayName}</p>
                                                    <p className="text-[10px] text-primary font-black uppercase tracking-tighter">@{member.username}</p>
                                                </div>
                                            </div>
                                            <div className="flex items-center gap-2">
                                                {/* Bouton Chat ajout√© par membre */}
                                                {member.uid !== user.uid && (
                                                    <button 
                                                        onClick={() => handleOpenChat(member.uid, member.displayName)}
                                                        className="w-8 h-8 flex items-center justify-center text-primary hover:bg-primary/10 rounded-full transition-colors"
                                                        title="Envoyer un message"
                                                    >
                                                        <MessageSquare className="w-4 h-4" />
                                                    </button>
                                                )}
                                                {isMemberAdmin && <span className="text-[8px] bg-primary/20 text-primary px-2 py-1 rounded-lg font-black uppercase tracking-widest">Admin</span>}
                                            </div>
                                        </div>

                                        <div className="flex items-center gap-2">
                                            <Link href={`/user/${member.uid}`} className="flex-1 text-center text-[10px] bg-secondary text-foreground py-2 rounded-xl font-black uppercase tracking-tighter border border-border/50">Voir</Link>
                                            <Link href={`/trades/new/${member.uid}`} className="flex-1 text-center text-[10px] bg-primary/10 text-primary py-2 rounded-xl font-black uppercase tracking-tighter border border-primary/20">√âchanger</Link>
                                            
                                            {isAdmin && member.uid !== user.uid && (
                                                <div className="flex gap-1 shrink-0">
                                                    {!isMemberAdmin && (
                                                        <button onClick={() => handlePromote(member.uid)} className="p-2 text-muted hover:text-primary transition-colors" title="Promouvoir"><Shield className="w-4 h-4" /></button>
                                                    )}
                                                    <button onClick={() => handleKickOrLeave(member.uid)} className="p-2 text-muted hover:text-danger transition-colors" title="Exclure"><X className="w-4 h-4" /></button>
                                                </div>
                                            )}
                                        </div>
                                    </div>
                                );
                            })}
                        </div>
                    </div>
                ) : (
                    <div className="h-full flex flex-col items-center justify-center text-center p-8">
                        <Users className="w-12 h-12 text-muted/20 mb-4" />
                        <p className="text-[10px] font-black text-muted uppercase tracking-widest">S√©lectionnez un groupe pour voir les membres</p>
                    </div>
                )}
            </div>

            {/* MODALE INVITATION */}
            {isInviteOpen && (
                <div className="fixed inset-0 bg-black/80 flex items-center justify-center z-50 p-4 backdrop-blur-md" onClick={() => setIsInviteOpen(false)}>
                    <div className="bg-surface p-6 rounded-3xl max-w-sm w-full shadow-2xl border border-border animate-in zoom-in duration-200" onClick={e => e.stopPropagation()}>
                        <h3 className="font-black text-lg text-foreground uppercase tracking-tighter mb-4">Inviter un ami</h3>
                        <div className="space-y-2 max-h-64 overflow-y-auto custom-scrollbar pr-1">
                            {friends.filter(f => !selectedGroup?.members.includes(f.uid)).map(friend => (
                                <div key={friend.uid} className="flex justify-between items-center p-3 bg-background rounded-xl border border-border">
                                    <span className="text-xs font-bold text-foreground truncate mr-2">@{friend.username}</span>
                                    <button onClick={() => handleInvite(friend.uid)} className="text-[10px] bg-primary text-white px-4 py-2 rounded-lg font-black uppercase tracking-widest shrink-0">Ajouter</button>
                                </div>
                            ))}
                        </div>
                        <button onClick={() => setIsInviteOpen(false)} className="mt-4 w-full text-[10px] font-black text-muted uppercase tracking-widest py-2">Fermer</button>
                    </div>
                </div>
            )}
        </main>
    );
}
</file>

<file path="app/trades/history/page.tsx">
'use client';

import { useState, useEffect, useMemo } from 'react';
import { useAuth } from '@/lib/AuthContext';
import { db } from '@/lib/firebase';
import { collection, query, where, orderBy, onSnapshot, Timestamp } from 'firebase/firestore';
import { TradeRequest } from '@/hooks/useTradeSystem';
import Link from 'next/link';
import { CardType } from '@/hooks/useCardCollection';
import { ScryfallRawData } from '@/lib/cardUtils';
import MagicCard from '@/components/MagicCard';

// --- UTILITAIRES ---

const formatDate = (timestamp: Timestamp) => {
    if (!timestamp) return '';
    return new Date(timestamp.seconds * 1000).toLocaleDateString('fr-FR', {
        day: 'numeric', month: 'short', year: '2-digit', hour: '2-digit', minute: '2-digit'
    });
};

const aggregateCards = (cards: CardType[]) => {
    const map = new Map<string, CardType>();
    cards.forEach(card => {
        const key = `${card.name}-${card.setCode}-${card.isFoil ? 'foil' : 'normal'}-${card.customPrice}`;
        if (map.has(key)) {
            const existing = map.get(key)!;
            existing.quantity += card.quantity;
        } else {
            map.set(key, { ...card });
        }
    });
    return Array.from(map.values()).sort((a, b) => b.quantity - a.quantity);
};

// --- COMPOSANT TABLEAU OPTIMIS√â AVEC LOGIQUE DE PRIX DYNAMIQUE ---
const CompactCardTable = ({ 
    cards, 
    title, 
    colorClass, 
    emptyLabel,
    onPreview 
}: { 
    cards: CardType[], 
    title: string, 
    colorClass: string, 
    emptyLabel: string,
    onPreview: (c: CardType) => void
}) => {
    const isGiven = colorClass.includes('danger');
    const accentBorder = isGiven ? 'border-danger/30' : 'border-success/30';
    const accentBg = isGiven ? 'bg-danger/5' : 'bg-success/5';

    return (
        <div className={`flex flex-col h-full bg-surface border rounded-xl overflow-hidden shadow-sm ${accentBorder}`}>
            <div className={`p-3 border-b border-border ${colorClass} bg-current/10 flex justify-between items-center`}>
                <h4 className="text-[10px] font-bold uppercase tracking-widest text-foreground">{title}</h4>
                <span className="bg-surface text-foreground px-2 py-0.5 rounded text-[10px] font-black shadow-sm border border-border">
                    {cards.reduce((acc, c) => acc + c.quantity, 0)}
                </span>
            </div>
            
            <div className="grow relative bg-background/30 flex flex-col min-h-0 overflow-hidden">
                {cards.length === 0 ? (
                    <div className="flex items-center justify-center text-muted text-[10px] italic p-6 text-center grow">
                        {emptyLabel}
                    </div>
                ) : (
                    <div className="overflow-y-auto custom-scrollbar grow">
                        <table className="hidden sm:table w-full text-left border-collapse table-fixed">
                            <thead className="bg-secondary/80 text-muted sticky top-0 z-10 font-bold text-[9px] uppercase tracking-tighter">
                                <tr>
                                    <th className="px-2 py-2 text-center w-10">Qt√©</th>
                                    <th className="px-2 py-2">Nom</th>
                                    <th className="px-2 py-2 text-center w-16">Set</th>
                                    <th className="px-2 py-2 text-center w-12">N¬∞</th>
                                    <th className="px-2 py-2 text-center w-12">Foil</th>
                                    <th className="px-2 py-2 text-right w-24">Prix</th>
                                </tr>
                            </thead>
                            <tbody className="divide-y divide-border">
                                {cards.map((c, i) => {
                                    const marketPrice = c.price ?? 0;
                                    const finalPrice = c.customPrice ?? marketPrice;
                                    const scryData = c.scryfallData as ScryfallRawData | undefined;

                                    // Logique de couleur dynamique
                                    let priceColor = 'text-foreground';
                                    if (c.customPrice !== undefined) {
                                        if (isGiven) {
                                            // SORTIE : Vert si on vend plus cher que le march√©
                                            priceColor = c.customPrice > marketPrice ? 'text-success font-bold' : 'text-danger font-bold';
                                        } else {
                                            // ENTR√âE : Vert si on paye moins cher que le march√©
                                            priceColor = c.customPrice < marketPrice ? 'text-success font-bold' : 'text-danger font-bold';
                                        }
                                    }

                                    return (
                                        <tr key={i} className="hover:bg-secondary/50 transition-colors text-foreground select-none cursor-pointer text-[11px]" onClick={() => onPreview(c)}>
                                            <td className="px-2 py-2 text-center font-bold text-muted border-r border-border/5">{c.quantity}</td>
                                            <td className="px-2 py-2 font-medium truncate" title={c.name}>{c.name}</td>
                                            <td className="px-2 py-2 text-center"><span className="text-[9px] font-mono bg-secondary text-secondary-foreground px-1.5 py-0.5 rounded border border-border uppercase">{c.setCode}</span></td>
                                            <td className="px-2 py-2 text-center text-[9px] text-muted font-mono">{scryData?.collector_number || '?'}</td>
                                            <td className="px-2 py-2 text-center">{c.isFoil ? <span className="text-amber-500 font-bold text-[8px] uppercase">Foil</span> : <span className="text-muted/30">-</span>}</td>
                                            <td className={`px-2 py-2 text-right tabular-nums ${priceColor}`}>
                                                {finalPrice.toFixed(2)}‚Ç¨
                                            </td>
                                        </tr>
                                    );
                                })}
                            </tbody>
                        </table>

                        <div className="sm:hidden flex flex-col divide-y divide-border/50">
                            {cards.map((c, i) => {
                                const marketPrice = c.price ?? 0;
                                const finalPrice = c.customPrice ?? marketPrice;
                                const scryData = c.scryfallData as ScryfallRawData | undefined;

                                let priceColor = 'text-foreground';
                                if (c.customPrice !== undefined) {
                                    if (isGiven) {
                                        priceColor = c.customPrice > marketPrice ? 'text-success' : 'text-danger';
                                    } else {
                                        priceColor = c.customPrice < marketPrice ? 'text-success' : 'text-danger';
                                    }
                                }

                                return (
                                    <div key={i} className={`p-3 active:bg-secondary transition-colors flex flex-col gap-1.5 cursor-pointer ${accentBg}`} onClick={() => onPreview(c)}>
                                        <div className="flex justify-between items-start">
                                            <span className="text-xs font-bold text-foreground">{c.quantity}x {c.name}</span>
                                            <span className={`text-xs font-black ${priceColor}`}>{finalPrice.toFixed(2)}‚Ç¨</span>
                                        </div>
                                        <div className="flex items-center gap-2 text-[9px] font-bold uppercase">
                                            <span className="bg-secondary text-secondary-foreground px-1.5 py-0.5 rounded border border-border">{c.setCode}</span>
                                            <span className="text-muted">#{scryData?.collector_number || '?'}</span>
                                            {c.isFoil && <span className="text-amber-500 bg-amber-500/10 px-1.5 py-0.5 rounded border border-amber-500/20">Foil</span>}
                                        </div>
                                    </div>
                                );
                            })}
                        </div>
                    </div>
                )}
            </div>
        </div>
    );
};

// --- MODALE BILAN ---
const PeriodSummaryModal = ({ 
    isOpen, 
    onClose, 
    trades, 
    currentUid,
    onPreview 
}: { 
    isOpen: boolean, 
    onClose: () => void, 
    trades: TradeRequest[], 
    currentUid: string,
    onPreview: (c: CardType) => void
}) => {
    const [startDate, setStartDate] = useState(() => {
        const d = new Date();
        d.setDate(d.getDate() - 30);
        return d.toISOString().split('T')[0];
    });
    const [endDate, setEndDate] = useState(() => new Date().toISOString().split('T')[0]);

    const summary = useMemo(() => {
        if (!isOpen) return { given: [], received: [], valGiven: 0, valReceived: 0, count: 0 };
        const start = new Date(startDate).getTime();
        const end = new Date(endDate).getTime() + (24 * 60 * 60 * 1000) - 1;
        const filteredTrades = trades.filter(t => t.status === 'completed' && t.createdAt && (t.createdAt.seconds * 1000 >= start && t.createdAt.seconds * 1000 <= end));
        const allReceived: CardType[] = [];
        const allGiven: CardType[] = [];

        filteredTrades.forEach(trade => {
            const isSender = trade.senderUid === currentUid;
            if (isSender) {
                allGiven.push(...trade.itemsGiven);
                allReceived.push(...trade.itemsReceived);
            } else {
                allGiven.push(...trade.itemsReceived);
                allReceived.push(...trade.itemsGiven);
            }
        });

        return {
            given: aggregateCards(allGiven),
            received: aggregateCards(allReceived),
            valGiven: allGiven.reduce((acc, c) => acc + (c.customPrice ?? c.price ?? 0) * c.quantity, 0),
            valReceived: allReceived.reduce((acc, c) => acc + (c.customPrice ?? c.price ?? 0) * c.quantity, 0),
            count: filteredTrades.length
        };
    }, [isOpen, trades, currentUid, startDate, endDate]);

    if (!isOpen) return null;
    const balance = summary.valReceived - summary.valGiven;

    return (
        <div className="fixed inset-0 bg-black/80 flex items-center justify-center z-50 p-2 md:p-4 backdrop-blur-md" onClick={onClose}>
            <div className="bg-surface rounded-3xl max-w-5xl w-full shadow-2xl border border-border flex flex-col h-[95vh] md:h-auto md:max-h-[90vh] overflow-hidden animate-in zoom-in duration-300" onClick={e => e.stopPropagation()}>
                <div className="p-4 md:p-6 border-b border-border bg-background/50">
                    <div className="flex justify-between items-start mb-4">
                        <div>
                            <h2 className="text-xl font-black text-foreground uppercase tracking-tight">Bilan des Mouvements</h2>
                            <p className="text-[10px] text-muted font-bold uppercase mt-0.5">Statistiques de vos √©changes</p>
                        </div>
                        <button onClick={onClose} className="bg-secondary text-foreground rounded-full w-8 h-8 flex items-center justify-center text-xl font-bold hover:bg-border transition-colors">&times;</button>
                    </div>
                    <div className="grid grid-cols-2 gap-2 bg-secondary/50 p-2 rounded-2xl border border-border">
                        <div className="flex flex-col gap-1">
                            <span className="text-[8px] font-black uppercase text-muted px-1">D√©but</span>
                            <input type="date" value={startDate} onChange={(e) => setStartDate(e.target.value)} className="bg-surface text-foreground text-xs border-none rounded-xl px-2 py-1.5 outline-none font-bold shadow-sm" />
                        </div>
                        <div className="flex flex-col gap-1">
                            <span className="text-[8px] font-black uppercase text-muted px-1">Fin</span>
                            <input type="date" value={endDate} onChange={(e) => setEndDate(e.target.value)} className="bg-surface text-foreground text-xs border-none rounded-xl px-2 py-1.5 outline-none font-bold shadow-sm" />
                        </div>
                    </div>
                </div>

                <div className="p-4 md:p-6 overflow-y-auto grow custom-scrollbar space-y-6 bg-background/20">
                    <div className="grid grid-cols-3 gap-2 md:gap-4">
                        <div className="bg-surface p-3 rounded-2xl border border-border text-center shadow-sm">
                            <p className="text-[8px] md:text-[10px] text-muted uppercase font-black mb-1">√âchanges</p>
                            <p className="text-lg md:text-xl font-black text-foreground">{summary.count}</p>
                        </div>
                        <div className="bg-danger/10 p-3 rounded-2xl border border-danger/20 text-center shadow-sm">
                            <p className="text-[8px] md:text-[10px] text-danger uppercase font-black mb-1">Sorties</p>
                            <p className="text-lg md:text-xl font-black text-danger">-{summary.valGiven.toFixed(0)}‚Ç¨</p>
                        </div>
                        <div className="bg-success/10 p-3 rounded-2xl border border-success/20 text-center shadow-sm">
                            <p className="text-[8px] md:text-[10px] text-success uppercase font-black mb-1">Entr√©es</p>
                            <p className="text-lg md:text-xl font-black text-success">+{summary.valReceived.toFixed(0)}‚Ç¨</p>
                        </div>
                    </div>
                    <div className="grid md:grid-cols-2 gap-4">
                        <CompactCardTable cards={summary.given} title="Cartes Sorties" colorClass="text-danger" emptyLabel="Aucune sortie." onPreview={onPreview} />
                        <CompactCardTable cards={summary.received} title="Cartes Entr√©es" colorClass="text-success" emptyLabel="Aucune entr√©e." onPreview={onPreview} />
                    </div>
                </div>

                <div className="p-4 md:p-6 border-t border-border bg-background/50 flex justify-between items-center">
                    <span className="text-xs text-muted font-black uppercase tracking-widest">Balance Finale</span>
                    <div className={`text-2xl font-black tabular-nums ${balance >= 0 ? 'text-success' : 'text-danger'}`}>
                        {balance > 0 ? '+' : ''}{balance.toFixed(2)} ‚Ç¨
                    </div>
                </div>
            </div>
        </div>
    );
};

const HistoryCard = ({ trade, currentUid, onPreview }: { trade: TradeRequest, currentUid: string, onPreview: (c: CardType) => void }) => {
    const [isOpen, setIsOpen] = useState(false);
    const isSender = trade.senderUid === currentUid;
    const partnerName = isSender ? trade.receiverName : trade.senderName;
    const givenCards = isSender ? trade.itemsGiven : trade.itemsReceived;
    const receivedCards = isSender ? trade.itemsReceived : trade.itemsGiven;

    const valGiven = givenCards.reduce((acc, c) => acc + (c.customPrice ?? c.price ?? 0) * c.quantity, 0);
    const valReceived = receivedCards.reduce((acc, c) => acc + (c.customPrice ?? c.price ?? 0) * c.quantity, 0);

    const statusConfig: Record<string, { label: string, color: string, bg: string }> = {
        completed: { label: 'Termin√©', color: 'text-success', bg: 'bg-success/10' },
        rejected: { label: 'Refus√©', color: 'text-danger', bg: 'bg-danger/10' },
        cancelled: { label: 'Annul√©', color: 'text-muted', bg: 'bg-secondary' },
    };
    const config = statusConfig[trade.status] || statusConfig['cancelled'];

    return (
        <div className="rounded-2xl border border-border bg-surface shadow-sm overflow-hidden mb-4">
            <div className="p-4 flex flex-col md:flex-row justify-between items-center gap-4 cursor-pointer hover:bg-secondary/30 transition select-none" onClick={() => setIsOpen(!isOpen)}>
                <div className="flex items-center gap-4 w-full md:w-auto">
                    <div className={`px-3 py-1 rounded-lg text-[10px] font-black uppercase shrink-0 ${config.bg} ${config.color} border border-current/20`}>
                        {config.label}
                    </div>
                    <div className="min-w-0">
                        <p className="font-bold text-foreground truncate">
                            {isSender ? `Envoy√© √† ${partnerName}` : `Re√ßu de ${partnerName}`}
                        </p>
                        <p className="text-[10px] text-muted font-medium">{formatDate(trade.createdAt)}</p>
                    </div>
                </div>
                <div className="flex items-center gap-8 text-sm w-full md:w-auto justify-between md:justify-end">
                    <div className="text-right">
                        <p className="text-muted text-[9px] uppercase font-black">Donn√©</p>
                        <p className="font-bold text-danger">-{valGiven.toFixed(2)}‚Ç¨</p>
                    </div>
                    <div className="text-right">
                        <p className="text-muted text-[9px] uppercase font-black">Re√ßu</p>
                        <p className="font-bold text-success">+{valReceived.toFixed(2)}‚Ç¨</p>
                    </div>
                    <div className={`text-muted transition-transform duration-300 ${isOpen ? 'rotate-180' : ''}`}>
                        <svg className="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={3} d="M19 9l-7 7-7-7" /></svg>
                    </div>
                </div>
            </div>
            {isOpen && (
                <div className="border-t border-border p-4 bg-background/20 grid md:grid-cols-2 gap-4 animate-in slide-in-from-top-2">
                    <CompactCardTable cards={aggregateCards(givenCards)} title="Sorties" colorClass="text-danger" emptyLabel="-" onPreview={onPreview} />
                    <CompactCardTable cards={aggregateCards(receivedCards)} title="Entr√©es" colorClass="text-success" emptyLabel="-" onPreview={onPreview} />
                </div>
            )}
        </div>
    );
};

export default function TradeHistoryPage() {
    const { user } = useAuth();
    const [history, setHistory] = useState<TradeRequest[]>([]);
    const [loading, setLoading] = useState(true);
    const [showSummary, setShowSummary] = useState(false);
    const [previewCard, setPreviewCard] = useState<CardType | null>(null);

    useEffect(() => {
        if (!user) return;
        const qSender = query(collection(db, 'trades'), where('senderUid', '==', user.uid), where('status', 'in', ['completed', 'rejected', 'cancelled']), orderBy('createdAt', 'desc'));
        const qReceiver = query(collection(db, 'trades'), where('receiverUid', '==', user.uid), where('status', 'in', ['completed', 'rejected', 'cancelled']), orderBy('createdAt', 'desc'));
        let sentData: TradeRequest[] = [];
        let receivedData: TradeRequest[] = [];
        const updateMerged = () => {
            const seenTradeIds = new Set<string>();
            const merged: TradeRequest[] = [];
            [...sentData, ...receivedData].forEach(trade => {
                if (!seenTradeIds.has(trade.id)) {
                    merged.push(trade);
                    seenTradeIds.add(trade.id);
                }
            });
            merged.sort((a, b) => (b.createdAt?.seconds || 0) - (a.createdAt?.seconds || 0));
            setHistory(merged);
            setLoading(false);
        };
        const u1 = onSnapshot(qSender, (snap) => { sentData = snap.docs.map(d => ({ id: d.id, ...d.data() } as TradeRequest)); updateMerged(); });
        const u2 = onSnapshot(qReceiver, (snap) => { receivedData = snap.docs.map(d => ({ id: d.id, ...d.data() } as TradeRequest)); updateMerged(); });
        return () => { u1(); u2(); };
    }, [user]);

    if (!user) return <div className="p-10 text-center text-muted font-bold">Connexion requise.</div>;

    return (
        <main className="container mx-auto p-4 max-w-5xl min-h-[85vh]">
            <div className="flex flex-col sm:flex-row justify-between items-end sm:items-center gap-4 mb-10 border-b border-border pb-6">
                <div className="flex items-center gap-6">
                    <Link href="/trades" className="text-xs bg-secondary text-secondary-foreground hover:bg-primary hover:text-white px-4 py-2 rounded-xl transition-all font-black uppercase tracking-tighter shadow-sm border border-border">‚Üê Retour</Link>
                    <h1 className="text-3xl font-black text-foreground tracking-tighter uppercase">Historique</h1>
                </div>
                <button onClick={() => setShowSummary(true)} className="btn-primary uppercase text-xs tracking-widest px-6 py-3">Bilan P√©riodique</button>
            </div>

            {loading ? (
                <div className="text-center py-20 text-muted animate-pulse font-bold tracking-widest text-xs uppercase">Initialisation...</div>
            ) : history.length === 0 ? (
                <div className="text-center py-24 bg-surface rounded-3xl border border-dashed border-border shadow-inner"><p className="text-muted italic font-medium">Aucun mouvement d&apos;√©change enregistr√©.</p></div>
            ) : (
                <div className="space-y-2 animate-in fade-in slide-in-from-bottom-4 duration-500">
                    {history.map(trade => <HistoryCard key={trade.id} trade={trade} currentUid={user.uid} onPreview={setPreviewCard} />)}
                </div>
            )}

            <PeriodSummaryModal isOpen={showSummary} onClose={() => setShowSummary(false)} trades={history} currentUid={user.uid} onPreview={setPreviewCard} />

            {previewCard && (
                <div className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black/90 backdrop-blur-sm animate-in fade-in cursor-pointer" onClick={() => setPreviewCard(null)}>
                    <div className="relative transform transition-all scale-100 p-4" onClick={e => e.stopPropagation()}>
                        <button onClick={() => setPreviewCard(null)} className="absolute -top-2 -right-2 bg-surface text-foreground rounded-full p-2 shadow-xl z-10 border border-border active:scale-90 transition-transform">&times;</button>
                        <div className="w-[300px] h-[420px] shadow-2xl rounded-2xl overflow-hidden pointer-events-none ring-1 ring-white/10">
                            <MagicCard {...previewCard} readOnly={true} quantity={previewCard.quantity} hideFooter={true} />
                        </div>
                    </div>
                </div>
            )}
        </main>
    );
}
</file>

<file path="hooks/useFriends.ts">
// hooks/useFriends.ts
import { useState, useEffect } from 'react';
import { db } from '@/lib/firebase';
import { useAuth } from '@/lib/AuthContext';
import { 
  doc, setDoc, deleteDoc, 
  collection, onSnapshot, serverTimestamp, 
  query, collectionGroup, where, getDocs, limit,
  writeBatch 
} from 'firebase/firestore';
import { acceptFriendRequestAction } from '@/app/actions/friends';
import toast from 'react-hot-toast';

export type FriendProfile = {
  uid: string;
  username: string;
  displayName: string;
  // Correction 1 : On autorise explicitement null ici
  photoURL?: string | null; 
};

type FirestoreProfileData = {
    username: string;
    displayName: string;
    photoURL?: string;
    [key: string]: unknown;
};

export function useFriends() {
  const { user, username } = useAuth();
  
  const [friends, setFriends] = useState<FriendProfile[]>([]);
  const [requestsReceived, setRequestsReceived] = useState<FriendProfile[]>([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    if (!user) {
      setFriends([]);
      setRequestsReceived([]);
      setLoading(false);
      return;
    }

    setLoading(true);

    // 1. √âcoute Mes Amis
    const friendsRef = collection(db, 'users', user.uid, 'friends');
    const unsubFriends = onSnapshot(friendsRef, (snap) => {
      const list = snap.docs.map(d => d.data() as FriendProfile);
      setFriends(list);
      setLoading(false); 
    }, (error) => {
        console.error("useFriends: Erreur √©coute Amis:", error);
        setLoading(false); 
    });

    // 2. √âcoute Demandes Re√ßues
    const reqRef = collection(db, 'users', user.uid, 'friend_requests_received');
    const unsubReq = onSnapshot(reqRef, (snap) => {
      const list = snap.docs.map(d => ({ uid: d.id, ...d.data() } as FriendProfile));
      setRequestsReceived(list);
    }, (error) => {
        console.error("useFriends: Erreur √©coute Demandes:", error);
    });

    return () => {
      unsubFriends();
      unsubReq();
    };
  }, [user]);

  // --- ACTIONS ---

  const searchUsers = async (searchTerm: string) => {
    const term = searchTerm.trim().toLowerCase();
    if (term.length < 2) return [];

    const usersQuery = query(
      collectionGroup(db, 'public_profile'), 
      where('username', '>=', term),
      where('username', '<=', term + '\uf8ff'),
      limit(5)
    );

    const snapshot = await getDocs(usersQuery);
    
    const results: FriendProfile[] = [];
    snapshot.forEach(docSnap => {
      const data = docSnap.data() as FirestoreProfileData;
      const foundUid = docSnap.ref.parent.parent?.id;

      if (foundUid && foundUid !== user?.uid) {
        results.push({
            uid: foundUid,
            username: data.username,
            displayName: data.displayName,
            photoURL: data.photoURL || null
        });
      }
    });

    return results;
  };

  const sendFriendRequest = async (targetUser: FriendProfile) => {
    if (!user || !username) return;

    if (friends.some(f => f.uid === targetUser.uid)) {
      toast.error("Vous √™tes d√©j√† amis !");
      return;
    }

    try {
      await setDoc(doc(db, 'users', targetUser.uid, 'friend_requests_received', user.uid), {
        uid: user.uid,
        username: username,
        displayName: user.displayName,
        photoURL: user.photoURL || null,
        sentAt: serverTimestamp()
      });
      
      toast.success(`Demande envoy√©e √† @${targetUser.username}`);
    } catch (error) {
      console.error(error);
      toast.error("Erreur lors de l'envoi.");
    }
  };

  const acceptRequest = async (sender: FriendProfile) => {
    if (!user) return;

    const toastId = toast.loading("Acceptation...");

    try {
        // Correction 2 : On retire ": FriendProfile" pour laisser TypeScript inf√©rer le bon type
        // Cela √©vite le conflit entre "string | undefined" et "string | null"
        const cleanSender = {
            uid: sender.uid,
            username: sender.username,
            displayName: sender.displayName,
            photoURL: sender.photoURL || null 
        };

        const result = await acceptFriendRequestAction(user.uid, cleanSender);

        if (result.success) {
            toast.success(`Ami ajout√© : @${sender.username}`, { id: toastId });
        } else {
            throw new Error(result.error);
        }
    } catch (err: unknown) {
      console.error(err);
      let msg = "Erreur validation";
      if (err instanceof Error) msg = err.message;
      toast.error(msg, { id: toastId });
    }
  };

  const declineRequest = async (senderUid: string) => {
    if (!user) return;
    try {
        await deleteDoc(doc(db, 'users', user.uid, 'friend_requests_received', senderUid));
        toast.success("Demande supprim√©e");
    } catch (error) {
        console.error(error);
        toast.error("Erreur lors du refus");
    }
  };
  
  const removeFriend = async (friendUid: string) => {
      if(!user) return;
      if(!confirm("Retirer cet ami d√©finitivement ?")) return;
      
      try {
        const batch = writeBatch(db);
        
        batch.delete(doc(db, 'users', user.uid, 'friends', friendUid));
        batch.delete(doc(db, 'users', friendUid, 'friends', user.uid));

        await batch.commit();
        
        toast.success("Ami retir√© (Liaison coup√©e)");
      } catch (error) {
        console.error("Erreur suppression ami:", error);
        toast.error("Erreur lors de la suppression");
      }
  };

  return { 
    friends, 
    requestsReceived, 
    loading, 
    searchUsers, 
    sendFriendRequest, 
    acceptRequest, 
    declineRequest, 
    removeFriend
  };
}
</file>

<file path="app/actions/trade.ts">
// app/actions/trade.ts
'use server';

import { getAdminFirestore } from '@/lib/firebase-admin';
import { FieldValue, DocumentData } from 'firebase-admin/firestore';
import { CardType } from '@/hooks/useCardCollection';
import { z } from 'zod';
import { CardSchema } from '@/lib/validators';

// Sch√©ma de validation pour l'action serveur
const TradeActionSchema = z.object({
    tradeId: z.string().min(1),
    senderUid: z.string().min(1),
    receiverUid: z.string().min(1),
    itemsGiven: z.array(CardSchema),
    itemsReceived: z.array(CardSchema)
});

const ManualTradeSchema = z.object({
    userId: z.string().min(1),
    itemsGiven: z.array(CardSchema),
    itemsReceived: z.array(CardSchema)
});

// Helper pour extraire les donn√©es S√õRES depuis la DB (Source of Truth)
// On ignore les donn√©es cosm√©tiques envoy√©es par le client pour √©viter le spoofing
const createSafeCardDataFromSnapshot = (snapData: DocumentData, quantityToTransfer: number) => {
    return {
        name: snapData.name,
        imageUrl: snapData.imageUrl,
        imageBackUrl: snapData.imageBackUrl || null,
        setName: snapData.setName || '',
        setCode: snapData.setCode || '',
        price: snapData.price || 0,
        // On utilise la quantit√© transf√©r√©e, pas celle du snapshot original
        quantity: quantityToTransfer,
        isFoil: snapData.isFoil || false,
        isSpecificVersion: snapData.isSpecificVersion || false,
        scryfallData: snapData.scryfallData || null,
        
        // Champs syst√®me remis √† neuf pour le nouveau propri√©taire
        addedAt: FieldValue.serverTimestamp(),
        wishlistId: null,
        isForTrade: false,
        quantityForTrade: 0,
        customPrice: null, // On reset le prix custom lors d'un √©change
        purchasePrice: null
    };
};

// Helper pour cr√©er une carte lors d'un import externe (Manual Trade - R√©ception)
// Ici on est oblig√© de faire confiance au client car la carte n'existe pas encore dans le syst√®me,
// mais c'est moins grave car c'est un ajout manuel unilat√©ral.
const createCardDataFromInput = (card: CardType) => {
    return {
        name: card.name,
        imageUrl: card.imageUrl,
        imageBackUrl: card.imageBackUrl || null,
        setName: card.setName || '',
        setCode: card.setCode || '',
        price: card.price || 0,
        quantity: card.quantity, 
        isFoil: card.isFoil || false,
        isSpecificVersion: card.isSpecificVersion || false,
        scryfallData: card.scryfallData || null,
        addedAt: FieldValue.serverTimestamp(),
        wishlistId: null,
        isForTrade: false,
        quantityForTrade: 0
    };
};

// --- ACTION 1 : √âCHANGE P2P AVEC VALIDATION STATUS ---
export async function executeServerTrade(
    tradeId: string,
    senderUid: string,
    receiverUid: string,
    itemsGiven: CardType[],
    itemsReceived: CardType[]
) {
    const db = getAdminFirestore();

    // 1. Validation Runtime des entr√©es
    const validation = TradeActionSchema.safeParse({ 
        tradeId, senderUid, receiverUid, itemsGiven, itemsReceived 
    });

    if (!validation.success) {
        return { success: false, error: "Donn√©es d'√©change invalides." };
    }

    try {
        await db.runTransaction(async (t) => {
            // PHASE 1 : TOUTES LES LECTURES
            
            // A. V√©rifier que l'√©change est toujours 'pending'
            const tradeRef = db.doc(`trades/${tradeId}`);
            const tradeSnap = await t.get(tradeRef);
            if (!tradeSnap.exists) throw new Error("√âchange introuvable");
            if (tradeSnap.data()?.status !== 'pending') throw new Error("Cet √©change n'est plus en attente.");

            // B. Lire les stocks Exp√©diteur (Source de v√©rit√© pour ce que Sender DONNE)
            const senderStockSnaps = [];
            for (const card of itemsGiven) {
                const ref = db.doc(`users/${senderUid}/collection/${card.id}`);
                const snap = await t.get(ref);
                senderStockSnaps.push({ ref, card, snap });
            }

            // C. Lire les stocks Receveur (Source de v√©rit√© pour ce que Receiver DONNE)
            const receiverStockSnaps = [];
            for (const card of itemsReceived) {
                const ref = db.doc(`users/${receiverUid}/collection/${card.id}`);
                const snap = await t.get(ref);
                receiverStockSnaps.push({ ref, card, snap });
            }

            // D. Lire les destinations (V√©rifier si le destinataire a d√©j√† la carte pour stacker)
            const senderDestSnaps = [];
            for (const card of itemsReceived) {
                const ref = db.doc(`users/${senderUid}/collection/${card.id}`);
                const snap = await t.get(ref);
                senderDestSnaps.push({ ref, card, snap });
            }

            const receiverDestSnaps = [];
            for (const card of itemsGiven) {
                const ref = db.doc(`users/${receiverUid}/collection/${card.id}`);
                const snap = await t.get(ref);
                receiverDestSnaps.push({ ref, card, snap });
            }

            // PHASE 2 : V√âRIFICATIONS LOGIQUES
            
            // Cr√©ation de Maps pour retrouver facilement les donn√©es sources
            const senderSourceMap = new Map<string, DocumentData>();
            for (const item of senderStockSnaps) {
                if (!item.snap.exists || (item.snap.data()?.quantity || 0) < item.card.quantity) {
                    throw new Error(`L'exp√©diteur ne poss√®de plus assez de : ${item.card.name}`);
                }
                senderSourceMap.set(item.card.id, item.snap.data()!);
            }

            const receiverSourceMap = new Map<string, DocumentData>();
            for (const item of receiverStockSnaps) {
                if (!item.snap.exists || (item.snap.data()?.quantity || 0) < item.card.quantity) {
                    throw new Error(`Le partenaire ne poss√®de plus assez de : ${item.card.name}`);
                }
                receiverSourceMap.set(item.card.id, item.snap.data()!);
            }

            // PHASE 3 : √âCRITURES

            // 1. Mise √† jour du statut
            t.update(tradeRef, { 
                status: 'completed',
                completedAt: FieldValue.serverTimestamp()
            });

            // 2. SOUSTRACTION DES STOCKS
            for (const item of senderStockSnaps) {
                if (item.snap.data()?.quantity === item.card.quantity) {
                    t.delete(item.ref);
                } else {
                    t.update(item.ref, { 
                        quantity: FieldValue.increment(-item.card.quantity),
                        // On r√©duit aussi le stock d'√©change si n√©cessaire pour ne pas avoir trade > qty
                        quantityForTrade: FieldValue.increment(-item.card.quantity) 
                    });
                }
            }
            for (const item of receiverStockSnaps) {
                if (item.snap.data()?.quantity === item.card.quantity) {
                    t.delete(item.ref);
                } else {
                    t.update(item.ref, { 
                        quantity: FieldValue.increment(-item.card.quantity),
                        quantityForTrade: FieldValue.increment(-item.card.quantity)
                    });
                }
            }

            // 3. AJOUT CHEZ EXP√âDITEUR (Il re√ßoit les cartes du Receveur)
            for (const item of senderDestSnaps) {
                // S√âCURIT√â : On utilise les donn√©es du receiverSourceMap, pas item.card !
                const sourceData = receiverSourceMap.get(item.card.id);
                if (!sourceData) throw new Error("Erreur int√©grit√© donn√©es (Sender Dest)");

                if (item.snap.exists) {
                    t.update(item.ref, { quantity: FieldValue.increment(item.card.quantity) });
                } else {
                    t.set(item.ref, createSafeCardDataFromSnapshot(sourceData, item.card.quantity));
                }
                // Nettoyage Wishlist
                const wishRef = db.doc(`users/${senderUid}/wishlist/${item.card.id}`);
                t.delete(wishRef); 
            }

            // 4. AJOUT CHEZ RECEVEUR (Il re√ßoit les cartes de l'Exp√©diteur)
            for (const item of receiverDestSnaps) {
                // S√âCURIT√â : On utilise les donn√©es du senderSourceMap
                const sourceData = senderSourceMap.get(item.card.id);
                if (!sourceData) throw new Error("Erreur int√©grit√© donn√©es (Receiver Dest)");

                if (item.snap.exists) {
                    t.update(item.ref, { quantity: FieldValue.increment(item.card.quantity) });
                } else {
                    t.set(item.ref, createSafeCardDataFromSnapshot(sourceData, item.card.quantity));
                }
                // Nettoyage Wishlist
                const wishRef = db.doc(`users/${receiverUid}/wishlist/${item.card.id}`);
                t.delete(wishRef);
            }
        });

        return { success: true };

    } catch (error: unknown) {
        console.error("Trade Error:", error);
        let errorMessage = "Une erreur inconnue est survenue";
        if (error instanceof Error) errorMessage = error.message;
        else if (typeof error === "string") errorMessage = error;
        return { success: false, error: errorMessage };
    }
}

// --- ACTION 2 : √âCHANGE MANUEL (SOLO) ---
export async function executeManualTrade(
    userId: string,
    itemsGiven: CardType[],    
    itemsReceived: CardType[]  
) {
    const db = getAdminFirestore();
    
    const validation = ManualTradeSchema.safeParse({ userId, itemsGiven, itemsReceived });
    if (!validation.success) return { success: false, error: "Donn√©es invalides" };

    try {
        await db.runTransaction(async (t) => {
            // PHASE 1 : LECTURES
            const stockSnaps = [];
            for (const card of itemsGiven) {
                const ref = db.doc(`users/${userId}/collection/${card.id}`);
                const snap = await t.get(ref);
                stockSnaps.push({ ref, card, snap });
            }

            const destSnaps = [];
            for (const card of itemsReceived) {
                const ref = db.doc(`users/${userId}/collection/${card.id}`);
                const snap = await t.get(ref);
                destSnaps.push({ ref, card, snap });
            }

            // PHASE 2 : V√âRIFICATIONS & √âCRITURES
            for (const item of stockSnaps) {
                if (!item.snap.exists || (item.snap.data()?.quantity || 0) < item.card.quantity) {
                    throw new Error(`Erreur: Vous ne poss√©dez pas assez de "${item.card.name}".`);
                }
                if (item.snap.data()?.quantity === item.card.quantity) {
                    t.delete(item.ref);
                } else {
                    t.update(item.ref, { quantity: FieldValue.increment(-item.card.quantity) });
                }
            }

            for (const item of destSnaps) {
                const wishRef = db.doc(`users/${userId}/wishlist/${item.card.id}`);
                if (item.snap.exists) {
                    t.update(item.ref, { quantity: FieldValue.increment(item.card.quantity) });
                } else {
                    // Pour un √©change manuel, on utilise les donn√©es fournies (import externe)
                    t.set(item.ref, createCardDataFromInput(item.card));
                }
                t.delete(wishRef);
            }
        });

        return { success: true };

    } catch (error: unknown) {
        console.error("Manual Trade Error:", error);
        let errorMessage = "Erreur lors de l'√©change manuel";
        if (error instanceof Error) errorMessage = error.message;
        return { success: false, error: errorMessage };
    }
}
</file>

<file path="components/wishlist/GlobalWishlistView.tsx">
// components/wishlist/GlobalWishlistView.tsx
'use client';

import { useState, useEffect, useMemo } from 'react';
import { useAuth } from '@/lib/AuthContext';
import { WishlistMeta } from '@/hooks/useWishlists';
import { CardType } from '@/hooks/useCardCollection';
import MagicCard from '@/components/MagicCard';
import { db } from '@/lib/firebase';
import { collection, getDocs } from 'firebase/firestore';
import toast from 'react-hot-toast';
import CardListFilterBar from '@/components/common/CardListFilterBar';
import { useSortPreference, SortOption } from '@/hooks/useSortPreference';
import { useColumnPreference } from '@/hooks/useColumnPreference';

const ITEMS_PER_PAGE = 50;

type Props = {
    lists: WishlistMeta[];
};

type CardSource = CardType & { sourceListName: string };

export default function GlobalWishlistView({ lists }: Props) {
    const { user } = useAuth();
    const [allCards, setAllCards] = useState<CardSource[]>([]);
    const [loading, setLoading] = useState(true);
    
    // --- GESTION DES PREFERENCES (Colonnes & Tri) ---
    const { columns, setColumns } = useColumnPreference('mw_cols_wishlist_global', 5);
    const { sortBy, setSortBy } = useSortPreference('mw_sort_wishlist_global', 'name_asc' as SortOption);

    // --- ETATS DES FILTRES ---
    const [searchQuery, setSearchQuery] = useState('');
    const [filterSet, setFilterSet] = useState<string>('all');
    const [filterFoil, setFilterFoil] = useState(false);
    const [minPriceFilter, setMinPriceFilter] = useState<string>('');
    const [maxPriceFilter, setMaxPriceFilter] = useState<string>('');
    const [filterCMC, setFilterCMC] = useState<string>('');
    const [filterColors, setFilterColors] = useState<string[]>([]);

    // --- PAGINATION ---
    const [visibleCount, setVisibleCount] = useState(ITEMS_PER_PAGE);

    useEffect(() => {
        if (!user || lists.length === 0) return;

        const fetchAll = async () => {
            setLoading(true);
            let combined: CardSource[] = [];

            try {
                // A. Liste par d√©faut
                const defaultRef = collection(db, 'users', user.uid, 'wishlist');
                const defaultSnap = await getDocs(defaultRef);
                const defaultCards = defaultSnap.docs.map(d => ({ 
                    ...d.data(), 
                    id: d.id, 
                    sourceListName: 'Liste principale' 
                })) as CardSource[];
                combined = [...defaultCards];

                // B. Listes customs
                const customLists = lists.filter(l => l.id !== 'default');
                const promises = customLists.map(async (list) => {
                    const colRef = collection(db, 'users', user.uid, 'wishlists_data', list.id, 'cards');
                    const snap = await getDocs(colRef);
                    return snap.docs.map(d => ({
                        ...d.data(),
                        id: d.id,
                        sourceListName: list.name
                    })) as CardSource[];
                });

                const results = await Promise.all(promises);
                results.forEach(res => { combined = [...combined, ...res]; });

                setAllCards(combined);
            } catch (error) {
                console.error("Erreur chargement global", error);
                toast.error("Erreur lors du chargement global");
            } finally {
                setLoading(false);
            }
        };

        fetchAll();
    }, [user, lists]);

    // Reset pagination quand on filtre
    useEffect(() => {
        if (visibleCount !== ITEMS_PER_PAGE) {
            setVisibleCount(ITEMS_PER_PAGE);
        }
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [searchQuery, filterSet, filterFoil, minPriceFilter, maxPriceFilter, filterCMC, filterColors, sortBy]);

    // --- LOGIQUE DE FILTRAGE ET TRI ---
    const filteredAndSortedCards = useMemo(() => {
        let result = [...allCards];
        
        const minPrice = parseFloat(minPriceFilter);
        const maxPrice = parseFloat(maxPriceFilter);

        // 1. Filtres
        if (searchQuery) {
            const lowerQ = searchQuery.toLowerCase();
            result = result.filter(c => c.name.toLowerCase().includes(lowerQ));
        }
        if (filterSet !== 'all') {
            result = result.filter(c => c.setName === filterSet);
        }
        if (filterFoil) {
            result = result.filter(c => c.isFoil);
        }
        
        if (!isNaN(minPrice) || !isNaN(maxPrice)) {
            result = result.filter(c => {
                const cardPrice = c.price ?? 0;
                const isAboveMin = isNaN(minPrice) || cardPrice >= minPrice;
                const isBelowMax = isNaN(maxPrice) || cardPrice <= maxPrice;
                return isAboveMin && isBelowMax;
            });
        }

        if (filterCMC) { 
            const t = parseFloat(filterCMC); 
            if (!isNaN(t)) result = result.filter(c => c.cmc === t); 
        }

        if (filterColors.length > 0) {
            result = result.filter(c => {
                if (!c.colors || c.colors.length === 0) return filterColors.includes('C');
                return c.colors.every(col => filterColors.includes(col));
            });
        }

        // 2. Tri Bidirectionnel
        result.sort((a, b) => {
            const priceA = a.price ?? 0;
            const priceB = b.price ?? 0;
            const dateA = a.lastPriceUpdate ? new Date(a.lastPriceUpdate).getTime() : 0;
            const dateB = b.lastPriceUpdate ? new Date(b.lastPriceUpdate).getTime() : 0;
            const cmcA = a.cmc ?? 0;
            const cmcB = b.cmc ?? 0;

            switch (sortBy) {
                // NOM
                case 'name_asc': return a.name.localeCompare(b.name);
                case 'name_desc': return b.name.localeCompare(a.name);
                case 'name': return a.name.localeCompare(b.name);

                // PRIX
                case 'price_asc': return priceA - priceB;
                case 'price_desc': return priceB - priceA;

                // DATE
                case 'date_asc': return dateA - dateB;
                case 'date_desc': return dateB - dateA;
                case 'date': return dateB - dateA;

                // CMC
                case 'cmc_asc': return cmcA - cmcB;
                case 'cmc_desc': return cmcB - cmcA;

                // SET
                case 'set_asc': return (a.setName || '').localeCompare(b.setName || '');
                case 'set_desc': return (b.setName || '').localeCompare(a.setName || '');

                default: return 0;
            }
        });

        return result;
    }, [allCards, searchQuery, sortBy, filterSet, filterFoil, minPriceFilter, maxPriceFilter, filterCMC, filterColors]);

    const visibleCards = useMemo(() => {
        return filteredAndSortedCards.slice(0, visibleCount);
    }, [filteredAndSortedCards, visibleCount]);

    // Calcul du total bas√© sur les cartes FILTR√âES (plus logique pour l'utilisateur)
    const currentTotal = useMemo(() => {
        return filteredAndSortedCards.reduce((acc, card) => acc + (card.price || 0) * card.quantity, 0);
    }, [filteredAndSortedCards]);

    const handleLoadMore = () => {
        setVisibleCount(prev => prev + ITEMS_PER_PAGE);
    };

    if (loading) {
        return <div className="p-10 text-center animate-pulse">Fusion des listes en cours...</div>;
    }

    return (
        <div className="animate-in fade-in duration-300 pb-10">
             
             {/* EN-T√äTE */}
             <div className="flex justify-between items-end mb-6 border-b pb-4 dark:border-gray-700 bg-linear-to-r from-blue-50 to-transparent dark:from-blue-900/20 p-4 rounded-t-xl">
                <div>
                    <h2 className="text-2xl font-bold text-gray-800 dark:text-white flex items-center gap-2">
                        Vue Globale
                    </h2>
                    <p className="text-sm text-gray-500 mt-1">
                        {filteredAndSortedCards.length} cartes affich√©es (sur {allCards.length})
                    </p>
                </div>
                <div className="text-right">
                    <span className="text-xs text-gray-500 uppercase font-semibold">Valeur Filtr√©e</span>
                    <p className="text-3xl font-bold text-blue-600 dark:text-blue-400">{currentTotal.toFixed(2)} ‚Ç¨</p>
                </div>
            </div>

            {/* BARRE DE FILTRES */}
            <CardListFilterBar
                context="wishlist-global"
                cards={allCards} // On passe toutes les cartes pour g√©n√©rer les options de Sets
                searchQuery={searchQuery}
                setSearchQuery={setSearchQuery}
                sortBy={sortBy}
                setSortBy={setSortBy}
                filterSet={filterSet}
                setFilterSet={setFilterSet}
                filterTrade={false}
                setFilterTrade={() => {}}
                filterFoil={filterFoil}
                setFilterFoil={setFilterFoil}
                minPriceFilter={minPriceFilter}
                setMinPriceFilter={setMinPriceFilter}
                maxPriceFilter={maxPriceFilter}
                setMaxPriceFilter={setMaxPriceFilter}
                filterCMC={filterCMC}
                setFilterCMC={setFilterCMC}
                filterColors={filterColors}
                setFilterColors={setFilterColors}
                columns={columns}
                setColumns={setColumns}
                // Pas de total ici car affich√© dans le header au-dessus
            />

            {/* LISTE VIDE */}
            {filteredAndSortedCards.length === 0 ? (
                <div className="text-center py-12">
                    <p className="text-gray-500 italic">Aucune carte ne correspond √† vos filtres.</p>
                    <button 
                        onClick={() => { setSearchQuery(''); setFilterSet('all'); setFilterFoil(false); setMinPriceFilter(''); setMaxPriceFilter(''); setFilterCMC(''); setFilterColors([]); }} 
                        className="text-primary hover:underline mt-2"
                    >
                        R√©initialiser les filtres
                    </button>
                </div>
            ) : (
                <>
                    {/* GRILLE */}
                    <div 
                        className="grid gap-4"
                        style={{ gridTemplateColumns: `repeat(${columns}, minmax(0, 1fr))` }}
                    >
                        {visibleCards.map((card, idx) => (
                            <div key={`${card.id}-${idx}`} className="relative group">
                                {/* Badge indiquant la liste d'origine */}
                                <div className="absolute top-0 right-0 z-30 bg-black/70 text-white text-[10px] px-2 py-1 rounded-bl-lg backdrop-blur-sm pointer-events-none">
                                    {card.sourceListName}
                                </div>
                                
                                <MagicCard 
                                    {...card} 
                                    isWishlist={false} 
                                    readOnly={true} 
                                />
                            </div>
                        ))}
                    </div>

                    {/* BOUTON CHARGER PLUS */}
                    {visibleCount < filteredAndSortedCards.length && (
                        <div className="flex justify-center mt-8">
                            <button 
                                onClick={handleLoadMore}
                                className="px-6 py-3 bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-full shadow-lg hover:bg-gray-50 dark:hover:bg-gray-700 font-bold text-primary transition transform hover:scale-105"
                            >
                                Afficher plus ({filteredAndSortedCards.length - visibleCount} restantes)
                            </button>
                        </div>
                    )}
                </>
            )}
        </div>
    );
}
</file>

<file path="app/globals.css">
@import "tailwindcss";

/* --- CONFIGURATION DU TH√àME (Mapping v4) --- */
@theme {
  /* On mappe les classes Tailwind (ex: bg-primary) vers les variables CSS */
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  
  --color-surface: var(--surface);
  --color-surface-foreground: var(--surface-foreground);
  
  --color-border: var(--border);

  --color-primary: var(--primary);
  --color-primary-foreground: var(--primary-foreground);

  --color-secondary: var(--secondary);
  --color-secondary-foreground: var(--secondary-foreground);

  --color-muted: var(--muted);
  --color-danger: var(--danger);
  --color-success: var(--success);
  
  --color-success-vif: var(--success-vif);

  /* Fonts */
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
}

/* --- D√âFINITION DES VALEURS (CSS Natif) --- */
:root {
  /* Mode Clair */
  --background: #f4f6fc; 
  --foreground: #27272a; 

  --surface: #ffffff;
  --surface-foreground: #27272a;

  --border: #e4e4e7; 

  --primary: #6275b3;
  --primary-foreground: #ffffff;

  --secondary: #eef2ff; 
  --secondary-foreground: #6275b3;

  --muted: #a1a1aa; 
  --danger: #ef4444; 
  --success: #10b981; 
  
  --success-vif: #48c99f;
}

/* Mode Sombre (Tailwind v4 d√©tecte automatiquement la classe .dark si pr√©sente) */
.dark {
  --background: #09090b; 
  --foreground: #f4f4f5; 

  --surface: #18181b; 
  --surface-foreground: #f4f4f5;

  --border: #27272a; 

  --primary: #7a8bc9; 
  --primary-foreground: #ffffff;

  --secondary: #1e1b4b; 
  --secondary-foreground: #a5b4fc;
  
  --success-vif: #37a380; 
}

/* --- STYLES GLOBAUX --- */
body {
  background: var(--background);
  color: var(--foreground);
  font-family: var(--font-sans), Arial, Helvetica, sans-serif;
  -webkit-font-smoothing: antialiased;
}

/* --- COMPOSANTS --- */
/* En v4, @layer components fonctionne toujours */
@layer components {
  .btn-primary {
    @apply bg-primary text-primary-foreground font-bold py-2 px-4 rounded-lg shadow-sm transition-transform active:scale-95 hover:opacity-90;
  }
}
</file>

<file path="firestore.rules">
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    function isAuthenticated() {
      return request.auth != null;
    }
    
    function isAdmin() {
      return isAuthenticated() && exists(/databases/$(database)/documents/admins/$(request.auth.uid));
    }

    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    function isFriend(userId) {
      return exists(/databases/$(database)/documents/users/$(userId)/friends/$(request.auth.uid));
    }

    // --- R√àGLES GLOBALES ---

    match /admins/{userId} {
      allow read: if isAuthenticated();
      allow write: if false; 
    }

    match /app_feedback/{feedbackId} {
      allow read, update, delete: if isAdmin();
      allow create: if isAuthenticated() && request.resource.data.uid == request.auth.uid;
    }

    match /{path=**}/public_profile/{docId} {
      allow read: if isAuthenticated();
    }

    match /usernames/{username} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() 
                    && request.resource.data.uid == request.auth.uid
                    && !exists(/databases/$(database)/documents/usernames/$(username));
      allow update, delete: if false;
    }

    match /games/{gameId} {
        allow read: if isAuthenticated();
        allow create: if isAuthenticated(); 
    }

    // --- R√àGLES UTILISATEURS ---

    match /users/{userId} {
      // CHANGEMENT ICI :
      // allow read: if isAuthenticated(); -> Tout le monde peut voir les infos de base (pour le Panth√©on)
      // allow write: if isOwner(userId); -> Seul moi peut modifier mon profil
      allow read: if isAuthenticated();
      allow write: if isOwner(userId);

      // Ces sous-collections restent prot√©g√©es ou semi-publiques selon le besoin
      match /public_profile/info {
        allow read: if isAuthenticated();
        allow write: if isOwner(userId);
      }
      
      match /public_profile/stats {
        allow read: if isAuthenticated();
        allow write: if isOwner(userId) || isAdmin();
      }

      // Ancienne collection (compatibilit√©)
      match /collection/{cardId} {
        allow read: if isOwner(userId) || isFriend(userId); 
        allow write: if isOwner(userId);
      }

      match /wishlist/{cardId} {
        allow read: if isOwner(userId) || isFriend(userId); 
        allow write: if isOwner(userId);
      }

      // --- NOUVELLES R√àGLES POUR LES COLLECTIONS MULTIPLES ---
      match /collections_meta/{listId} {
        allow read: if isOwner(userId) || isFriend(userId);
        allow write: if isOwner(userId);
      }
      
      match /collections_data/{listId}/cards/{cardId} {
        allow read: if isOwner(userId) || isFriend(userId);
        allow write: if isOwner(userId);
      }
      // -------------------------------------------------------

      // --- NOUVELLES R√àGLES POUR LES WISHLISTS MULTIPLES ---
      match /wishlists_meta/{listId} {
        allow read: if isOwner(userId) || isFriend(userId);
        allow write: if isOwner(userId);
      }
      
      match /wishlists_data/{listId}/cards/{cardId} {
        allow read: if isOwner(userId) || isFriend(userId);
        allow write: if isOwner(userId);
      }
      // -----------------------------------------------------

      match /friends/{friendId} {
        allow read, write: if isOwner(userId);
        allow delete: if isOwner(userId) || request.auth.uid == friendId;
      }

      match /friend_requests_received/{senderId} {
        allow read: if isOwner(userId);
        allow write: if isAuthenticated() && request.resource.data.uid == request.auth.uid && request.auth.uid == senderId;
        allow delete: if isOwner(userId) || request.auth.uid == senderId;
      }
      
      match /notifications/{notifId} {
        allow create, write, delete: if isAdmin(); 
        allow read: if isOwner(userId); 
      }
    }

    match /trades/{tradeId} {
      allow read: if isAdmin() || (isAuthenticated() && (resource.data.senderUid == request.auth.uid || resource.data.receiverUid == request.auth.uid));
      allow create: if isAuthenticated() && request.resource.data.senderUid == request.auth.uid;
      allow delete: if isAdmin(); 
      allow update: if isAdmin() 
        || (
        isAuthenticated() 
        && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status'])
        && (
          (resource.data.senderUid == request.auth.uid && request.resource.data.status == 'cancelled') ||
          (resource.data.receiverUid == request.auth.uid && request.resource.data.status == 'rejected')
        )
      );
    }

    match /groups/{groupId} {
      allow read: if isAuthenticated() && request.auth.uid in resource.data.members;
      allow create: if isAuthenticated() && request.resource.data.ownerUid == request.auth.uid;
      allow update: if false; 
      allow delete: if isAuthenticated() && resource.data.ownerUid == request.auth.uid;
    }
    
    // --- R√àGLES DE CHAT ---
    match /chats/{chatId} {
      // Lecture autoris√©e si l'UID est dans le tableau participants
      allow read: if isAuthenticated() && request.auth.uid in resource.data.participants;
      
      match /messages/{messageId} {
        // Autorise la lecture si l'utilisateur est participant du chat PARENT
        allow read: if isAuthenticated() && 
          request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.participants;
        
        // Autorise l'√©criture si l'utilisateur est participant
        allow create: if isAuthenticated() && 
          request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.participants;
      }
    }
  }
}
</file>

<file path="lib/AuthContext.tsx">
'use client';

import { createContext, useContext, useEffect, useState, useMemo } from 'react';
import { 
  onAuthStateChanged, 
  signInWithPopup, 
  GoogleAuthProvider, 
  createUserWithEmailAndPassword,
  signInWithEmailAndPassword,
  signOut, 
  User,
  Unsubscribe,
  sendEmailVerification 
} from 'firebase/auth';
import { doc, onSnapshot, collection, getDoc, setDoc, serverTimestamp, updateDoc } from 'firebase/firestore'; 
import { auth, db } from './firebase'; 
import toast from 'react-hot-toast';
import { UserProfile } from '@/lib/types';

type AuthContextType = {
  user: User | null;
  userProfile: UserProfile | null;
  username: string | null;
  loading: boolean;
  friendRequestCount: number;
  isAdmin: boolean;
  signInWithGoogle: () => Promise<void>;
  signInWithEmail: (email: string, pass: string) => Promise<boolean>;
  signUpWithEmail: (email: string, pass: string) => Promise<boolean>;
  logOut: () => Promise<void>;
  sendVerificationEmail: () => Promise<boolean>;
  reloadUser: () => Promise<void>;
};

const AuthContext = createContext<AuthContextType>({
  user: null,
  userProfile: null,
  username: null,
  loading: true,
  friendRequestCount: 0,
  isAdmin: false,
  signInWithGoogle: async () => {},
  signInWithEmail: async () => false,
  signUpWithEmail: async () => false,
  logOut: async () => {},
  sendVerificationEmail: async () => false,
  reloadUser: async () => {},
});

const getErrorMessage = (code: string) => {
    switch (code) {
        case 'auth/email-already-in-use': return "Cet email est d√©j√† utilis√©.";
        case 'auth/invalid-email': return "Email invalide.";
        case 'auth/weak-password': return "Le mot de passe doit faire 6 caract√®res min.";
        case 'auth/user-not-found': return "Aucun compte avec cet email.";
        case 'auth/wrong-password': return "Mot de passe incorrect.";
        case 'auth/too-many-requests': return "Trop de tentatives. R√©essayez plus tard.";
        case 'auth/credential-already-in-use': return "Ce compte existe d√©j√†.";
        default: return "Erreur d'authentification.";
    }
};

export const useAuth = () => useContext(AuthContext);

export const AuthProvider = ({ children }: { children: React.ReactNode }) => {
  const [user, setUser] = useState<User | null>(null);
  const [userProfile, setUserProfile] = useState<UserProfile | null>(null);
  const [username, setUsername] = useState<string | null>(null);
  const [friendRequestCount, setFriendRequestCount] = useState(0);
  const [loading, setLoading] = useState(true);
  const [isAdmin, setIsAdmin] = useState(false);

  useEffect(() => {
    let unsubProfile: Unsubscribe | null = null;
    let unsubUserData: Unsubscribe | null = null;
    let unsubRequests: Unsubscribe | null = null;
    let unsubAdmin: Unsubscribe | null = null;

    const unsubscribeAuth = onAuthStateChanged(auth, async (currentUser) => {
      
      if (unsubProfile) { unsubProfile(); unsubProfile = null; }
      if (unsubUserData) { unsubUserData(); unsubUserData = null; }
      if (unsubRequests) { unsubRequests(); unsubRequests = null; }
      if (unsubAdmin) { unsubAdmin(); unsubAdmin = null; }

      setUser(currentUser);

      if (currentUser) {
        const userRef = doc(db, 'users', currentUser.uid);

        // --- Check & Reset Daily Credits ---
        const checkDailyCredits = async () => {
             try {
                 const userSnap = await getDoc(userRef);
                 
                 // Initialisation si nouveau user
                 if (!userSnap.exists()) {
                    await setDoc(userRef, {
                        uid: currentUser.uid,
                        email: currentUser.email,
                        displayName: currentUser.displayName,
                        photoURL: currentUser.photoURL,
                        createdAt: serverTimestamp(),
                        lastLogin: serverTimestamp(),
                        cardCount: 0,
                        isCollectionPublic: false,
                        isPremium: false,
                        dailyCredits: 5,
                        lastCreditReset: new Date().toISOString().split('T')[0]
                    }, { merge: true });
                    return; // Le listener prendra le relais
                 }

                 // Logique de reset
                 const data = userSnap.data() as UserProfile;
                 const todayStr = new Date().toISOString().split('T')[0];
                 
                 // Si pas premium et nouvelle journ√©e => Reset
                 if (!data.isPremium && data.lastCreditReset !== todayStr) {
                     await updateDoc(userRef, {
                         dailyCredits: 5,
                         lastCreditReset: todayStr
                     });
                 }
             } catch (err) {
                 console.error("Erreur checkDailyCredits:", err);
             }
        };
        
        // On lance la v√©rification sans bloquer le reste
        checkDailyCredits();

        // --- Listeners ---

        // 1. User Data (Credits, Premium)
        unsubUserData = onSnapshot(userRef, (docSnap) => {
            if (docSnap.exists()) {
                setUserProfile(docSnap.data() as UserProfile);
            }
        });

        // 2. Admin Check
        const adminRef = doc(db, 'admins', currentUser.uid);
        unsubAdmin = onSnapshot(adminRef, (docSnap) => {
            setIsAdmin(docSnap.exists());
        }, (error) => {
            console.error("Erreur v√©rification admin:", error);
            setIsAdmin(false);
        });

        // 3. Public Profile
        const profileRef = doc(db, 'users', currentUser.uid, 'public_profile', 'info');
        unsubProfile = onSnapshot(profileRef, (docSnap) => {
          if (docSnap.exists()) {
            setUsername(docSnap.data().username as string);
          } else {
            setUsername(null);
          }
          setLoading(false);
        }, () => {
            setLoading(false);
        });

        // 4. Friend Requests
        const requestsRef = collection(db, 'users', currentUser.uid, 'friend_requests_received');
        unsubRequests = onSnapshot(requestsRef, (snap) => {
          setFriendRequestCount(snap.docs.length);
        }, (error) => {
          console.error("Erreur listener requests:", error);
        });

      } else {
        setUserProfile(null);
        setUsername(null);
        setFriendRequestCount(0);
        setIsAdmin(false);
        setLoading(false);
      }
    });

    return () => {
      unsubscribeAuth();
      if (unsubProfile) unsubProfile();
      if (unsubUserData) unsubUserData();
      if (unsubRequests) unsubRequests();
      if (unsubAdmin) unsubAdmin();
    };
  }, []);

  const signInWithGoogle = async () => {
    try {
      const provider = new GoogleAuthProvider();
      await signInWithPopup(auth, provider);
      toast.success('Connexion Google r√©ussie !');
    } catch (error: unknown) {
      if (error && typeof error === 'object' && 'code' in error) {
          const firebaseError = error as { code: string };
          if (firebaseError.code === 'auth/cancelled-popup-request' || 
              firebaseError.code === 'auth/popup-closed-by-user') {
              return; 
          }
      }
      console.error(error);
      toast.error("Erreur connexion Google");
    }
  };

  const signInWithEmail = async (email: string, pass: string) => {
    try {
        await signInWithEmailAndPassword(auth, email, pass);
        toast.success("Bon retour !");
        return true;
    } catch (error: unknown) {
        console.error(error);
        let msg = "Erreur connexion";
        if (error && typeof error === 'object' && 'code' in error) {
            msg = getErrorMessage((error as { code: string }).code);
        }
        toast.error(msg);
        return false;
    }
  };

  const signUpWithEmail = async (email: string, pass: string) => {
    try {
        const userCred = await createUserWithEmailAndPassword(auth, email, pass);
        toast.success("Compte cr√©√© avec succ√®s !");
        
        if (userCred.user) {
            try {
                await sendEmailVerification(userCred.user);
                toast("Un email de v√©rification a √©t√© envoy√©.");
            } catch (err) {
                console.warn("Erreur envoi email v√©rif auto", err);
            }
        }

        return true;
    } catch (error: unknown) {
        console.error(error);
        let msg = "Erreur inscription";
        if (error && typeof error === 'object' && 'code' in error) {
            msg = getErrorMessage((error as { code: string }).code);
        }
        toast.error(msg);
        return false;
    }
  };

  const logOut = async () => {
    try {
      await signOut(auth);
      toast.success('D√©connect√©');
    } catch (error) {
      console.error(error);
      toast.error("Erreur d√©connexion");
    }
  };

  const sendVerificationEmail = async () => {
    if (!auth.currentUser) return false;
    try {
        await sendEmailVerification(auth.currentUser);
        toast.success("Email envoy√© ! V√©rifiez vos spams.");
        return true;
    } catch (e) {
        console.error(e);
        toast.error("Erreur lors de l'envoi.");
        return false;
    }
  };

  const reloadUser = async () => {
    if (!auth.currentUser) return;
    try {
        await auth.currentUser.reload();
        setUser({ ...auth.currentUser });
        
        if (auth.currentUser.emailVerified) {
            toast.success("Compte v√©rifi√© !");
        } else {
            toast("Email toujours non v√©rifi√©.");
        }
    } catch (e) {
        console.error(e);
    }
  };

  const value = useMemo(() => ({
    user,
    userProfile,
    username,
    friendRequestCount,
    loading,
    isAdmin,
    signInWithGoogle,
    signInWithEmail,
    signUpWithEmail,
    logOut,
    sendVerificationEmail,
    reloadUser
  }), [user, userProfile, username, loading, friendRequestCount, isAdmin]);

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
};
</file>

<file path="package.json">
{
  "name": "magicwish",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "eslint"
  },
  "dependencies": {
    "@types/papaparse": "^5.5.1",
    "axios": "^1.13.2",
    "canvas": "^3.2.0",
    "firebase": "^12.5.0",
    "firebase-admin": "^13.6.0",
    "lucide-react": "^0.562.0",
    "next": "^16.0.8",
    "next-themes": "^0.4.6",
    "papaparse": "^5.5.3",
    "react": "^19.2.1",
    "react-dom": "^19.2.1",
    "react-hot-toast": "^2.6.0",
    "react-webcam": "^7.2.0",
    "stripe": "^20.0.0",
    "tesseract.js": "^7.0.0",
    "zod": "^4.1.13"
  },
  "devDependencies": {
    "@tailwindcss/postcss": "^4",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "babel-plugin-react-compiler": "1.0.0",
    "eslint": "^9",
    "eslint-config-next": "16.0.3",
    "tailwindcss": "^4",
    "typescript": "^5"
  }
}
</file>

<file path="app/trades/new/[uid]/page.tsx">
// app/trades/new/[uid]/page.tsx
'use client';

import { useState, use, useEffect, useMemo } from 'react'; // useTransition retir√©
import { useAuth } from '@/lib/AuthContext';
import { useCardCollection, CardType } from '@/hooks/useCardCollection';
import { useTradeSystem } from '@/hooks/useTradeSystem';
import { db } from '@/lib/firebase';
import { doc, getDoc } from 'firebase/firestore';
import { useRouter } from 'next/navigation';
import toast from 'react-hot-toast';
import MagicCard from '@/components/MagicCard';
import Image from 'next/image'; // Import pour optimisation image

// --- TABLEAU DE S√âLECTION (Panier - Haut) ---
const TradeSelectionTable = ({ 
    cards, 
    onRemove, 
    onUpdatePrice, 
    onUpdateQuantity,
    getMaxQuantity,
    colorClass, 
    emptyLabel,
    onCardClick
}: { 
    cards: CardType[], 
    onRemove: (id: string) => void, 
    onUpdatePrice: (id: string, price: number) => void,
    onUpdateQuantity: (id: string, delta: number) => void,
    getMaxQuantity: (id: string) => number,
    colorClass: 'text-danger' | 'text-success',
    emptyLabel: string,
    onCardClick: (card: CardType) => void
}) => {
    if (cards.length === 0) return <div className="flex-1 flex items-center justify-center border-b border-border bg-secondary/10 text-muted text-sm italic p-8">{emptyLabel}</div>;

    return (
        <div className="flex-1 overflow-hidden flex flex-col bg-surface border-b border-border shadow-sm">
            <div className="overflow-y-auto custom-scrollbar flex-1">
                <table className="w-full text-xs text-left border-collapse">
                    <thead className="bg-secondary text-muted sticky top-0 z-10 font-semibold uppercase">
                        <tr>
                            <th className="px-2 py-2 text-center w-24">Qt√©</th>
                            <th className="px-2 py-2">Nom</th>
                            <th className="px-2 py-2 w-10 text-center">Set</th>
                            <th className="px-2 py-2 w-10 text-center">Foil</th>
                            <th className="px-2 py-2 text-right w-16">Prix</th>
                            <th className="px-2 py-2 w-8"></th>
                        </tr>
                    </thead>
                    <tbody className="divide-y divide-border">
                        {cards.map((card, i) => {
                            const currentPrice = card.customPrice !== undefined ? card.customPrice : (card.price || 0);
                            const maxQty = getMaxQuantity(card.id);
                            const isMaxReached = card.quantity >= maxQty;
                            const isMinReached = card.quantity <= 1;

                            return (
                                <tr 
                                    key={`${card.id}-${i}`} 
                                    className="hover:bg-secondary/50 transition-colors text-foreground select-none cursor-pointer"
                                    onClick={() => onCardClick(card)}
                                >
                                    <td className="px-2 py-1.5 text-center">
                                        <div className={`flex items-center justify-center gap-1 bg-background/50 rounded border border-border p-0.5 ${colorClass}`} onClick={e => e.stopPropagation()}>
                                            <button 
                                                onClick={() => onUpdateQuantity(card.id, -1)} 
                                                disabled={isMinReached}
                                                className="w-5 h-5 flex items-center justify-center bg-surface hover:bg-secondary rounded text-xs font-bold disabled:opacity-30 transition-colors border border-border"
                                            >
                                                -
                                            </button>
                                            <span className="font-mono font-bold w-8 text-center text-[10px]">
                                                {card.quantity}
                                                <span className="opacity-50 font-normal">/{maxQty}</span>
                                            </span>
                                            <button 
                                                onClick={() => onUpdateQuantity(card.id, 1)} 
                                                disabled={isMaxReached}
                                                className="w-5 h-5 flex items-center justify-center bg-surface hover:bg-secondary rounded text-xs font-bold disabled:opacity-30 transition-colors border border-border"
                                            >
                                                +
                                            </button>
                                        </div>
                                    </td>
                                    <td className="px-2 py-1.5 font-medium truncate max-w-[120px]" title={card.name}>{card.name}</td>
                                    <td className="px-2 py-1.5 text-center"><span className="text-[9px] font-mono bg-secondary text-muted px-1 rounded border border-border">{card.setCode?.toUpperCase()}</span></td>
                                    <td className="px-2 py-1.5 text-center">{card.isFoil && <span className="text-[9px] font-bold text-amber-600 bg-amber-100 px-1 rounded">Foil</span>}</td>
                                    <td className="px-2 py-1.5 text-right">
                                        <div className="flex items-center justify-end gap-1" onClick={e => e.stopPropagation()}>
                                            <input 
                                                type="number" min="0" step="0.01"
                                                className="w-14 p-1 text-right bg-background border border-border rounded text-xs outline-none focus:border-primary [appearance:textfield] [&::-webkit-outer-spin-button]:appearance-none [&::-webkit-inner-spin-button]:appearance-none"
                                                value={currentPrice}
                                                onChange={(e) => onUpdatePrice(card.id, parseFloat(e.target.value) || 0)}
                                            />
                                            <span className="text-muted">‚Ç¨</span>
                                        </div>
                                    </td>
                                    <td className="px-2 py-1.5 text-center">
                                        <button onClick={(e) => { e.stopPropagation(); onRemove(card.id); }} className="text-muted hover:text-danger transition px-1 font-bold">‚úï</button>
                                    </td>
                                </tr>
                            );
                        })}
                    </tbody>
                </table>
            </div>
        </div>
    );
};

// --- TABLEAU SOURCE (Recherche - Bas) ---
const TradeSourceTable = ({ cards, onAdd, buttonColorClass, loading }: { cards: CardType[], onAdd: (c: CardType) => void, buttonColorClass: 'text-danger' | 'text-success', loading?: boolean }) => {
    if (loading) return <p className="text-xs text-muted text-center py-4">Chargement...</p>;
    if (cards.length === 0) return null;
    
    return (
        <div className="overflow-y-auto custom-scrollbar bg-surface border-t border-border max-h-[300px]">
            <table className="w-full text-xs text-left border-collapse">
                <tbody className="divide-y divide-border">
                    {cards.map((item, i) => {
                        return (
                            <tr key={`${item.id}-${i}`} className="hover:bg-secondary/50 transition-colors text-foreground cursor-pointer group select-none" onClick={() => onAdd(item)}>
                                <td className="px-2 py-1.5 text-center text-muted font-mono">+</td>
                                <td className="px-2 py-1.5 font-medium truncate" title={item.name}>{item.name}</td>
                                <td className="px-2 py-1.5 text-center text-muted italic" colSpan={3}>
                                    Cliquez pour choisir une version
                                </td>
                                <td className="px-2 py-1.5 text-center">
                                    <button className={`${buttonColorClass} font-bold hover:scale-125 transition-transform`}>+</button>
                                </td>
                            </tr>
                        );
                    })}
                </tbody>
            </table>
        </div>
    );
};

// --- MODALE DE S√âLECTION COLLECTION ---
const CollectionPickerModal = ({ 
    isOpen, 
    onClose, 
    cardName, 
    matchingCards, 
    onConfirm 
}: { 
    isOpen: boolean;
    onClose: () => void;
    cardName: string;
    matchingCards: CardType[];
    onConfirm: (card: CardType) => void;
}) => {
    if (!isOpen) return null;

    return (
        <div className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black/50 backdrop-blur-sm animate-in fade-in">
            <div className="bg-surface border border-border rounded-xl shadow-2xl w-full max-w-lg overflow-hidden flex flex-col max-h-[80vh]">
                <div className="p-4 border-b border-border flex justify-between items-center bg-secondary/30">
                    <h3 className="font-bold text-lg text-foreground">S√©lectionner une version</h3>
                    <button onClick={onClose} className="text-muted hover:text-foreground">‚úï</button>
                </div>
                
                <div className="p-4 overflow-y-auto custom-scrollbar space-y-2">
                    <p className="text-sm text-muted mb-2">Versions disponibles pour <strong>{cardName}</strong> :</p>
                    {matchingCards.length === 0 ? (
                        <p className="text-center text-muted italic">Aucune carte correspondante trouv√©e avec les filtres actuels.</p>
                    ) : (
                        <div className="grid gap-2">
                            {matchingCards.map(card => (
                                <div 
                                    key={card.id} 
                                    onClick={() => { onConfirm(card); onClose(); }}
                                    className="flex items-center gap-3 p-2 rounded-lg border border-border hover:border-primary cursor-pointer hover:bg-primary/5 transition-all group"
                                >
                                    <div className="w-10 h-14 bg-black/10 rounded overflow-hidden shrink-0 relative">
                                        {/* Utilisation de next/image pour l'optimisation */}
                                        <Image 
                                            src={card.imageUrl} 
                                            alt={card.name} 
                                            fill
                                            className="object-cover"
                                            sizes="40px" // Indique au navigateur que c'est une petite image
                                        />
                                    </div>
                                    <div className="grow">
                                        <div className="flex items-center gap-2">
                                            <span className="font-bold text-sm text-foreground">{card.name}</span>
                                            {card.isFoil && <span className="text-[10px] font-bold bg-amber-100 text-amber-700 px-1.5 rounded border border-amber-200">Foil</span>}
                                        </div>
                                        <div className="flex items-center gap-2 text-xs text-muted mt-0.5">
                                            <span className="bg-secondary px-1.5 rounded text-foreground border border-border font-mono">{card.setName}</span>
                                            <span>‚Ä¢</span>
                                            <span>Stock: <strong className="text-foreground">{card.quantity}</strong></span>
                                            {card.quantityForTrade !== undefined && (
                                                <span>(Trade: {card.quantityForTrade})</span>
                                            )}
                                        </div>
                                    </div>
                                    <button className="bg-primary text-primary-foreground px-3 py-1.5 rounded text-xs font-bold opacity-0 group-hover:opacity-100 transition-opacity">
                                        Choisir
                                    </button>
                                </div>
                            ))}
                        </div>
                    )}
                </div>
            </div>
        </div>
    );
};

// --- PAGE PRINCIPALE ---

export default function DirectTradePage({ params }: { params: Promise<{ uid: string }> }) {
    const unwrappedParams = use(params);
    const targetUid = unwrappedParams.uid;

    const { user } = useAuth();
    const router = useRouter();
    const { proposeTrade } = useTradeSystem();

    // --- CHARGEMENT ---
    const { cards: myCollection, loading: loadingMe } = useCardCollection('collection');
    const { cards: friendCollection, loading: loadingHim } = useCardCollection('collection', 'default', targetUid);

    // --- √âTATS ---
    const [targetName, setTargetName] = useState('L\'ami');
    const [toGive, setToGive] = useState<CardType[]>([]);
    const [toReceive, setToReceive] = useState<CardType[]>([]);
    const [searchMe, setSearchMe] = useState('');
    const [searchHim, setSearchHim] = useState('');
    
    // Privacy & Toggles
    const [partnerAllowsFull, setPartnerAllowsFull] = useState(false);
    const [showMyFull, setShowMyFull] = useState(false);
    const [showPartnerFull, setShowPartnerFull] = useState(false);

    // Modales & Preview
    const [previewCard, setPreviewCard] = useState<CardType | null>(null);
    const [pickerOpen, setPickerOpen] = useState(false);
    const [pickerSource, setPickerSource] = useState<'me' | 'him'>('me');
    const [pickerName, setPickerName] = useState('');

    // Chargement infos partenaire (Nom + Settings Privacy)
    useEffect(() => {
        const fetchInfo = async () => {
            try {
                const snap = await getDoc(doc(db, 'users', targetUid, 'public_profile', 'info'));
                if(snap.exists()) {
                    const data = snap.data();
                    setTargetName(data.displayName || data.username || 'L\'ami');
                    setPartnerAllowsFull(data.allowFullCollectionInTrade === true);
                }
            } catch(e) { console.error(e); }
        };
        if (targetUid) fetchInfo();
    }, [targetUid]);

    // S√©curit√© : Si le partenaire coupe l'acc√®s, on d√©sactive la vue full
    useEffect(() => {
        // eslint-disable-next-line react-hooks/set-state-in-effect
        if (!partnerAllowsFull) setShowPartnerFull(false);
    }, [partnerAllowsFull]);

    // --- LOGIQUE FILTRAGE (Accessible collections) ---
    const accessibleMyCollection = useMemo(() => {
        if (showMyFull) return myCollection;
        return myCollection.filter(c => (c.quantityForTrade || 0) > 0);
    }, [myCollection, showMyFull]);

    const accessibleFriendCollection = useMemo(() => {
        if (showPartnerFull) return friendCollection;
        return friendCollection.filter(c => (c.quantityForTrade || 0) > 0);
    }, [friendCollection, showPartnerFull]);

    // --- LOGIQUE RECHERCHE (Noms Uniques) ---
    const mySearchResults = useMemo(() => {
        if (!searchMe.trim()) return [];
        const lower = searchMe.toLowerCase();
        const matches = accessibleMyCollection.filter(c => c.name.toLowerCase().includes(lower));
        const uniqueNames = Array.from(new Set(matches.map(c => c.name))).slice(0, 10);
        return uniqueNames.map(name => matches.find(c => c.name === name)!);
    }, [accessibleMyCollection, searchMe]);

    const friendSearchResults = useMemo(() => {
        if (!searchHim.trim()) return [];
        const lower = searchHim.toLowerCase();
        const matches = accessibleFriendCollection.filter(c => c.name.toLowerCase().includes(lower));
        const uniqueNames = Array.from(new Set(matches.map(c => c.name))).slice(0, 10);
        return uniqueNames.map(name => matches.find(c => c.name === name)!);
    }, [accessibleFriendCollection, searchHim]);

    // --- LOGIQUE PICKER (Contenu Modale) ---
    const matchingCardsForPicker = useMemo(() => {
        if (!pickerName) return [];
        const source = pickerSource === 'me' ? accessibleMyCollection : accessibleFriendCollection;
        return source.filter(c => c.name === pickerName);
    }, [pickerName, pickerSource, accessibleMyCollection, accessibleFriendCollection]);

    // --- ACTIONS ---

    // 1. Ouvrir le picker
    const openPicker = (card: CardType, source: 'me' | 'him') => {
        setPickerName(card.name);
        setPickerSource(source);
        setPickerOpen(true);
    };

    // 2. Confirmer ajout depuis picker
    const confirmAdd = (card: CardType) => {
        const isMe = pickerSource === 'me';
        const setTarget = isMe ? setToGive : setToReceive;
        const targetList = isMe ? toGive : toReceive;
        
        // Check existant
        const existing = targetList.find(c => c.id === card.id);
        
        // Check stock max
        const isFullView = isMe ? showMyFull : showPartnerFull;
        const maxStock = isFullView ? card.quantity : (card.quantityForTrade || 0);

        if (existing) {
            if (existing.quantity < maxStock) {
                setTarget(prev => prev.map(c => c.id === card.id ? { ...c, quantity: c.quantity + 1 } : c));
                toast.success("+1 ajout√©");
            } else {
                toast.error("Stock max atteint");
            }
        } else {
            // Ajout nouvelle ligne
            setTarget(prev => [...prev, { ...card, quantity: 1, customPrice: card.price }]);
            toast.success("Carte ajout√©e");
        }
        
        setPickerOpen(false);
        if (isMe) setSearchMe(''); else setSearchHim('');
    };

    // 3. Update Quantit√© (+/-)
    const handleUpdateQuantity = (cardId: string, delta: number, listType: 'give' | 'receive') => {
        const setTarget = listType === 'give' ? setToGive : setToReceive;
        const isMe = listType === 'give';

        setTarget(prev => prev.map(c => {
            if (c.id !== cardId) return c;
            const newQty = c.quantity + delta;
            
            if (newQty < 1) return c; // Pas de suppression, utiliser croix

            // Recalcul du max stock en direct
            const sourceCol = isMe ? accessibleMyCollection : accessibleFriendCollection;
            const sourceCard = sourceCol.find(sc => sc.id === cardId);
            // Si on ne trouve pas la carte source (cas rare de changement de filtre), on bloque pas forc√©ment
            const max = sourceCard ? (isMe && showMyFull ? sourceCard.quantity : (sourceCard?.quantityForTrade || 0)) : 999;
            
            if (newQty > max) {
                toast.error("Stock maximum atteint");
                return c;
            }
            return { ...c, quantity: newQty };
        }));
    };
    
    // 4. Update Prix
    const handleUpdatePrice = (cardId: string, newPrice: number, listType: 'give' | 'receive') => {
        const setTarget = listType === 'give' ? setToGive : setToReceive;
        setTarget(prev => prev.map(c => c.id === cardId ? { ...c, customPrice: newPrice } : c));
    };

    // 5. Remove
    const handleRemoveCard = (cardId: string, listType: 'give' | 'receive') => {
        const setTarget = listType === 'give' ? setToGive : setToReceive;
        setTarget(prev => prev.filter(c => c.id !== cardId));
    };

    // 6. Helper pour le Max Quantity dans le tableau
    const getMaxStockDisplay = (cardId: string, isMe: boolean) => {
        const sourceCol = isMe ? myCollection : friendCollection;
        const isFull = isMe ? showMyFull : showPartnerFull;
        const c = sourceCol.find(x => x.id === cardId);
        if (!c) return 0;
        return isFull ? c.quantity : (c.quantityForTrade || 0);
    };

    // 7. Proposer
    const handlePropose = async () => {
        if (toGive.length === 0 && toReceive.length === 0) return;
        const success = await proposeTrade(targetUid, targetName, toGive, toReceive);
        if (success) router.push('/trades'); 
    };

    // Calculs Totaux
    const valGive = toGive.reduce((acc, c) => acc + (c.customPrice ?? c.price ?? 0) * c.quantity, 0);
    const valReceive = toReceive.reduce((acc, c) => acc + (c.customPrice ?? c.price ?? 0) * c.quantity, 0);
    const balance = valGive - valReceive;

    if (!user) return <div className="p-10 text-center text-muted">Connexion requise.</div>;

    return (
        <div className="container mx-auto p-4 h-[calc(100vh-64px)] flex flex-col">
            
            {/* HEADER */}
            <div className="flex-none flex items-center gap-4 mb-4">
                <button onClick={() => router.back()} className="text-muted hover:text-foreground bg-secondary px-3 py-1 rounded-lg text-sm">
                    ‚Üê Retour
                </button>
                <h1 className="text-2xl font-bold truncate text-foreground">
                    √âchange avec <span className="text-primary">{targetName}</span>
                </h1>
            </div>

            {/* GRILLE PRINCIPALE */}
            <div className="grid lg:grid-cols-2 gap-6 grow overflow-hidden pb-24">
                
                {/* COLONNE GAUCHE (MOI) */}
                <div className="flex flex-col h-full bg-danger/5 rounded-xl border border-danger/20 overflow-hidden relative shadow-sm">
                    <div className="p-4 pb-0 flex-none space-y-2">
                        
                        <div className="flex justify-between items-center">
                            <h2 className="font-bold text-danger">üì§ Je donne</h2>
                            <label className="flex items-center gap-2 cursor-pointer select-none">
                                <input 
                                    type="checkbox" 
                                    className="w-3.5 h-3.5 text-danger rounded border-danger/30 focus:ring-danger accent-danger"
                                    checked={showMyFull}
                                    onChange={(e) => setShowMyFull(e.target.checked)}
                                />
                                <span className="text-[10px] font-semibold text-danger/80 hover:text-danger">
                                    Tout voir
                                </span>
                            </label>
                        </div>

                        <input 
                            type="text" 
                            placeholder="Filtrer ma collection..." 
                            className="w-full p-2 mb-2 rounded border border-border bg-background text-foreground text-sm focus:ring-2 focus:ring-danger/30 outline-none"
                            value={searchMe}
                            onChange={e => setSearchMe(e.target.value)}
                        />
                    </div>
                    
                    <TradeSelectionTable 
                        cards={toGive} 
                        onRemove={(id) => handleRemoveCard(id, 'give')} 
                        onUpdatePrice={(id, p) => handleUpdatePrice(id, p, 'give')}
                        onUpdateQuantity={(id, d) => handleUpdateQuantity(id, d, 'give')}
                        getMaxQuantity={(id) => getMaxStockDisplay(id, true)}
                        colorClass="text-danger" 
                        emptyLabel="Recherchez vos cartes ci-dessus..." 
                        onCardClick={setPreviewCard}
                    />

                    <div className="flex-none bg-danger/10 p-2 border-t border-danger/20 text-center">
                        <span className="text-xs text-danger font-bold uppercase">Total : {valGive.toFixed(2)} ‚Ç¨</span>
                    </div>

                    {/* R√âSULTATS DE RECHERCHE (NOMS UNIQUES) */}
                    {searchMe && (
                        <TradeSourceTable 
                            cards={mySearchResults} 
                            onAdd={(c) => openPicker(c, 'me')} 
                            buttonColorClass="text-danger" 
                            loading={loadingMe} 
                        />
                    )}
                </div>

                {/* COLONNE DROITE (AMI) */}
                <div className="flex flex-col h-full bg-success/5 rounded-xl border border-success/20 overflow-hidden relative shadow-sm">
                    <div className="p-4 pb-0 flex-none space-y-2">
                        
                        <div className="flex justify-between items-center">
                            <h2 className="font-bold text-success">Je re√ßois</h2>
                            
                            {partnerAllowsFull ? (
                                <label className="flex items-center gap-2 cursor-pointer select-none">
                                    <input 
                                        type="checkbox" 
                                        className="w-3.5 h-3.5 text-success rounded border-success/30 focus:ring-success accent-success"
                                        checked={showPartnerFull}
                                        onChange={(e) => setShowPartnerFull(e.target.checked)}
                                    />
                                    <span className="text-[10px] font-semibold text-success/80 hover:text-success">
                                        Tout voir
                                    </span>
                                </label>
                            ) : (
                                <span className="text-[10px] text-muted italic flex items-center gap-1">
                                    Trade binder uniquement
                                </span>
                            )}
                        </div>

                        <input 
                            type="text" 
                            placeholder={`Filtrer chez ${targetName}...`}
                            className="w-full p-2 mb-2 rounded border border-border bg-background text-foreground text-sm focus:ring-2 focus:ring-success/30 outline-none"
                            value={searchHim}
                            onChange={e => setSearchHim(e.target.value)}
                        />
                    </div>

                    <TradeSelectionTable 
                        cards={toReceive} 
                        onRemove={(id) => handleRemoveCard(id, 'receive')} 
                        onUpdatePrice={(id, p) => handleUpdatePrice(id, p, 'receive')}
                        onUpdateQuantity={(id, d) => handleUpdateQuantity(id, d, 'receive')}
                        getMaxQuantity={(id) => getMaxStockDisplay(id, false)}
                        colorClass="text-success" 
                        emptyLabel={`S√©lectionnez les cartes de ${targetName} en bas...`} 
                        onCardClick={setPreviewCard}
                    />

                    <div className="flex-none bg-success/10 p-2 border-t border-success/20 text-center">
                        <span className="text-xs text-success font-bold uppercase">Total : {valReceive.toFixed(2)} ‚Ç¨</span>
                    </div>

                    {/* R√âSULTATS DE RECHERCHE (NOMS UNIQUES) */}
                    {searchHim && (
                        <TradeSourceTable 
                            cards={friendSearchResults} 
                            onAdd={(c) => openPicker(c, 'him')} 
                            buttonColorClass="text-success" 
                            loading={loadingHim} 
                        />
                    )}
                </div>
            </div>

            {/* FOOTER */}
            <div className="fixed bottom-0 left-0 right-0 h-20 bg-surface border-t border-border flex items-center px-6 z-40 shadow-[0_-4px_6px_-1px_rgba(0,0,0,0.1)]">
                <div className="flex-1"></div>
                <div className="flex-1 flex flex-col items-center justify-center">
                    <span className="text-xs text-muted font-bold uppercase tracking-widest">Balance Estim√©e</span>
                    <div className={`text-2xl font-black ${balance >= 0 ? 'text-success' : 'text-danger'}`}>
                        {balance > 0 ? '+' : ''}{balance.toFixed(2)} ‚Ç¨
                    </div>
                </div>
                <div className="flex-1 flex justify-end">
                    <button 
                        onClick={handlePropose}
                        disabled={toGive.length === 0 && toReceive.length === 0}
                        className="bg-primary hover:opacity-90 text-primary-foreground px-8 py-3 rounded-xl font-bold disabled:opacity-50 transition shadow-lg transform active:scale-95 flex items-center gap-2"
                    >
                        Proposer
                    </button>
                </div>
            </div>

            {/* MODALES */}
            
            {/* 1. Picker de Collection */}
            <CollectionPickerModal 
                isOpen={pickerOpen} 
                onClose={() => setPickerOpen(false)} 
                cardName={pickerName} 
                matchingCards={matchingCardsForPicker} 
                onConfirm={confirmAdd}
            />

            {/* 2. Pr√©visualisation */}
            {previewCard && (
                <div 
                    className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black/60 backdrop-blur-sm animate-in fade-in cursor-pointer"
                    onClick={() => setPreviewCard(null)}
                >
                    <div className="relative transform transition-all scale-100 p-4" onClick={e => e.stopPropagation()}>
                        <button 
                            onClick={() => setPreviewCard(null)} 
                            className="absolute -top-2 -right-2 bg-surface text-foreground rounded-full p-2 shadow-lg z-10 border border-border hover:bg-secondary transition-colors"
                        >
                            ‚úï
                        </button>
                        <div className="w-[300px] h-[420px] shadow-2xl rounded-xl overflow-hidden pointer-events-none">
                            {/* AJOUT DE HIDEFOOTER ICI */}
                            <MagicCard {...previewCard} readOnly={true} quantity={previewCard.quantity} hideFooter={true} />
                        </div>
                    </div>
                </div>
            )}

        </div>
    );
}
</file>

<file path="app/user/[uid]/page.tsx">
// app/user/[uid]/page.tsx
'use client';

import { useState, use, useEffect, useMemo } from 'react';
import { useAuth } from '@/lib/AuthContext';
import { useCardCollection, CardType } from '@/hooks/useCardCollection';
import { db } from '@/lib/firebase';
import { doc, getDoc, collection, onSnapshot } from 'firebase/firestore';
import { WishlistMeta } from '@/hooks/useWishlists';
import { useColumnPreference } from '@/hooks/useColumnPreference';
import { useSortPreference, SortOption } from '@/hooks/useSortPreference';
import Image from 'next/image';

// Composants
import FriendCollectionDisplay from '@/components/user-profile/FriendCollectionDisplay';
import FriendWishlistDisplay from '@/components/user-profile/FriendWishlistDisplay';

type UserProfile = {
    username: string;
    displayName: string;
    photoURL?: string;
    bio?: string;
};

export default function UserProfilePage({ params }: { params: Promise<{ uid: string }> }) {
    const unwrappedParams = use(params);
    const targetUid = unwrappedParams.uid;
    const { user, loading: authLoading } = useAuth();

    // --- CHARGEMENT DONN√âES AMI ---
    const { cards: friendCollectionCards, loading: loadingCollection, totalPrice: collectionTotal } = useCardCollection('collection', 'default', targetUid);
    
    const [profile, setProfile] = useState<UserProfile | null>(null);
    const [wishlistsMeta, setWishlistsMeta] = useState<WishlistMeta[]>([]);
    const [loadingMeta, setLoadingMeta] = useState(true);
    
    // --- √âTATS UI ---
    const [activeTab, setActiveTab] = useState<'collection' | 'wishlist'>('collection');
    
    // --- CHARGEMENT DONN√âES PERSO (Pour le matching) ---
    const { cards: myWishlistCards } = useCardCollection('wishlist', 'default', user?.uid);
    const { cards: myTradeCards } = useCardCollection('collection', 'default', user?.uid);

    const myWishlistMap = useMemo(() => {
        const map = new Map<string, CardType>();
        myWishlistCards.forEach(c => {
            map.set(c.id, c);
            if (!c.isSpecificVersion) map.set(c.name.toLowerCase(), c);
        });
        return map;
    }, [myWishlistCards]);

    const myTradeBinderMap = useMemo(() => {
        const map = new Map<string, CardType>();
        myTradeCards.filter(c => (c.quantityForTrade || 0) > 0).forEach(c => {
            map.set(c.id, c);
            if (!c.isSpecificVersion) map.set(c.name.toLowerCase(), c);
        });
        return map;
    }, [myTradeCards]);

    // --- PR√âF√âRENCES UTILISATEUR ---
    const { columns: colColumns, setColumns: setColColumns } = useColumnPreference('mw_cols_friend_col', 5);
    const { columns: wishColumns, setColumns: setWishColumns } = useColumnPreference('mw_cols_friend_wish', 5);
    const { sortBy: colSortBy, setSortBy: setColSortBy } = useSortPreference('mw_sort_friend_col', 'date_desc' as SortOption);

    useEffect(() => {
        const fetchProfile = async () => {
            if (!targetUid) return;
            try {
                const profileSnap = await getDoc(doc(db, 'users', targetUid, 'public_profile', 'info'));
                if (profileSnap.exists()) setProfile(profileSnap.data() as UserProfile);
            } catch (e) {
                console.error("Erreur profil", e);
            }
        };
        fetchProfile();
    }, [targetUid]);

    useEffect(() => {
        if (!targetUid) return;
        // eslint-disable-next-line react-hooks/set-state-in-effect
        setLoadingMeta(true);
        const unsubscribe = onSnapshot(collection(db, 'users', targetUid, 'wishlists_meta'), (snapshot) => {
            const fetchedLists = snapshot.docs.map(d => ({ id: d.id, ...d.data() } as WishlistMeta));
            if (!fetchedLists.find(l => l.id === 'default')) fetchedLists.unshift({ id: 'default', name: 'Liste principale' });
            fetchedLists.sort((a, b) => a.id === 'default' ? -1 : b.id === 'default' ? 1 : a.name.localeCompare(b.name));
            setWishlistsMeta(fetchedLists);
            setLoadingMeta(false);
        }, (error) => {
            console.error("Erreur meta", error);
            setLoadingMeta(false);
        });
        return () => unsubscribe();
    }, [targetUid]);

    if (!profile && loadingCollection && loadingMeta || authLoading) return <div className="p-10 text-center text-muted font-bold animate-pulse uppercase text-xs">Chargement du profil...</div>;
    if (!user) return <div className="p-10 text-center text-muted font-bold uppercase text-xs">Veuillez vous connecter.</div>;

    return (
        <main className="container mx-auto p-4 pb-20">
            <div className="bg-surface rounded-2xl p-6 shadow-sm border border-border mb-6 flex flex-col md:flex-row items-center md:items-start gap-6">
                <div className="w-24 h-24 rounded-full bg-primary flex items-center justify-center text-white text-3xl font-black border-4 border-surface shadow-md overflow-hidden relative">
                    {profile?.photoURL ? <Image src={profile.photoURL} alt="Avatar" fill className="object-cover" sizes="96px" /> : profile?.username?.[0]?.toUpperCase()}
                </div>
                <div className="text-center md:text-left grow">
                    <h1 className="text-3xl font-black text-foreground mb-1 uppercase tracking-tighter">{profile?.displayName || 'Utilisateur'}</h1>
                    <p className="text-primary font-black bg-primary/10 inline-block px-3 py-1 rounded-lg text-xs uppercase tracking-widest">@{profile?.username}</p>
                </div>
                <div className="bg-success/10 px-6 py-4 rounded-2xl border border-success/20 text-center shadow-sm">
                    <p className="text-[10px] uppercase text-success font-black mb-1 tracking-widest">Valeur Collection</p>
                    <p className="text-2xl font-black text-success">{collectionTotal.toFixed(2)} ‚Ç¨</p>
                </div>
            </div>

            <div className="flex justify-center mb-8 border-b border-border">
                <button onClick={() => setActiveTab('collection')} className={`px-6 py-3 font-black text-xs uppercase tracking-widest transition-colors border-b-2 ${activeTab === 'collection' ? 'border-primary text-primary' : 'border-transparent text-muted hover:text-foreground'}`}>
                    Collection ({friendCollectionCards.length})
                </button>
                <button onClick={() => setActiveTab('wishlist')} className={`px-6 py-3 font-black text-xs uppercase tracking-widest transition-colors border-b-2 ${activeTab === 'wishlist' ? 'border-primary text-primary' : 'border-transparent text-muted hover:text-foreground'}`}>
                    Wishlist ({wishlistsMeta.length})
                </button>
            </div>

            {activeTab === 'collection' ? (
                <FriendCollectionDisplay cards={friendCollectionCards} loading={loadingCollection} totalPrice={collectionTotal} columns={colColumns} setColumns={setColColumns} sortBy={colSortBy} setSortBy={setColSortBy} targetUid={targetUid} myWishlistMap={myWishlistMap} myTradeBinderMap={myTradeBinderMap} />
            ) : (
                <FriendWishlistDisplay targetUid={targetUid} columns={wishColumns} setColumns={setWishColumns} wishlistsMeta={wishlistsMeta} myWishlistMap={myWishlistMap} myTradeBinderMap={myTradeBinderMap} />
            )}
        </main>
    );
}
</file>

<file path="app/layout.tsx">
import type { Metadata } from 'next';
import { Inter } from 'next/font/google';
import './globals.css';
import { AuthProvider } from '@/lib/AuthContext';
import { ThemeProvider } from '@/components/ThemeProvider';
import Header from '@/components/Header';
import Footer from '@/components/Footer'; 
import { Toaster } from 'react-hot-toast';
import UsernameSetupModal from '@/components/UsernameSetupModal'; 
import Script from 'next/script'; 
import { Suspense } from 'react';
import VerificationBlocker from '@/components/auth/VerificationBlocker'; // 1. IMPORT DU BLOQUEUR

const inter = Inter({ subsets: ['latin'] });

const adsensePubId = process.env.NEXT_PUBLIC_ADSENSE_PUB_ID; 
const cmpMessageId = process.env.NEXT_PUBLIC_CMP_MESSAGE_ID; 

export const metadata: Metadata = {
  title: 'MagicWish',
  description: 'G√©rez votre collection Magic the Gathering et echangez avec vos amis facilement !',
  verification: adsensePubId ? {
      google: adsensePubId 
  } : undefined,
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const isProd = process.env.NODE_ENV === 'production';
  const cleanPubId = adsensePubId?.replace('pub-', ''); 
  const dataId = cmpMessageId || cleanPubId; 

  return (
    <html lang="fr" suppressHydrationWarning>
      <head>
        {/* CMP Script */}
        {(isProd && adsensePubId && dataId) && (
          <>
            <Script
              async
              src={`https://fundingchoicesmessages.google.com/i/${cleanPubId}?hl=fr`}
              data-id={dataId} 
              strategy="beforeInteractive" 
              crossOrigin="anonymous"
            />
            <Script
              id="cmp-starter-script"   
              strategy="beforeInteractive"
              dangerouslySetInnerHTML={{
                __html: `
                  (function(){
                    var s = document.createElement('script'); 
                    s.async = true; 
                    s.src = 'https://fundingchoicesmessages.google.com/start.js?id=${adsensePubId}';
                    document.head.appendChild(s);
                  })();
                `,
              }}
            />
          </>
        )}

        {/* AdSense Script */}
        {(isProd && adsensePubId) && (
          <Script
            async
            src={`https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=${adsensePubId}`}
            strategy="beforeInteractive" 
            crossOrigin="anonymous"
          />
        )}
      </head>

      <body className={`${inter.className} min-h-screen flex flex-col bg-background text-foreground`}>
        <ThemeProvider 
            attribute="class" 
            defaultTheme="light" 
            enableSystem={false} 
            disableTransitionOnChange 
        >
          <AuthProvider>
            
            {/* 2. ON ENGLOBE TOUT LE CONTENU VISIBLE */}
            <VerificationBlocker>
                <Suspense fallback={<div className="h-16 w-full bg-background border-b border-border" />}>
                    <Header />
                </Suspense>

                <main className="flex-1">
                    {children}
                </main>
                
                <UsernameSetupModal />
                
                <Footer />
            </VerificationBlocker>

            {/* Le Toaster reste en dehors pour afficher les notifs m√™me si bloqu√© */}
            <Toaster position="bottom-right" toastOptions={{
                style: {
                  background: '#333',
                  color: '#fff',
                },
            }} />
            
          </AuthProvider>
        </ThemeProvider>
      </body>
    </html>
  );
}
</file>

<file path="components/wishlist/SingleWishlistView.tsx">
// components/wishlist/SingleWishlistView.tsx
'use client';

import { useMemo, useState, useEffect } from 'react';
import { useAuth } from '@/lib/AuthContext';
import { useCardCollection, CardType } from '@/hooks/useCardCollection';
import MagicCard from '@/components/MagicCard';
import toast from 'react-hot-toast';
import { moveCardFromWishlistToCollection } from '@/lib/services/collectionService'; 
import { useColumnPreference } from '@/hooks/useColumnPreference'; 
import { SortOption } from '@/hooks/useSortPreference'; 
import CardListFilterBar from '@/components/common/CardListFilterBar'; 

type Props = {
    listId: string;
    listName: string;
    onRename?: (newName: string) => Promise<void>;
};

export default function SingleWishlistView({ listId, listName, onRename }: Props) {
    const { cards, loading, updateQuantity, removeCard, toggleAttribute, totalPrice } = useCardCollection('wishlist', listId);
    const { user } = useAuth();
    
    // --- √âTATS RENOMMAGE ---
    const [isRenaming, setIsRenaming] = useState(false);
    const [renameValue, setRenameValue] = useState(listName);

    useEffect(() => {
        setRenameValue(listName);
    }, [listName]);

    // --- √âTATS DE PR√âF√âRENCE & FILTRE ---
    const { columns, setColumns } = useColumnPreference('mw_cols_wishlist_single', 5);
    const [searchQuery, setSearchQuery] = useState('');
    const [sortBy, setSortBy] = useState<SortOption>('name_asc'); // Default strict
    const [filterSet, setFilterSet] = useState<string>('all'); 
    const [filterFoil, setFilterFoil] = useState(false);
    const [minPriceFilter, setMinPriceFilter] = useState<string>('');
    const [maxPriceFilter, setMaxPriceFilter] = useState<string>('');
    // ------------------------------------

    const handleRenameSubmit = async (e: React.FormEvent) => {
        e.preventDefault();
        if (onRename && renameValue.trim() && listId !== 'default') {
            await onRename(renameValue.trim());
            setIsRenaming(false);
        }
    };

    const filteredAndSortedCards = useMemo(() => {
        
        if (!cards) return [];
        
        let result = [...cards];
        
        const minPrice = parseFloat(minPriceFilter);
        const maxPrice = parseFloat(maxPriceFilter);

        // 1. Filtrage par recherche
        if (searchQuery) {
            const lowerQ = searchQuery.toLowerCase();
            result = result.filter((c: CardType) => c.name.toLowerCase().includes(lowerQ));
        }
        
        // 2. Filtre par √©dition
        if (filterSet !== 'all') { 
            result = result.filter((c: CardType) => c.setName === filterSet);
        }

        // 3. Filtrage Foil
        if (filterFoil) {
            result = result.filter((c: CardType) => c.isFoil);
        }
        
        // 4. Filtrage Prix
        if (!isNaN(minPrice) || !isNaN(maxPrice)) {
            result = result.filter((c: CardType) => {
                const cardPrice = c.price ?? 0;
                const isAboveMin = isNaN(minPrice) || cardPrice >= minPrice;
                const isBelowMax = isNaN(maxPrice) || cardPrice <= maxPrice;
                return isAboveMin && isBelowMax;
            });
        }

        // --- TRI MIS A JOUR ---
        result.sort((a: CardType, b: CardType) => {
            const priceA = a.price ?? 0;
            const priceB = b.price ?? 0;
            const cmcA = a.cmc ?? 0;
            const cmcB = b.cmc ?? 0;

            switch (sortBy) {
                case 'name_asc': return a.name.localeCompare(b.name);
                case 'name_desc': return b.name.localeCompare(a.name);
                case 'name': return a.name.localeCompare(b.name);

                case 'price_asc': return priceA - priceB;
                case 'price_desc': return priceB - priceA;

                case 'cmc_asc': return cmcA - cmcB;
                case 'cmc_desc': return cmcB - cmcA;

                case 'set_asc': return (a.setName || '').localeCompare(b.setName || '');
                case 'set_desc': return (b.setName || '').localeCompare(a.setName || '');

                default: return 0;
            }
        });

        return result;
    }, [cards, searchQuery, sortBy, filterSet, filterFoil, minPriceFilter, maxPriceFilter]);


    const moveToCollection = async (card: CardType) => {
        if (!user) return;
        const toastId = toast.loading("D√©placement...");
        
        const result = await moveCardFromWishlistToCollection(user.uid, card, listId);

        if (result.success) {
            toast.success("Ajout√©e √† la collection !", { id: toastId });
        } else {
            toast.error(result.error || "Erreur technique", { id: toastId });
        }
    };

    if (loading) return <div className="p-10 text-center text-muted">Chargement des cartes...</div>;

    return (
        <div className="animate-in fade-in duration-300">
            <div className="flex flex-col md:flex-row justify-between items-end mb-6 border-b border-border pb-4 gap-4">
                
                {/* TITRE √âDITABLE */}
                <div className="grow">
                    {isRenaming ? (
                        <form onSubmit={handleRenameSubmit} className="flex items-center gap-2">
                            <input 
                                type="text" 
                                value={renameValue}
                                onChange={(e) => setRenameValue(e.target.value)}
                                className="text-2xl font-bold text-foreground bg-background border border-border rounded px-2 py-1 outline-none focus:ring-2 focus:ring-primary w-full max-w-md"
                                autoFocus
                            />
                            <button type="submit" className="bg-success-vif text-white px-3 py-1 rounded font-bold text-sm">OK</button>
                            <button type="button" onClick={() => setIsRenaming(false)} className="bg-secondary text-foreground px-3 py-1 rounded font-bold text-sm">Annuler</button>
                        </form>
                    ) : (
                        <div className="flex items-center gap-3">
                            <h2 className="text-2xl font-bold text-foreground">{listName}</h2>
                            {onRename && listId !== 'default' && (
                                <button 
                                    onClick={() => setIsRenaming(true)}
                                    className="text-muted hover:text-primary transition p-1"
                                    title="Renommer la liste"
                                >
                                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-5 h-5">
                                        <path strokeLinecap="round" strokeLinejoin="round" d="m16.862 4.487 1.687-1.688a1.875 1.875 0 1 1 2.652 2.652L10.582 16.07a4.5 4.5 0 0 1-1.897 1.13L6 18l.8-2.685a4.5 4.5 0 0 1 1.13-1.897l8.932-8.931Zm0 0L19.5 7.125M18 14v4.75A2.25 2.25 0 0 1 15.75 21H5.25A2.25 2.25 0 0 1 3 18.75V8.25A2.25 2.25 0 0 1 5.25 6H10" />
                                    </svg>
                                </button>
                            )}
                        </div>
                    )}
                </div>
                
                <div className="text-right shrink-0">
                    <span className="text-xs text-muted uppercase font-semibold">Total estim√©</span>
                    <p className="text-2xl font-bold text-success">{totalPrice.toFixed(2)} ‚Ç¨</p>
                </div>
            </div>
            
            {/* UTILISATION DU COMPOSANT PARTAG√â */}
            <CardListFilterBar
                context="wishlist"
                cards={cards}
                searchQuery={searchQuery}
                setSearchQuery={setSearchQuery}
                sortBy={sortBy}
                setSortBy={setSortBy}
                filterSet={filterSet}
                setFilterSet={setFilterSet}
                filterTrade={false}
                setFilterTrade={() => {}}
                filterFoil={filterFoil}
                setFilterFoil={setFilterFoil}
                minPriceFilter={minPriceFilter}
                setMinPriceFilter={setMinPriceFilter}
                maxPriceFilter={maxPriceFilter}
                setMaxPriceFilter={setMaxPriceFilter}
                columns={columns}
                setColumns={setColumns}
            />

            {filteredAndSortedCards.length === 0 ? (
                <div className="text-center py-12 bg-secondary/30 rounded-xl border border-dashed border-border">
                    <p className="text-muted italic">Cette liste est vide ou ne correspond pas aux filtres.</p>
                </div>
            ) : (
                <div 
                    className="grid gap-4"
                    style={{ gridTemplateColumns: `repeat(${columns}, minmax(0, 1fr))` }}
                >
                    {filteredAndSortedCards.map((card: CardType) => (
                        <MagicCard 
                            key={card.id} 
                            {...card} 
                            isWishlist={true}
                            onIncrement={() => updateQuantity(card.id, 1, card.quantity)}
                            onDecrement={() => {
                                if(card.quantity === 1) { if(confirm("Supprimer ?")) removeCard(card.id); } 
                                else { updateQuantity(card.id, -1, card.quantity); }
                            }}
                            onMove={() => moveToCollection(card)}
                            onToggleAttribute={(field, val) => toggleAttribute(card.id, field, val)}
                            returnTo="/wishlist" 
                        />
                    ))}
                </div>
            )}
        </div>
    );
}
</file>

<file path="app/search/page.tsx">
'use client';

import { useState, useMemo, useEffect } from 'react';
import { useAuth } from '@/lib/AuthContext';
import { db } from '@/lib/firebase';
// eslint-disable-next-line @typescript-eslint/no-unused-vars
import { doc, setDoc, increment, serverTimestamp, writeBatch } from 'firebase/firestore';
import { ScryfallRawData, normalizeCardData } from '@/lib/cardUtils';
import { CardType } from '@/hooks/useCardCollection';
import { useWishlists } from '@/hooks/useWishlists';
import CardVersionPickerModal from '@/components/CardVersionPickerModal';
import MagicCard from '@/components/MagicCard'; 
import toast from 'react-hot-toast';
import CardListFilterBar, { CardContext } from '@/components/common/CardListFilterBar';
import SearchToolbar from '@/components/search/SearchToolbar';
import { useColumnPreference } from '@/hooks/useColumnPreference';
import { useSortPreference, SortOption } from '@/hooks/useSortPreference';
import { checkWishlistMatch } from '@/app/actions/matching';
import Link from 'next/link';
import { useSearchParams } from 'next/navigation';

export default function SearchPage() {
  const { user } = useAuth();
  const { lists } = useWishlists();
  const searchParams = useSearchParams();
  
  // Initialisation de la requ√™te depuis l'URL
  const [query, setQuery] = useState(searchParams.get('q') || '');
  const [results, setResults] = useState<ScryfallRawData[]>([]);
  const [isSearching, setIsSearching] = useState(false);
  const [hasSearched, setHasSearched] = useState(false);
  
  const [modalOpen, setModalOpen] = useState(false);
  const [selectedBaseCard, setSelectedBaseCard] = useState<ScryfallRawData | null>(null);
  const [targetDestination, setTargetDestination] = useState<'collection' | 'wishlist'>('collection');

  const [isSelectMode, setIsSelectMode] = useState(false);
  const [selectedIds, setSelectedIds] = useState<string[]>([]);
  const [activeOverlayId, setActiveOverlayId] = useState<string | null>(null);

  const { columns, setColumns } = useColumnPreference('mw_cols_search', 4);
  const { sortBy, setSortBy } = useSortPreference('mw_sort_search', 'name_asc' as SortOption);
  const [filterSet, setFilterSet] = useState<string>('all');
  const [filterFoil, setFilterFoil] = useState(false);
  const [minPriceFilter, setMinPriceFilter] = useState<string>('');
  const [maxPriceFilter, setMaxPriceFilter] = useState<string>('');
  const [filterCMC, setFilterCMC] = useState<string>('');
  const [filterColors, setFilterColors] = useState<string[]>([]);

  const [isMobile, setIsMobile] = useState(false);

  useEffect(() => {
    const checkMobile = () => setIsMobile(window.innerWidth < 768);
    checkMobile();
    window.addEventListener('resize', checkMobile);
    return () => window.removeEventListener('resize', checkMobile);
  }, []);

  const handleSearch = async (forcedQuery?: string) => {
    const searchTerm = forcedQuery !== undefined ? forcedQuery : query;
    if (!searchTerm.trim()) return;

    setIsSearching(true);
    setHasSearched(true);
    setActiveOverlayId(null);

    // Mettre √† jour l'URL sans recharger la page pour garder la recherche en m√©moire
    const newUrl = `${window.location.pathname}?q=${encodeURIComponent(searchTerm)}`;
    window.history.replaceState(null, '', newUrl);

    try {
      const res = await fetch(`/api/search?q=${encodeURIComponent(searchTerm)}`);
      const data = await res.json();
      if (data.data) {
        setResults(data.data);
      } else {
        setResults([]);
        toast.error("Aucune carte trouv√©e.");
      }
    } catch (error) {
      console.error(error);
      toast.error("Erreur de recherche.");
    } finally {
      setIsSearching(false);
    }
  };

  // Relancer la recherche automatiquement si on arrive sur la page avec un param√®tre 'q'
  useEffect(() => {
    const q = searchParams.get('q');
    if (q && !hasSearched) {
      handleSearch(q);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [searchParams]);

  const filteredCards = useMemo(() => {
    let processed: CardType[] = results.map(raw => {
        const normalized = normalizeCardData(raw);
        return {
            ...normalized,
            quantity: 0,
            isFoil: false,
            isSpecificVersion: false,
            quantityForTrade: 0,
            scryfallData: raw
        };
    });

    if (filterSet !== 'all') processed = processed.filter(c => c.setName === filterSet);
    
    if (minPriceFilter || maxPriceFilter) {
        const min = parseFloat(minPriceFilter);
        const max = parseFloat(maxPriceFilter);
        processed = processed.filter(c => {
            const p = c.price || 0;
            return (isNaN(min) || p >= min) && (isNaN(max) || p <= max);
        });
    }

    if (filterCMC) { 
        const targetCMC = parseFloat(filterCMC);
        if (!isNaN(targetCMC)) processed = processed.filter(c => c.cmc === targetCMC); 
    }

    if (filterColors.length > 0) {
        processed = processed.filter(c => {
            if (!c.colors || c.colors.length === 0) return filterColors.includes('C');
            return c.colors.every(color => filterColors.includes(color));
        });
    }

    processed.sort((a, b) => {
        const priceA = a.price || 0;
        const priceB = b.price || 0;
        const cmcA = a.cmc || 0;
        const cmcB = b.cmc || 0;

        switch (sortBy) {
            case 'name_asc': return a.name.localeCompare(b.name);
            case 'name_desc': return b.name.localeCompare(a.name);
            case 'price_asc': return priceA - priceB;
            case 'price_desc': return priceB - priceA;
            case 'cmc_asc': return cmcA - cmcB;
            case 'cmc_desc': return cmcB - cmcA;
            default: return 0;
        }
    });

    return processed;
  }, [results, filterSet, minPriceFilter, maxPriceFilter, sortBy, filterCMC, filterColors]);

  const openPicker = (card: ScryfallRawData, destination: 'collection' | 'wishlist') => {
    setSelectedBaseCard(card);
    setTargetDestination(destination);
    setModalOpen(true);
  };

  const toggleSelection = (id: string) => setSelectedIds(p => p.includes(id) ? p.filter(x => x !== id) : [...p, id]);

  const handleConfirmAdd = async (card: CardType, targetListId: string = 'default') => {
    if (!user) return;
    const toastId = toast.loading("Ajout...");
    try {
        let path = targetDestination === 'collection' ? 'collection' : 'wishlist';
        if (targetDestination === 'wishlist' && targetListId !== 'default') path = `wishlists_data/${targetListId}/cards`;
        else if (targetDestination === 'collection' && targetListId !== 'default') path = `collections_data/${targetListId}/cards`;

        await setDoc(doc(db, 'users', user.uid, path, card.id), {
            ...card,
            uid: user.uid,
            wishlistId: targetDestination === 'wishlist' ? targetListId : null,
            addedAt: serverTimestamp(),
            imageBackUrl: card.imageBackUrl || null,
            quantity: increment(card.quantity)
        }, { merge: true });

        toast.success("Ajout√© !", { id: toastId });

        if (targetDestination === 'wishlist') {
            checkWishlistMatch(user.uid, [{ id: card.id, name: card.name, isFoil: !!card.isFoil }])
            .then(res => { if ((res?.matches ?? 0) > 0) toast(`Match trouv√© avec ${res?.matches ?? 0} ami(s)!`, { icon: 'üîî' }); });
        }
    } catch (e) {
        console.error(e);
        toast.error("Erreur", { id: toastId });
    }
  };


  const handleCardClick = (id: string) => {
    if (!isMobile || isSelectMode) return;
    setActiveOverlayId(activeOverlayId === id ? null : id);
  };

  return (
    <main className="container mx-auto p-4 min-h-[85vh] relative pb-24">
      <div className="text-center mb-8 pt-4">
        <h1 className="text-3xl font-bold text-primary mb-2">Centre de Recherche</h1>
        <p className="text-muted">Trouvez n&apos;importe quelle carte et g√©rez votre collection.</p>
      </div>

      <CardListFilterBar
        context={'search' as CardContext}
        cards={filteredCards}
        searchQuery={query}
        setSearchQuery={setQuery}
        onSearch={() => handleSearch()}
        sortBy={sortBy}
        setSortBy={setSortBy}
        filterSet={filterSet}
        setFilterSet={setFilterSet}
        filterTrade={false}
        setFilterTrade={() => {}}
        filterFoil={filterFoil}
        setFilterFoil={setFilterFoil}
        minPriceFilter={minPriceFilter}
        setMinPriceFilter={setMinPriceFilter}
        maxPriceFilter={maxPriceFilter}
        setMaxPriceFilter={setMaxPriceFilter}
        filterCMC={filterCMC}
        setFilterCMC={setFilterCMC}
        filterColors={filterColors}
        setFilterColors={setFilterColors}
        columns={columns}
        setColumns={setColumns}
        hideSliderOnMobile={true} 
      />

      {results.length > 0 && (
        <SearchToolbar 
            isSelectMode={isSelectMode} 
            setIsSelectMode={setIsSelectMode} 
            totalResults={filteredCards.length} 
        />
      )}

      {isSearching ? (
        <div className="text-center py-20"><div className="inline-block w-8 h-8 border-4 border-primary border-t-transparent rounded-full animate-spin mb-4"></div><p className="text-muted">Recherche en cours...</p></div>
      ) : filteredCards.length > 0 ? (
        <div 
            className="grid gap-4 md:gap-6 grid-cols-2 md:grid-cols-[repeat(var(--cols),minmax(0,1fr))]"
            style={{ '--cols': columns } as React.CSSProperties}
        >
            {filteredCards.map((card) => (
                <div key={card.id} className="relative flex flex-col group h-full">
                    <div 
                        className="relative aspect-[2.5/3.5] rounded-[4.5%/3.2%] overflow-hidden shadow-md border border-border bg-secondary"
                        onClick={() => handleCardClick(card.id)}
                    >
                        <MagicCard 
                            {...card} 
                            readOnly={true} 
                            isSelectMode={isSelectMode}
                            isSelected={selectedIds.includes(card.id)}
                            onSelect={() => toggleSelection(card.id)}
                            hideFooter={true}
                        />

                        {!isSelectMode && (
                            <div 
                                className={`absolute inset-0 bg-black/70 flex flex-col items-center justify-center gap-2 p-3 transition-opacity duration-200 z-30 ${
                                    isMobile 
                                        ? (activeOverlayId === card.id ? 'opacity-100' : 'opacity-0 pointer-events-none') 
                                        : 'opacity-0 group-hover:opacity-100'
                                }`}
                            >
                                <button 
                                    onClick={(e) => { e.stopPropagation(); openPicker(card.scryfallData as ScryfallRawData, 'collection'); }}
                                    className="w-full max-w-[120px] bg-primary text-primary-foreground font-bold py-2 rounded-lg text-[10px] uppercase tracking-wider"
                                >
                                    Collection
                                </button>
                                <button 
                                    onClick={(e) => { e.stopPropagation(); openPicker(card.scryfallData as ScryfallRawData, 'wishlist'); }}
                                    className="w-full max-w-[120px] bg-white text-black font-bold py-2 rounded-lg text-[10px] uppercase tracking-wider"
                                >
                                    Wishlist
                                </button>
                                <Link 
                                    href={`/card/${card.id}?returnTo=${encodeURIComponent(`/search?q=${query}`)}`}
                                    className="w-full max-w-[120px] bg-secondary text-foreground text-center font-bold py-2 rounded-lg text-[10px] uppercase tracking-wider"
                                    onClick={(e) => e.stopPropagation()}
                                >
                                    D√©tails
                                </Link>
                            </div>
                        )}
                    </div>

                    <div className="mt-2 px-1 text-center">
                        <h3 className="font-bold text-foreground text-[11px] md:text-xs truncate">{card.name}</h3>
                        <p className="text-[9px] md:text-[10px] text-muted truncate">{card.setName}</p>
                    </div>
                </div>
            ))}
        </div>
      ) : hasSearched ? (
        <div className="text-center py-20 text-muted">Aucun r√©sultat trouv√©.</div>
      ) : null}

      <CardVersionPickerModal 
        isOpen={modalOpen} 
        onClose={() => setModalOpen(false)} 
        baseCard={selectedBaseCard} 
        onConfirm={handleConfirmAdd} 
        destination={targetDestination} 
        availableLists={lists} 
      />
    </main>
  );
}
</file>

<file path="app/wishlist/page.tsx">
// app/wishlist/page.tsx
'use client';

import { useState, useMemo, useEffect, Suspense } from 'react';
import { useAuth } from '@/lib/AuthContext';
import { useWishlists } from '@/hooks/useWishlists';
import { useCardCollection, CardType } from '@/hooks/useCardCollection';
import { useSearchParams, useRouter } from 'next/navigation';
import { useColumnPreference } from '@/hooks/useColumnPreference';
import { useSortPreference, SortOption } from '@/hooks/useSortPreference';
import { moveCardFromWishlistToCollection } from '@/lib/services/collectionService';

// Composants
import MagicCard from '@/components/MagicCard';
import GlobalWishlistView from '@/components/wishlist/GlobalWishlistView';
import DataTransferHubModal from '@/components/DataTransferHubModal'; 
import ImportModal from '@/components/ImportModal';
import ExportModal from '@/components/ExportModal';
import CollectionToolbar from '@/components/collection/CollectionToolbar';
import CardListFilterBar from '@/components/common/CardListFilterBar';
import ConfirmModal from '@/components/ConfirmModal';
import { LockedListModal } from '@/components/LockedListModal';
import { Lock } from 'lucide-react'; // AJOUT DE L'IMPORT
import toast from 'react-hot-toast';

const ITEMS_PER_PAGE = 50;

function WishlistContent() {
  const { user, userProfile } = useAuth();
  const searchParams = useSearchParams();
  const router = useRouter();
  
  const selectedListId = searchParams.get('listId') || 'default';
  const { lists, renameList, deleteList, loading: metaLoading } = useWishlists();

  const { 
      cards, loading, updateQuantity, removeCard, toggleAttribute, 
      bulkRemoveCards, totalPrice 
  } = useCardCollection('wishlist', selectedListId);

  const isLocked = useMemo(() => {
    if (selectedListId === 'default' || selectedListId === 'GLOBAL_VIEW') return false;
    if (userProfile?.isPremium) return false;

    const sortedLists = [...lists].sort((a, b) => (a.createdAt?.seconds || 0) - (b.createdAt?.seconds || 0));
    const index = sortedLists.findIndex(l => l.id === selectedListId);
    
    return index >= 1;
  }, [selectedListId, lists, userProfile]);

  const [isHubOpen, setIsHubOpen] = useState(false);
  const [isImportOpen, setIsImportOpen] = useState(false);
  const [isExportOpen, setIsExportOpen] = useState(false);
  
  const [cardToDelete, setCardToDelete] = useState<string | null>(null);
  const [listToDelete, setListToDelete] = useState<string | null>(null);

  const [isRenaming, setIsRenaming] = useState(false);
  const [renameValue, setRenameValue] = useState('');

  const [isSelectMode, setIsSelectMode] = useState(false);
  const [selectedIds, setSelectedIds] = useState<string[]>([]);
  const [visibleCount, setVisibleCount] = useState(ITEMS_PER_PAGE);
  const { columns, setColumns } = useColumnPreference('mw_cols_wishlist', 5);

  const [searchQuery, setSearchQuery] = useState('');
  const { sortBy, setSortBy } = useSortPreference('mw_sort_wishlist', 'date_desc' as SortOption); 
  const [filterSet, setFilterSet] = useState<string>('all');
  const [filterFoil, setFilterFoil] = useState(false);
  const [minPriceFilter, setMinPriceFilter] = useState<string>('');
  const [maxPriceFilter, setMaxPriceFilter] = useState<string>('');
  const [filterCMC, setFilterCMC] = useState<string>('');
  const [filterColors, setFilterColors] = useState<string[]>([]);

  const currentListName = useMemo(() => {
    return lists.find(l => l.id === selectedListId)?.name || 'Liste principale';
  }, [lists, selectedListId]);

  useEffect(() => {
      setRenameValue(currentListName);
  }, [currentListName]);

  const closeAllModals = () => { setIsHubOpen(false); setIsImportOpen(false); setIsExportOpen(false); };
  const openHub = () => { setIsImportOpen(false); setIsExportOpen(false); setIsHubOpen(true); };
  const handleSelectImport = () => { setIsHubOpen(false); setIsImportOpen(true); };
  const handleSelectExport = () => { setIsHubOpen(false); setIsExportOpen(true); };

  const handleRenameSubmit = async (e: React.FormEvent) => {
      e.preventDefault();
      if (renameValue.trim() && selectedListId !== 'default' && selectedListId !== 'GLOBAL_VIEW') {
          await renameList(selectedListId, renameValue.trim());
          setIsRenaming(false);
      }
  };

  const handleDeleteCurrentList = async () => {
      if (listToDelete) {
          await deleteList(listToDelete);
          setListToDelete(null);
          router.push('/wishlist');
      }
  };

  const moveToCollection = async (card: CardType) => {
    if (!user || isLocked) return;
    const toastId = toast.loading("D√©placement...");
    const result = await moveCardFromWishlistToCollection(user.uid, card, selectedListId);
    if (result.success) {
        toast.success("Ajout√©e √† la collection !", { id: toastId });
    } else {
        toast.error(result.error || "Erreur technique", { id: toastId });
    }
  };

  const filteredAndSortedCards = useMemo(() => {
    let result = [...cards];
    const minPrice = parseFloat(minPriceFilter);
    const maxPrice = parseFloat(maxPriceFilter);

    if (searchQuery) {
        const lowerQ = searchQuery.toLowerCase();
        result = result.filter(c => c.name.toLowerCase().includes(lowerQ));
    }
    if (filterSet !== 'all') result = result.filter(c => c.setName === filterSet);
    if (filterFoil) result = result.filter(c => c.isFoil);
    
    if (!isNaN(minPrice) || !isNaN(maxPrice)) {
        result = result.filter(c => {
            const cardPrice = c.price ?? 0;
            const isAboveMin = isNaN(minPrice) || cardPrice >= minPrice;
            const isBelowMax = isNaN(maxPrice) || cardPrice <= maxPrice;
            return isAboveMin && isBelowMax;
        });
    }

    if (filterCMC) { 
        const t = parseFloat(filterCMC); 
        if (!isNaN(t)) result = result.filter(c => c.cmc === t); 
    }

    if (filterColors.length > 0) {
        result = result.filter(c => {
            if (!c.colors || c.colors.length === 0) return filterColors.includes('C');
            return c.colors.every(col => filterColors.includes(col));
        });
    }

    result.sort((a, b) => {
        const priceA = a.price ?? 0;
        const priceB = b.price ?? 0;
        const dateA = a.lastPriceUpdate ? new Date(a.lastPriceUpdate).getTime() : 0;
        const dateB = b.lastPriceUpdate ? new Date(b.lastPriceUpdate).getTime() : 0;
        
        switch (sortBy) {
            case 'name_asc': return a.name.localeCompare(b.name);
            case 'name_desc': return b.name.localeCompare(a.name);
            case 'price_asc': return priceA - priceB;
            case 'price_desc': return priceB - priceA;
            case 'date_asc': return dateA - dateB;
            case 'date_desc': return dateB - dateA;
            case 'quantity_asc': return a.quantity - b.quantity;
            case 'quantity_desc': return b.quantity - a.quantity;
            case 'cmc_asc': return (a.cmc ?? 0) - (b.cmc ?? 0);
            case 'cmc_desc': return (b.cmc ?? 0) - (a.cmc ?? 0);
            default: return 0;
        }
    });

    return result;
  }, [cards, searchQuery, sortBy, filterSet, filterFoil, minPriceFilter, maxPriceFilter, filterCMC, filterColors]);

  const visibleCards = filteredAndSortedCards.slice(0, visibleCount);

  const toggleSelection = (id: string) => {
      if (isLocked) return;
      setSelectedIds(prev => prev.includes(id) ? prev.filter(pid => pid !== id) : [...prev, id]);
  };

  const handleSelectAll = () => {
      if (isLocked) return;
      if (selectedIds.length === filteredAndSortedCards.length) setSelectedIds([]); 
      else setSelectedIds(filteredAndSortedCards.map(c => c.id)); 
  };

  const handleBulkDelete = async () => {
      if (isLocked) return;
      if (!confirm(`Supprimer ces ${selectedIds.length} cartes ?`)) return;
      await bulkRemoveCards(selectedIds);
      setSelectedIds([]);
      setIsSelectMode(false);
  };

  if (!user) return <p className="p-10 text-center text-muted font-bold uppercase text-xs">Veuillez vous connecter.</p>;
  
  if (selectedListId === 'GLOBAL_VIEW') {
      return (
        <main className="container mx-auto p-4 min-h-[85vh]">
            <div className="flex justify-end mb-4">
                 <button onClick={openHub} className="btn-primary text-xs tracking-widest uppercase">Importer/Exporter</button>
            </div>
            <GlobalWishlistView lists={lists} />
            <DataTransferHubModal isOpen={isHubOpen} onClose={closeAllModals} onSelectImport={handleSelectImport} onSelectExport={handleSelectExport} targetLabel="Wishlist" />
        </main>
      );
  }

  if (loading && metaLoading) return <div className="flex h-screen items-center justify-center text-muted animate-pulse font-bold uppercase text-xs">Chargement...</div>;

  return (
    <main className="container mx-auto p-4 pb-24 relative">
      <LockedListModal isOpen={isLocked} listName={currentListName} />

      <div className="flex justify-between items-center mb-6">
          <div className="overflow-hidden grow pr-4">
              {isRenaming && !isLocked ? (
                  <form onSubmit={handleRenameSubmit} className="flex items-center gap-2">
                      <input type="text" value={renameValue} onChange={(e) => setRenameValue(e.target.value)} className="text-2xl font-black text-foreground bg-background border border-border rounded-xl px-2 py-1 outline-none focus:ring-2 focus:ring-primary w-full max-w-md" autoFocus />
                      <button type="submit" className="bg-success-vif text-white px-3 py-1 rounded-lg font-bold text-sm uppercase">OK</button>
                  </form>
              ) : (
                  <div>
                      <h1 className="text-2xl md:text-3xl font-black text-foreground truncate uppercase tracking-tighter flex items-center gap-2">
                          {currentListName} 
                          <span className="text-base font-bold text-muted">({filteredAndSortedCards.length})</span>
                          {/* UTILISATION DE L'IC√îNE LOCK */}
                          {isLocked && <Lock className="w-5 h-5 text-muted-foreground" />}
                      </h1>
                      {selectedListId !== 'default' && !isLocked && (
                          <button onClick={() => setListToDelete(selectedListId)} className="text-[10px] font-black text-danger hover:underline mt-1 block uppercase tracking-widest">Supprimer la liste</button>
                      )}
                  </div>
              )}
          </div>
          <div className="shrink-0 bg-primary text-primary-foreground px-4 py-2 rounded-xl shadow-sm text-right">
              <span className="text-[8px] uppercase tracking-widest font-black opacity-80 block mb-0.5">Valeur Totale</span>
              <span className="font-black text-sm whitespace-nowrap">{totalPrice.toFixed(2)} EUR</span>
          </div>
      </div>

      {!isLocked && (
          <CollectionToolbar
              isSelectMode={isSelectMode}
              setIsSelectMode={setIsSelectMode}
              onOpenHub={openHub}
              onOpenTools={() => {}} 
          />
      )}

      <CardListFilterBar
        context="wishlist"
        cards={cards}
        searchQuery={searchQuery}
        setSearchQuery={setSearchQuery}
        sortBy={sortBy}
        setSortBy={setSortBy}
        filterSet={filterSet}
        setFilterSet={setFilterSet}
        filterTrade={false}
        setFilterTrade={() => {}}
        filterFoil={filterFoil}
        setFilterFoil={setFilterFoil}
        minPriceFilter={minPriceFilter}
        setMinPriceFilter={setMinPriceFilter}
        maxPriceFilter={maxPriceFilter}
        setMaxPriceFilter={setMaxPriceFilter}
        filterCMC={filterCMC}
        setFilterCMC={setFilterCMC}
        filterColors={filterColors}
        setFilterColors={setFilterColors}
        columns={columns} 
        setColumns={setColumns}
        hideSliderOnMobile={true}
      />

      {isSelectMode && !isLocked && (
          <div className="mb-4 flex items-center justify-between bg-primary/10 p-3 rounded-xl border border-primary/30 animate-in fade-in">
              <span className="font-bold text-primary pl-2 uppercase text-xs tracking-widest">{selectedIds.length} carte(s) s√©lectionn√©e(s)</span>
              <button onClick={handleSelectAll} className="text-xs text-primary font-black px-3 py-1 rounded-lg hover:bg-primary/10 transition uppercase">Tout s√©lectionner</button>
          </div>
      )}

      {filteredAndSortedCards.length === 0 ? (
        <div className="text-center py-20 bg-secondary/50 rounded-3xl border-2 border-dashed border-border shadow-inner">
          <p className="text-sm font-bold text-muted mb-4 uppercase italic">La liste est vide.</p>
        </div>
      ) : (
        <>
            <div 
                className="grid gap-4 md:gap-6 grid-cols-2 md:grid-cols-[repeat(var(--cols),minmax(0,1fr))]" 
                style={{ '--cols': columns } as React.CSSProperties}
            >
                {visibleCards.map((card) => (
                    <MagicCard 
                        key={card.id}
                        {...card}
                        isWishlist={true}
                        hideFooter={isLocked}
                        isSelectMode={isSelectMode && !isLocked}
                        isSelected={selectedIds.includes(card.id)}
                        onSelect={() => toggleSelection(card.id)}
                        onIncrement={!isLocked ? () => updateQuantity(card.id, 1, card.quantity) : undefined}
                        onDecrement={!isLocked ? () => card.quantity <= 1 ? setCardToDelete(card.id) : updateQuantity(card.id, -1, card.quantity) : undefined}
                        onMove={!isLocked ? () => moveToCollection(card) : undefined}
                        onToggleAttribute={!isLocked ? (field, val) => toggleAttribute(card.id, field, val) : undefined}
                    />
                ))}
            </div>
            {filteredAndSortedCards.length > visibleCount && (
                <div className="mt-8 flex justify-center pb-10">
                    <button onClick={() => setVisibleCount(prev => prev + ITEMS_PER_PAGE)} className="bg-surface hover:bg-secondary text-foreground border border-border px-8 py-3 rounded-2xl font-black shadow-sm transition flex items-center gap-2 uppercase text-xs tracking-widest">Afficher plus</button>
                </div>
            )}
        </>
      )}

      {isSelectMode && selectedIds.length > 0 && !isLocked && (
          <div className="fixed bottom-6 left-4 right-4 md:left-1/2 md:right-auto md:-translate-x-1/2 bg-surface shadow-2xl border border-border p-2 rounded-2xl flex items-center justify-around gap-2 z-50 animate-in slide-in-from-bottom-6 duration-300">
              <button onClick={handleBulkDelete} className="px-4 py-2 bg-danger hover:bg-red-600 text-white rounded-xl text-xs font-black transition flex flex-col items-center leading-none gap-1 shadow-md w-full uppercase"><span>Supprimer {selectedIds.length} cartes</span></button>
          </div>
      )}

      <DataTransferHubModal isOpen={isHubOpen} onClose={closeAllModals} onSelectImport={handleSelectImport} onSelectExport={handleSelectExport} targetLabel="Wishlist" />
      <ImportModal isOpen={isImportOpen} onClose={closeAllModals} onGoBack={openHub} onCloseAll={closeAllModals} targetCollection="wishlist" listId={selectedListId} />
      <ExportModal isOpen={isExportOpen} onClose={closeAllModals} onGoBack={openHub} onCloseAll={closeAllModals} cards={cards} listName={currentListName} targetType="wishlist" />
      <ConfirmModal isOpen={!!cardToDelete} onClose={() => setCardToDelete(null)} onConfirm={() => { if(cardToDelete) removeCard(cardToDelete); }} title="Retirer ?" message="Cette carte sera retir√©e de votre wishlist." />
      <ConfirmModal isOpen={!!listToDelete} onClose={() => setListToDelete(null)} onConfirm={handleDeleteCurrentList} title="Supprimer la liste ?" message="Toutes les cartes seront supprim√©es d√©finitivement." />
    </main>
  );
}

export default function WishlistPage() {
    return (
        <Suspense fallback={<div className="flex h-screen items-center justify-center text-muted animate-pulse font-bold uppercase text-xs">Chargement...</div>}>
            <WishlistContent />
        </Suspense>
    );
}
</file>

<file path="hooks/useTradeSystem.ts">
// hooks/useTradeSystem.ts
import { useState, useEffect } from 'react';
import { db } from '@/lib/firebase';
import { 
  collection, query, where, onSnapshot, 
  doc, updateDoc, orderBy, 
  Timestamp
} from 'firebase/firestore';
import { useAuth } from '@/lib/AuthContext';
import { CardType } from './useCardCollection';
import { executeServerTrade } from '@/app/actions/trade'; 
import { proposeTradeAction } from '@/app/actions/trade-proposal'; 
import toast from 'react-hot-toast';

export type TradeStatus = 'pending' | 'completed' | 'rejected' | 'cancelled';

export type TradeRequest = {
  id: string;
  senderUid: string;
  senderName: string;
  receiverUid: string;
  receiverName: string;
  itemsGiven: CardType[];
  itemsReceived: CardType[];
  status: TradeStatus;
  createdAt: Timestamp;
};

// Interface stricte des donn√©es de carte s√©rialisables pour le serveur
interface ServerCardPayload {
    id: string;
    name: string;
    imageUrl: string;
    imageBackUrl: string | null;
    quantity: number;
    quantityForTrade: number; // AJOUT : requis pour √™tre assignable √† CardType
    price: number;
    customPrice?: number;
    setName: string;
    setCode: string;
    isFoil: boolean;
    isSpecificVersion: boolean;
    scryfallData: Record<string, unknown> | null;
    wishlistId: string | null;
}

// Fonction utilitaire pour convertir les CardType du client vers le format attendu par le serveur
const mapCardsForServer = (cards: CardType[]): ServerCardPayload[] => {
    return cards.map(c => {
        const payload: ServerCardPayload = {
            id: c.id,
            name: c.name,
            imageUrl: c.imageUrl,
            imageBackUrl: c.imageBackUrl ?? null,
            quantity: c.quantity,
            quantityForTrade: c.quantityForTrade ?? 0, // AJOUT : mapping de la valeur
            price: c.price ?? 0,
            customPrice: c.customPrice,
            setName: c.setName ?? '',
            setCode: c.setCode ?? '',
            isFoil: c.isFoil ?? false,
            isSpecificVersion: c.isSpecificVersion ?? false,
            scryfallData: (c.scryfallData as Record<string, unknown>) || null,
            wishlistId: c.wishlistId ?? null,
        };
        
        if (payload.customPrice === undefined) delete payload.customPrice;

        return payload;
    });
};

export function useTradeSystem() {
  const { user, username } = useAuth();
  
  const [incomingTrades, setIncomingTrades] = useState<TradeRequest[]>([]);
  const [outgoingTrades, setOutgoingTrades] = useState<TradeRequest[]>([]);
  const [loading, setLoading] = useState(true);
  const [isProcessing, setIsProcessing] = useState(false);

  useEffect(() => {
    if (!user) return;

    const qIn = query(
      collection(db, 'trades'),
      where('receiverUid', '==', user.uid),
      where('status', '==', 'pending'),
      orderBy('createdAt', 'desc')
    );

    const qOut = query(
      collection(db, 'trades'),
      where('senderUid', '==', user.uid),
      where('status', '==', 'pending'),
      orderBy('createdAt', 'desc')
    );

    const unsubIn = onSnapshot(qIn, (snap) => {
      setIncomingTrades(snap.docs.map(d => ({ id: d.id, ...d.data() } as TradeRequest)));
    });

    const unsubOut = onSnapshot(qOut, (snap) => {
      setOutgoingTrades(snap.docs.map(d => ({ id: d.id, ...d.data() } as TradeRequest)));
      setLoading(false);
    });

    return () => { unsubIn(); unsubOut(); };
  }, [user]);

  const proposeTrade = async (receiverUid: string, receiverName: string, toGive: CardType[], toReceive: CardType[]) => {
    if (!user) return false;
    
    const toastId = toast.loading("Envoi de la proposition...");

    try {
      // Cast en unknown puis CardType[] pour satisfaire TypeScript apr√®s avoir nettoy√© l'objet
      const itemsGiven = mapCardsForServer(toGive) as unknown as CardType[];
      const itemsReceived = mapCardsForServer(toReceive) as unknown as CardType[];

      const payload = {
          senderUid: user.uid,
          senderName: username || user.displayName || 'Inconnu',
          receiverUid,
          receiverName,
          itemsGiven,
          itemsReceived
      };

      const result = await proposeTradeAction(payload) as { 
          success: boolean; 
          error?: string; 
          proposalConflict?: boolean;
          existingTradeId?: string; 
      }; 

      if (result.success) {
          toast.success("Proposition envoy√©e !", { id: toastId });
          return true;
      } 
      else if (result.proposalConflict) {
          const friendName = receiverName || "cet ami";
          
          toast.error(`Vous avez d√©j√† une proposition en attente avec ${friendName} pour ces cartes.`, { 
              id: toastId, 
              duration: 5000 
          });
          
          return false;
      }
      else {
          throw new Error(result.error);
      }

    } catch (e: unknown) {
      console.error("Erreur proposeTrade:", e);
      let msg = "Erreur envoi";
      if (e instanceof Error) msg = e.message;
      toast.error(msg, { id: toastId });
      return false;
    }
  };

  const acceptTrade = async (trade: TradeRequest) => {
    if (!user) return;
    
    setIsProcessing(true);
    const toastId = toast.loading("Validation s√©curis√©e en cours...");

    try {
        const cleanGiven = mapCardsForServer(trade.itemsGiven) as unknown as CardType[];
        const cleanReceived = mapCardsForServer(trade.itemsReceived) as unknown as CardType[];
        
        const result = await executeServerTrade(
            trade.id, 
            trade.senderUid,
            user.uid, 
            cleanGiven, 
            cleanReceived 
        ) as { success: boolean; error?: string; };

        if (result.success) {
            toast.success("√âchange termin√© avec succ√®s !", { id: toastId });
        } else {
            throw new Error(result.error || "Erreur serveur inconnue");
        }

    } catch (error: unknown) { 
        console.error("Erreur Accept Trade:", error);
        let msg = "√âchec de l'√©change";
        if (error instanceof Error) msg = error.message;
        else if (typeof error === "string") msg = error;
        toast.error(msg, { id: toastId });
    } finally {
        setIsProcessing(false);
    }
  };

  const rejectTrade = async (tradeId: string) => {
    if(!confirm("Refuser cet √©change ?")) return;
    try {
        await updateDoc(doc(db, 'trades', tradeId), { status: 'rejected' });
        toast.success("√âchange refus√©");
    } catch (error) {
        console.error(error);
        toast.error("Erreur");
    }
  };

  const cancelTrade = async (tradeId: string) => {
    if(!confirm("Annuler cette proposition ?")) return;
    try {
        await updateDoc(doc(db, 'trades', tradeId), { status: 'cancelled' });
        toast.success("Proposition annul√©e");
    } catch (error) {
        console.error(error);
        toast.error("Erreur");
    }
  };

  return { 
    incomingTrades, outgoingTrades, loading, 
    proposeTrade, acceptTrade, rejectTrade, cancelTrade,
    isProcessing,
  };
}
</file>

<file path="app/card/[id]/page.tsx">
'use client';

import { use, useEffect, useState, useMemo, Suspense } from 'react';
import { db } from '@/lib/firebase';
import { doc, getDoc, updateDoc } from 'firebase/firestore';
import { useAuth } from '@/lib/AuthContext';
import { useCardCollection, CardType } from '@/hooks/useCardCollection'; 
import { normalizeCardData, ScryfallRawData } from '@/lib/cardUtils'; 
import { useSearchParams, useRouter } from 'next/navigation';
import Image from 'next/image';
import toast from 'react-hot-toast';

// Imports des composants s√©par√©s
import CardVersionsGrid from '@/components/card-page/CardVersionsGrid';
import DualQuantityManager from '@/components/card-page/DualQuantityManager'; 

// --- INTERFACES ---
interface ScryfallDataExtended extends ScryfallRawData {
    purchase_uris?: {
        cardmarket?: string;
        tcgplayer?: string;
        cardhoarder?: string;
    };
}

type CardDetailPageProps = {
    params: Promise<{ id: string }>;
};

// --- COMPOSANT DE D√âTAILS PRINCIPAUX ---
function CardMainDetails({ cardData }: { cardData: CardType | null }) {
    const { user } = useAuth();
    
    const [isEditingPurchase, setIsEditingPurchase] = useState(false);
    const [purchaseValue, setPurchaseValue] = useState<string>("");
    const [isSaving, setIsSaving] = useState(false);

    useEffect(() => {
        if (cardData?.purchasePrice !== undefined && cardData?.purchasePrice !== null) {
            setPurchaseValue(cardData.purchasePrice.toString());
        } else {
            setPurchaseValue("");
        }
    }, [cardData]);

    if (!cardData) return null;

    const currentPrice = cardData.price ?? 0;
    const hasPrice = currentPrice > 0;
    const purchasePrice = cardData.purchasePrice;
    
    let profitLoss = null;
    let profitLossPercent = null;
    
    if (purchasePrice !== undefined && purchasePrice !== null && purchasePrice > 0 && hasPrice) {
        profitLoss = currentPrice - purchasePrice;
        profitLossPercent = (profitLoss / purchasePrice) * 100;
    }

    const scryfallRaw = cardData.scryfallData as ScryfallDataExtended | undefined;
    const finishes = scryfallRaw?.finishes || [];
    const prices = scryfallRaw?.prices;

    const hasNonFoilVersion = finishes.includes('nonfoil');
    const hasFoilVersion = finishes.includes('foil');

    const baseCardmarketUrl = scryfallRaw?.purchase_uris?.cardmarket 
        || `https://www.cardmarket.com/en/Magic/Products/Search?searchString=${encodeURIComponent(cardData.name)}`;

    const getPreciseUrl = (isFoilVersion: boolean) => {
        const separator = baseCardmarketUrl.includes('?') ? '&' : '?';
        const param = isFoilVersion ? 'isFoil=Y' : 'isFoil=N';
        return `${baseCardmarketUrl}${separator}${param}`;
    };

    const handleSavePurchasePrice = async () => {
        if (!user || !cardData.id) return;
        const val = parseFloat(purchaseValue);
        const finalVal = isNaN(val) ? 0 : val;

        setIsSaving(true);
        try {
            const cardRef = doc(db, 'users', user.uid, 'collection', cardData.id);
            await updateDoc(cardRef, { 
                purchasePrice: finalVal > 0 ? finalVal : 0 
            });
            toast.success("Historique mis √† jour");
            setIsEditingPurchase(false);
        } catch (error) {
            console.error(error);
            toast.error("Erreur sauvegarde.");
        } finally {
            setIsSaving(false);
        }
    };

    const formatPrice = (val?: string) => {
        if (!val) return null;
        const num = parseFloat(val);
        return num > 0 ? `${num.toFixed(2)} EUR` : null;
    };

    const priceNormal = formatPrice(prices?.eur);
    const priceFoil = formatPrice(prices?.eur_foil);

    return (
        <div className="space-y-6">
            <div className="bg-surface p-6 rounded-xl border border-border shadow-sm">
                <div className="flex justify-between items-center mb-4">
                    <h2 className="text-lg font-bold text-foreground flex items-center gap-2">
                        <span className="bg-primary/10 text-primary p-1 rounded">
                            <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8c1.11 0 2.08.402 2.599 1M12 8V7m0 1v8m0 0v1m0-1c-1.11 0-2.08-.402-2.599-1M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                            </svg>
                        </span>
                        Historique d&apos;Acquisition
                    </h2>
                    {!isEditingPurchase && (
                        <button 
                            onClick={() => setIsEditingPurchase(true)}
                            className="text-xs font-bold text-primary hover:underline"
                        >
                            {purchasePrice ? "Modifier" : "Ajouter un prix"}
                        </button>
                    )}
                </div>

                {isEditingPurchase ? (
                    <div className="flex items-center gap-3 animate-in fade-in">
                        <div className="relative">
                            <input 
                                type="number" 
                                min="0" 
                                step="0.01" 
                                placeholder="0.00"
                                value={purchaseValue}
                                onChange={(e) => setPurchaseValue(e.target.value)}
                                className="w-32 p-2 pl-3 rounded border border-border bg-background font-bold focus:ring-2 focus:ring-primary outline-none"
                                autoFocus
                            />
                            <span className="absolute right-3 top-2 text-muted font-bold">EUR</span>
                        </div>
                        <button 
                            onClick={handleSavePurchasePrice} 
                            disabled={isSaving} 
                            className="bg-primary text-primary-foreground py-2 px-4 rounded-lg text-sm font-bold"
                        >
                            {isSaving ? '...' : 'OK'}
                        </button>
                        <button 
                            onClick={() => setIsEditingPurchase(false)} 
                            className="text-muted hover:text-foreground text-sm px-2"
                        >
                            Annuler
                        </button>
                    </div>
                ) : (
                    <div>
                        {purchasePrice ? (
                            <div className="flex items-center gap-6">
                                <div>
                                    <p className="text-xs text-muted uppercase tracking-wider">Acquis pour</p>
                                    <p className="text-xl font-bold text-foreground">{purchasePrice.toFixed(2)} EUR</p>
                                </div>
                                {profitLoss !== null && (
                                    <div className={`px-3 py-1 rounded-lg border ${profitLoss >= 0 ? 'bg-success/10 border-success/20 text-success' : 'bg-danger/10 border-danger/20 text-danger'}`}>
                                        <p className="text-xs font-bold uppercase">{profitLoss >= 0 ? 'Plus-value' : 'Moins-value'}</p>
                                        <p className="font-bold">
                                            {profitLoss >= 0 ? '+' : ''}{profitLoss.toFixed(2)} EUR 
                                            <span className="opacity-70 ml-1">
                                                ({profitLoss >= 0 ? '+' : ''}{profitLossPercent?.toFixed(1)}%)
                                            </span>
                                        </p>
                                    </div>
                                )}
                            </div>
                        ) : (
                            <p className="text-muted italic text-sm">Aucune donn√©e d&apos;achat enregistr√©e.</p>
                        )}
                    </div>
                )}
            </div>

            <div className="bg-surface rounded-xl border border-border shadow-sm overflow-hidden">
                <div className="px-6 py-4 border-b border-border bg-secondary/10">
                    <h2 className="text-lg font-bold text-foreground flex items-center gap-2">
                        <span className="bg-secondary text-muted p-1 rounded">
                            <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 7h8m0 0v8m0-8l-8 8-4-4-6 6" />
                            </svg>
                        </span>
                        Donn√©es du March√© (Scryfall)
                    </h2>
                </div>

                <div className="divide-y divide-border">
                    {hasNonFoilVersion && (
                        <div className="px-6 py-4 grid grid-cols-3 items-center hover:bg-secondary/5 transition-colors">
                            <div className="justify-self-start">
                                <span className="text-sm font-bold text-foreground bg-secondary/50 px-2 py-1 rounded">Normal</span>
                            </div>
                            <div className={`justify-self-center text-lg font-bold ${priceNormal ? 'text-success' : 'text-muted italic'}`}>
                                {priceNormal || 'N/A'}
                            </div>
                            <div className="justify-self-end">
                                <a 
                                    href={getPreciseUrl(false)} 
                                    target="_blank" 
                                    rel="noopener noreferrer"
                                    className="text-sm text-blue-600 hover:text-blue-800 font-bold"
                                >
                                    Acheter
                                </a>
                            </div>
                        </div>
                    )}

                    {hasFoilVersion && (
                        <div className="px-6 py-4 grid grid-cols-3 items-center hover:bg-secondary/5 transition-colors">
                            <div className="justify-self-start">
                                <span className="text-sm font-bold text-amber-700 bg-amber-50 px-2 py-1 rounded border border-amber-100 flex items-center gap-1">
                                    Foil
                                </span>
                            </div>
                            <div className={`justify-self-center text-lg font-bold ${priceFoil ? 'text-purple-600' : 'text-muted italic'}`}>
                                {priceFoil || 'N/A'}
                            </div>
                            <div className="justify-self-end">
                                <a 
                                    href={getPreciseUrl(true)} 
                                    target="_blank" 
                                    rel="noopener noreferrer"
                                    className="text-sm text-amber-700 hover:text-amber-900 font-bold"
                                >
                                    Acheter
                                </a>
                            </div>
                        </div>
                    )}
                </div>
            </div>
        </div>
    );
}

// --- CONTENU DE LA PAGE ---
function CardDetailContent({ params }: CardDetailPageProps) {
    const { user } = useAuth();
    const router = useRouter();
    const unwrappedParams = use(params);
    const cardId = unwrappedParams.id;
    const searchParams = useSearchParams();
    
    // GESTION RETOUR INTELLIGENTE
    const returnTo = searchParams.get('returnTo');
    const handleBack = () => {
        if (returnTo) {
            router.push(decodeURIComponent(returnTo));
        } else {
            router.back();
        }
    };

    const { cards: collectionCards, loading: collectionLoading } = useCardCollection('collection'); 
    
    const collectionMap = useMemo(() => {
        const map = new Map<string, CardType>();
        collectionCards.forEach(c => map.set(c.id, c));
        return map;
    }, [collectionCards]);

    const [card, setCard] = useState<CardType | null>(null);
    const [loading, setLoading] = useState(true);
    const [isFlipped, setIsFlipped] = useState(false); 
    const [showAllVersions, setShowAllVersions] = useState(false);

    useEffect(() => {
        if (!user) { setLoading(false); return; }

        const liveCard = collectionCards.find(c => c.id === cardId);

        if (liveCard) {
            setCard(liveCard);
            setLoading(false);
        } else if (!collectionLoading) {
            const fetchFallback = async () => {
                setLoading(true);
                try {
                    const snap = await getDoc(doc(db, 'users', user.uid, 'wishlist', cardId));
                    
                    if (snap.exists()) {
                        setCard({ id: snap.id, ...snap.data(), uid: user.uid } as CardType); 
                    } else {
                        try {
                            const scryRes = await fetch(`https://api.scryfall.com/cards/${cardId}`);
                            if (scryRes.ok) {
                                const scryData = await scryRes.json();
                                const normalized = normalizeCardData(scryData);
                                setCard({ ...normalized, quantity: 0, uid: '', wishlistId: undefined, isFoil: false, isSpecificVersion: false, quantityForTrade: 0 } as CardType);
                            }
                        } catch (errScry) { console.error(errScry); }
                    }
                } catch (e) { console.error(e); } 
                finally { setLoading(false); }
            };
            fetchFallback();
        }
    }, [user, cardId, collectionCards, collectionLoading]);

    const handleVersionSelect = (rawCard: ScryfallRawData) => {
        const normalized = normalizeCardData(rawCard);
        setCard(prev => {
            if (!prev) return null;
            return {
                ...prev,
                name: normalized.name,
                imageUrl: normalized.imageUrl,
                imageBackUrl: normalized.imageBackUrl,
                setName: normalized.setName,
                setCode: normalized.setCode,
                price: normalized.price,
                scryfallData: normalized.scryfallData as Record<string, unknown>, 
            };
        });
        setShowAllVersions(false); 
        setIsFlipped(false); 
    };

    const scryfallId = card ? ((card.scryfallData as ScryfallRawData)?.id || card.id) : null;
    const isOwner = useMemo(() => {
        if (!user || !card) return false;
        if (!!card.uid && user.uid === card.uid) return true;
        if (collectionMap.has(card.id)) return true;
        if (scryfallId) {
            return Array.from(collectionMap.values()).some(c => {
                const cScryId = (c.scryfallData as ScryfallRawData)?.id;
                return cScryId === scryfallId;
            });
        }
        return false;
    }, [user, card, collectionMap, scryfallId]);

    if (!user) return <div className="p-10 text-center text-muted">Connectez-vous pour voir les d√©tails.</div>;
    if (loading) return <div className="p-10 text-center text-muted animate-pulse">Chargement des d√©tails...</div>;
    if (!card) return <div className="p-10 text-center text-danger">Carte introuvable.</div>;

    const displayData = card.scryfallData 
        ? normalizeCardData(card.scryfallData as ScryfallRawData)
        : { 
            name: card.name, 
            imageUrl: card.imageUrl, 
            imageBackUrl: card.imageBackUrl, 
            setName: card.setName, 
            setCode: card.setCode,
            price: card.price
        };

    const { name, imageUrl, imageBackUrl, setName } = displayData;
    const isDoubleSided = !!imageBackUrl;
    const oracleId = (card.scryfallData as ScryfallRawData)?.oracle_id as string | undefined;
    const displayImage = isFlipped && imageBackUrl ? imageBackUrl : imageUrl;
    
    return (
        <main className="container mx-auto p-4 max-w-6xl min-h-[80vh]">
            <div className="mb-6 flex justify-between items-center">
                <button 
                    onClick={handleBack} 
                    className="text-sm text-primary hover:underline font-bold flex items-center gap-1"
                >
                    <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10 19l-7-7m0 0l7-7m-7 7h18" />
                    </svg>
                    Retour
                </button>
                {oracleId && (
                     <button
                        onClick={() => setShowAllVersions(!showAllVersions)}
                        className="bg-secondary hover:bg-border text-foreground px-4 py-2 rounded-lg text-sm font-bold transition"
                     >
                        {showAllVersions ? 'Afficher les D√©tails' : 'Voir toutes les √âditions'}
                     </button>
                )}
            </div>

            <h1 className="text-2xl md:text-3xl font-bold text-foreground mb-8 border-b border-border pb-4">
                {name}
            </h1>

            {showAllVersions && oracleId ? (
                <CardVersionsGrid 
                    oracleId={oracleId} 
                    currentCardId={card.id} 
                    onVersionSelect={handleVersionSelect} 
                    collectionMap={collectionMap} 
                />
            ) : (
                <div className="grid md:grid-cols-3 gap-8">
                    <div className="md:col-span-1 flex flex-col items-center">
                        <div 
                            className="w-full max-w-sm aspect-[2.5/3.5] rounded-[4.5%] overflow-hidden shadow-2xl ring-4 ring-primary/20 cursor-pointer relative"
                            onClick={() => isDoubleSided && setIsFlipped(!isFlipped)}
                        >
                            <Image 
                                src={displayImage} 
                                alt={name} 
                                fill 
                                className="object-cover" 
                                sizes="(max-width: 768px) 100vw, 400px" 
                                priority 
                            />
                        </div>
                        {isDoubleSided && (
                            <button 
                                onClick={() => setIsFlipped(!isFlipped)} 
                                className="mt-4 text-sm text-primary hover:underline font-medium"
                            >
                                {isFlipped ? 'Afficher le Recto' : 'Afficher le Verso'}
                            </button>
                        )}
                        <div className="mt-4 text-center">
                            <p className="text-lg font-semibold text-foreground">{setName}</p>
                            {isOwner ? (
                                <p className="text-xs text-success font-bold mt-1 uppercase tracking-widest">
                                    ‚úì En Collection
                                </p>
                            ) : (
                                <p className="text-sm text-muted italic mt-1">Non poss√©d√©e</p>
                            )}
                        </div>
                    </div>

                    <div className="md:col-span-2 space-y-6">
                        {isOwner && <DualQuantityManager card={card} />}
                        <CardMainDetails cardData={card} />
                    </div>
                </div>
            )}
        </main>
    );
}

// --- PAGE EXPORT ---
export default function CardDetailPage(props: CardDetailPageProps) {
    return (
        <Suspense fallback={<div className="flex h-screen items-center justify-center text-muted">Chargement...</div>}>
            <CardDetailContent {...props} />
        </Suspense>
    );
}
</file>

<file path="app/contacts/page.tsx">
// app/contacts/page.tsx
'use client';

import { useState, useEffect } from 'react';
import Link from 'next/link';
import Image from 'next/image';
import { useAuth } from '@/lib/AuthContext';
import { useFriends, FriendProfile } from '@/hooks/useFriends';
import toast from 'react-hot-toast';
import { Search, UserPlus, Eye, X, UserMinus, Check, MessageSquare } from 'lucide-react';
import { getOrCreateDirectChat } from '@/app/actions/chat';
import ChatWindow from '@/components/chat/ChatWindow';

const PLANESWALKERS = ["Jace", "Liliana", "Chandra", "Ajani", "Garruk", "Teferi", "Nissa", "Gideon"];

export default function ContactsPage() {
  const { user } = useAuth();
  const { 
    friends, requestsReceived, loading,
    searchUsers, sendFriendRequest, acceptRequest, declineRequest, removeFriend
  } = useFriends();

  const [searchQuery, setSearchQuery] = useState('');
  const [searchResults, setSearchResults] = useState<FriendProfile[]>([]);
  const [isSearching, setIsSearching] = useState(false);
  const [randomPlaceholder, setRandomPlaceholder] = useState("Chercher...");
  
  // √âtat pour le chat actif
  const [activeChat, setActiveChat] = useState<{ chatId: string; recipientName: string } | null>(null);

  useEffect(() => {
    const randomName = PLANESWALKERS[Math.floor(Math.random() * PLANESWALKERS.length)];
    setRandomPlaceholder(`@${randomName.toLowerCase()}...`);
  }, []);

  if (!user) return <div className="p-10 text-center text-muted font-bold uppercase text-xs">Veuillez vous connecter.</div>;

  const handleSearch = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!searchQuery.trim()) return;
    setIsSearching(true);
    try {
      const results = await searchUsers(searchQuery);
      setSearchResults(results);
      if (results.length === 0) toast("Aucun utilisateur trouv√©");
    } catch (err) { 
      console.error(err); 
      toast.error("Erreur recherche"); 
    } finally { 
      setIsSearching(false); 
    }
  };

  const handleOpenChat = async (friendUid: string, friendName: string) => {
    try {
      const res = await getOrCreateDirectChat(user.uid, friendUid);
      if (res.success && res.chatId) {
        setActiveChat({ chatId: res.chatId, recipientName: friendName });
      } else {
        toast.error("Impossible d'ouvrir la discussion");
      }
    } catch (err) {
      console.error(err);
      toast.error("Erreur lors de l'ouverture du chat");
    }
  };

  return (
    <main className="container mx-auto p-4 max-w-5xl min-h-[80vh] pb-32">
      <h1 className="text-3xl font-black mb-8 text-foreground uppercase tracking-tighter">Mes Contacts</h1>

      <div className="grid md:grid-cols-2 gap-6 items-start">
        
        {/* RECHERCHE */}
        <div className="bg-surface p-5 rounded-2xl shadow-sm border border-border">
          <h2 className="font-black text-[10px] uppercase tracking-[0.2em] mb-4 text-muted flex items-center gap-2">
            <Search className="w-3 h-3" /> Chercher un ami
          </h2>
          <form onSubmit={handleSearch} className="flex gap-2 mb-4">
            <input 
              type="text" 
              placeholder={randomPlaceholder} 
              className="grow p-3 border border-border rounded-xl bg-background text-foreground outline-none focus:ring-2 focus:ring-primary font-bold text-sm lowercase"
              value={searchQuery}
              onChange={e => setSearchQuery(e.target.value.toLowerCase())}
            />
            <button type="submit" disabled={isSearching} className="bg-primary text-white px-5 rounded-xl font-black uppercase text-[10px] tracking-widest disabled:opacity-50 transition-transform active:scale-95">
              {isSearching ? '...' : 'OK'}
            </button>
          </form>
          
          <div className="space-y-2">
            {searchResults.map(result => (
              <div key={result.uid} className="flex items-center justify-between bg-background p-3 rounded-xl border border-border animate-in fade-in">
                <div className="flex items-center gap-3 min-w-0">
                  <div className="w-8 h-8 rounded-full bg-primary flex items-center justify-center text-white font-black text-xs shrink-0 overflow-hidden relative">
                    {result.photoURL ? <Image src={result.photoURL} alt="" fill className="object-cover" /> : result.username[0].toUpperCase()}
                  </div>
                  <p className="font-bold text-xs truncate">@{result.username}</p>
                </div>
                <button onClick={() => sendFriendRequest(result)} className="p-2 bg-primary text-white rounded-lg transition-transform active:scale-90 shadow-sm" title="Ajouter">
                  <UserPlus className="w-4 h-4" />
                </button>
              </div>
            ))}
          </div>
        </div>

        {/* LISTE D'AMIS & CHAT */}
        <div className="space-y-6">
          {/* Fen√™tre de Chat active */}
          {activeChat && (
            <div className="animate-in slide-in-from-top duration-300">
              <div className="flex justify-end mb-2">
                <button 
                  onClick={() => setActiveChat(null)}
                  className="text-[10px] font-black uppercase text-muted hover:text-foreground flex items-center gap-1"
                >
                  <X className="w-3 h-3" /> Fermer le chat
                </button>
              </div>
              <ChatWindow chatId={activeChat.chatId} recipientName={activeChat.recipientName} />
            </div>
          )}

          <div className="bg-surface p-5 rounded-2xl shadow-sm border border-border">
            <h2 className="font-black text-[10px] uppercase tracking-[0.2em] mb-6 text-muted">Mes Amis ({friends.length})</h2>

            {/* Demandes re√ßues */}
            {requestsReceived.length > 0 && (
              <div className="mb-8 space-y-2">
                <p className="text-[9px] font-black text-orange-500 uppercase tracking-widest mb-2">Demandes en attente</p>
                {requestsReceived.map(req => (
                  <div key={req.uid} className="flex items-center justify-between p-3 bg-orange-50/50 dark:bg-orange-950/10 border border-orange-200 dark:border-orange-900/30 rounded-xl">
                    <p className="font-bold text-xs truncate grow mr-2">@{req.username}</p>
                    <div className="flex gap-1 shrink-0">
                      <button onClick={() => acceptRequest(req)} className="w-8 h-8 bg-success text-white rounded-lg flex items-center justify-center"><Check className="w-4 h-4" /></button>
                      <button onClick={() => declineRequest(req.uid)} className="w-8 h-8 bg-danger text-white rounded-lg flex items-center justify-center"><X className="w-4 h-4" /></button>
                    </div>
                  </div>
                ))}
              </div>
            )}

            {/* Liste principale */}
            <div className="grid gap-3">
              {loading ? (
                <p className="text-muted text-[10px] font-bold uppercase p-4 text-center animate-pulse tracking-widest">Chargement...</p>
              ) : friends.length === 0 ? (
                <p className="text-muted italic text-[10px] p-8 text-center bg-background rounded-xl border border-dashed border-border uppercase">Aucun ami.</p>
              ) : (
                friends.map(friend => (
                  <div key={friend.uid} className="flex flex-col p-4 bg-background rounded-2xl border border-border hover:border-primary/40 transition-all gap-4 shadow-xs">
                    
                    <div className="flex items-center justify-between min-w-0">
                      <div className="flex items-center gap-3 min-w-0">
                        <div className="w-10 h-10 rounded-full bg-secondary border border-border shrink-0 overflow-hidden relative shadow-sm">
                          {friend.photoURL && <Image src={friend.photoURL} alt="" fill className="object-cover" sizes="40px" />}
                        </div>
                        <div className="min-w-0">
                          <p className="font-black text-sm text-foreground truncate tracking-tight">{friend.displayName}</p>
                          <p className="text-[10px] text-primary font-black uppercase tracking-tighter">@{friend.username}</p>
                        </div>
                      </div>
                      <div className="flex items-center gap-1">
                        {/* Bouton Message ajout√© */}
                        <button 
                          onClick={() => handleOpenChat(friend.uid, friend.displayName || friend.username)}
                          className="w-8 h-8 flex items-center justify-center text-primary hover:bg-primary/10 rounded-full transition-colors"
                          title="Envoyer un message"
                        >
                          <MessageSquare className="w-4 h-4" />
                        </button>
                        <button 
                          onClick={() => removeFriend(friend.uid)} 
                          className="w-8 h-8 flex items-center justify-center text-muted hover:text-danger transition-colors"
                          title="Retirer des amis"
                        >
                          <UserMinus className="w-4 h-4" />
                        </button>
                      </div>
                    </div>

                    <div className="flex items-center gap-2">
                      <Link 
                        href={`/user/${friend.uid}`} 
                        className="flex-1 flex items-center justify-center gap-2 text-[10px] bg-secondary text-foreground py-2.5 rounded-xl font-black uppercase tracking-tighter border border-border/50 hover:bg-border transition-colors"
                      >
                        <Eye className="w-3.5 h-3.5" /> Voir
                      </Link>
                      <Link 
                        href={`/trades/new/${friend.uid}`} 
                        className="flex-1 flex items-center justify-center gap-2 text-[10px] bg-primary text-white py-2.5 rounded-xl font-black uppercase tracking-tighter shadow-sm active:scale-95 transition-transform"
                      >
                          √âchanger
                      </Link>
                    </div>
                  </div>
                ))
              )}
            </div>
          </div>
        </div>
      </div>
    </main>
  );
}
</file>

<file path="components/ImportModal.tsx">
// components/ImportModal.tsx
'use client';

import React, { useState, useEffect } from 'react';
import Papa from 'papaparse';
import { useAuth } from '@/lib/AuthContext';
import toast from 'react-hot-toast';
import { importCardsAction, ImportItemInput } from '@/app/actions/import';
import AdContainer from './AdContainer'; 

type CsvRow = {
  "Name": string;
  "Set code": string;
  "Collector number": string;
  "Foil": string;
  "Quantity": string;
  "Scryfall ID": string; 
  [key: string]: string; 
};

type ImportModalProps = {
  isOpen: boolean;
  onClose: () => void;
  targetCollection?: 'collection' | 'wishlist'; 
  listId?: string;
  onGoBack?: () => void; 
  onCloseAll?: () => void;
};

export default function ImportModal({ 
    isOpen, 
    onClose,
    targetCollection = 'collection',
    listId = 'default',
    onGoBack,
    onCloseAll
}: ImportModalProps) {
  const { user } = useAuth();
  
  const [inputType, setInputType] = useState<'csv' | 'text'>('csv'); 
  const [textInput, setTextInput] = useState('');
  
  const [data, setData] = useState<CsvRow[]>([]);
  const [step, setStep] = useState<'upload' | 'preview' | 'importing'>('upload');
  const [importMode, setImportMode] = useState<'add' | 'sync'>('add'); 

  useEffect(() => {
    if (isOpen) {
        // eslint-disable-next-line react-hooks/set-state-in-effect
        setStep('upload');
        setData([]);
        setTextInput('');
        setInputType('csv');
        setImportMode('add');
    }
  }, [isOpen]);

  const handleFileUpload = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file) return;

    Papa.parse(file, {
      header: true,
      skipEmptyLines: true,
      delimiter: ",", 
      encoding: "UTF-8",
      complete: (results) => {
        const fields = results.meta.fields || [];
        if (!fields.includes("Name") && !fields.includes("Scryfall ID")) {
            toast.error("Format CSV non reconnu (Manabox ou Deckbox requis)");
            return;
        }
        setData(results.data as CsvRow[]);
        setStep('preview');
      },
      error: (error) => toast.error("Erreur lecture CSV : " + error.message)
    });
  };

  const handleTextParse = () => {
    if (!textInput.trim()) return;

    const rows: CsvRow[] = [];
    const lines = textInput.split('\n');
    
    const regex = /^(\d+)x?\s+(.+?)\s+\(([a-zA-Z0-9]+)\)\s+(\S+)(?:\s+\*(F)\*)?/i;

    lines.forEach(line => {
        const cleanLine = line.trim();
        if (!cleanLine) return;
        
        const match = cleanLine.match(regex);
        if (match) {
            rows.push({
                "Quantity": match[1],
                "Name": match[2],
                "Set code": match[3].toLowerCase(),
                "Collector number": match[4] || '',
                "Foil": match[5] === 'F' ? "true" : "false",
                "Scryfall ID": ""
            });
        }
    });

    if (rows.length === 0) {
        toast.error("Aucune ligne valide reconnue.");
        return;
    }
    setData(rows);
    setStep('preview');
  };

  const startImport = async () => {
    if (!user) return;
    setStep('importing');

    const cleanItems: ImportItemInput[] = data.map(row => ({
        scryfallId: row["Scryfall ID"] || undefined,
        name: row["Name"] || "Unknown",
        set: row["Set code"] || "",
        collectorNumber: row["Collector number"] || "",
        quantity: parseInt(row["Quantity"]) || 1,
        isFoil: row["Foil"]?.toLowerCase() === "true"
    })).filter(item => item.name !== "Unknown" || item.scryfallId);

    if (cleanItems.length === 0) {
        toast.error("Aucune donn√©e valide √† importer.");
        setStep('preview');
        return;
    }

    try {
        const result = await importCardsAction(
            user.uid,
            targetCollection,
            importMode,
            cleanItems,
            listId 
        );

        if (result.success) {
            toast.success(`Op√©ration termin√©e. ${result.count} cartes trait√©es.`);
            if (onCloseAll) onCloseAll();
            else onClose();
        } else {
            toast.error(`Erreur: ${result.error}`);
            setStep('preview');
        }

    } catch (e) {
        console.error("Erreur client import:", e);
        toast.error("Erreur de communication avec le serveur.");
        setStep('preview');
    }
  };

  const handleBackdropClick = () => {
      if (step !== 'importing') {
          if (onGoBack) onGoBack();
          else onClose();
      }
  };

  if (!isOpen) return null;

  const targetLabel = targetCollection === 'collection' ? 'Collection' : 'Wishlist';

  return (
    <div className="fixed inset-0 bg-black/60 flex items-center justify-center z-50 p-4 backdrop-blur-sm" onClick={handleBackdropClick}>
      <div 
        className="bg-surface rounded-xl p-6 max-w-5xl w-full shadow-2xl border border-border flex flex-col max-h-[90vh]"
        onClick={(e) => e.stopPropagation()}
      >
        <div className="flex-none flex justify-between items-center mb-4 border-b border-border pb-3">
            <div className="flex items-center gap-3">
                {step !== 'importing' && onGoBack && (
                    <button onClick={onGoBack} className="text-muted hover:text-foreground text-xl p-1 rounded transition">‚Üê</button>
                )}
                <h2 className="text-xl font-bold text-foreground">
                    Importer : {targetLabel} {listId !== 'default' && <span className="text-xs font-normal text-muted ml-2">({listId})</span>}
                </h2>
            </div>
            {step !== 'importing' && onCloseAll && (
                <button onClick={onCloseAll} className="text-muted hover:text-danger text-lg p-2">‚úï</button>
            )}
        </div>

        <div className="grow overflow-hidden flex flex-col min-h-0">
            {step === 'upload' && (
                <div className="flex flex-col h-full overflow-hidden">
                    <p className="text-sm text-muted mb-4 flex-none">
                        Formats support√©s : Manabox (CSV), Deckbox (CSV), ou texte copi√©.
                    </p>
                    <div className="flex-none flex border-b border-border mb-4">
                        <button onClick={() => setInputType('csv')} className={`px-4 py-2 font-medium text-sm border-b-2 transition-colors ${inputType === 'csv' ? 'border-primary text-primary' : 'border-transparent text-muted'}`}>Fichier CSV</button>
                        <button onClick={() => setInputType('text')} className={`px-4 py-2 font-medium text-sm border-b-2 transition-colors ${inputType === 'text' ? 'border-primary text-primary' : 'border-transparent text-muted'}`}>Coller Texte</button>
                    </div>
                    
                    {inputType === 'csv' ? (
                        <div className="grow p-12 border-2 border-dashed border-border rounded-xl text-center hover:bg-secondary transition relative cursor-pointer group flex flex-col items-center justify-center">
                            <input type="file" accept=".csv" onChange={handleFileUpload} className="absolute inset-0 w-full h-full opacity-0 cursor-pointer z-50" />
                            <div className="text-6xl mb-4 text-muted">[CSV]</div>
                            <p className="font-bold text-lg text-foreground">D√©poser un fichier CSV</p>
                        </div>
                    ) : (
                        <div className="grow flex flex-col min-h-0">
                            <textarea 
                                value={textInput} 
                                onChange={(e) => setTextInput(e.target.value)} 
                                rows={15} 
                                placeholder="Ex: 1x Sol Ring (CMD) 100 *F*" 
                                className="grow w-full p-4 rounded-lg border border-border bg-background text-foreground font-mono text-xs focus:ring-2 focus:ring-primary outline-none resize-none" 
                            />
                            <button 
                                onClick={handleTextParse} 
                                disabled={!textInput.trim()} 
                                className="flex-none mt-4 bg-primary hover:opacity-90 disabled:opacity-50 text-primary-foreground font-bold py-3 rounded-xl shadow-md transition"
                            >
                                Analyser le texte
                            </button>
                        </div>
                    )}
                </div>
            )}

            {step === 'preview' && (
                <div className="flex flex-col h-full overflow-hidden">
                    <p className="text-sm text-muted mb-4 flex-none">
                        {data.length} cartes d√©tect√©es.
                    </p>
                    <div className="flex-none grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                        <div onClick={() => setImportMode('add')} className={`p-4 rounded-xl border-2 cursor-pointer transition flex flex-col gap-1 ${importMode === 'add' ? 'border-primary bg-primary/5' : 'border-border hover:border-primary/50'}`}>
                            <div className="flex items-center gap-2 font-bold text-primary text-sm">
                                <span className={`w-4 h-4 rounded-full border flex items-center justify-center ${importMode === 'add' ? 'border-primary bg-primary' : 'border-muted'}`}>{importMode === 'add' && <span className="w-2 h-2 rounded-full bg-white"></span>}</span> 
                                Mode Ajout (Add)
                            </div>
                        </div>
                        <div onClick={() => setImportMode('sync')} className={`p-4 rounded-xl border-2 cursor-pointer transition flex flex-col gap-1 ${importMode === 'sync' ? 'border-purple-600 bg-purple-500/5' : 'border-border hover:border-purple-500/50'}`}>
                            <div className="flex items-center gap-2 font-bold text-purple-600 dark:text-purple-300 text-sm">
                                <span className={`w-4 h-4 rounded-full border flex items-center justify-center ${importMode === 'sync' ? 'border-purple-600 bg-purple-600' : 'border-muted'}`}>{importMode === 'sync' && <span className="w-2 h-2 rounded-full bg-white"></span>}</span> 
                                Mode Compl√©tion (Smart Sync)
                            </div>
                        </div>
                    </div>
                    <div className="grow overflow-auto min-h-0 border border-border rounded-lg bg-background mb-4">
                        <table className="w-full text-xs text-left text-muted">
                            <thead className="text-foreground bg-secondary sticky top-0 z-10">
                                <tr>
                                    <th className="px-4 py-2">Nom</th>
                                    <th className="px-4 py-2">Set</th>
                                    <th className="px-4 py-2">Num</th>
                                    <th className="px-4 py-2">Qt√©</th>
                                    <th className="px-4 py-2">Foil</th>
                                </tr>
                            </thead>
                            <tbody>
                                {data.slice(0, 100).map((row, i) => (
                                    <tr key={i} className="bg-surface border-b border-border">
                                        <td className="px-4 py-1 truncate max-w-[150px] text-foreground">{row["Name"]}</td>
                                        <td className="px-4 py-1">{row["Set code"]}</td>
                                        <td className="px-4 py-1">{row["Collector number"]}</td>
                                        <td className="px-4 py-1 font-bold">{row["Quantity"]}</td>
                                        <td className="px-4 py-1">{row["Foil"]}</td>
                                    </tr>
                                ))}
                            </tbody>
                        </table>
                    </div>
                    <div className="flex-none pt-2">
                        <button onClick={startImport} className="w-full text-white font-bold py-3 rounded-xl shadow-lg bg-primary hover:opacity-90">
                            {importMode === 'add' ? 'Valider l\'Ajout' : 'Valider la Synchronisation'}
                        </button>
                    </div>
                </div>
            )}

           {step === 'importing' && (
                <div className="flex flex-col items-center justify-center h-full py-10 text-center">
                    <div className="w-16 h-16 border-4 border-primary border-t-transparent rounded-full animate-spin mb-6"></div>
                    <h3 className="text-xl font-bold text-foreground mb-2">Importation en cours...</h3>
                    <p className="text-muted text-sm max-w-md mb-8">Ne fermez pas cette fen√™tre.</p>
                    <div className="w-full max-w-md">
                        {/* CORRECTION : Utilisation de la prop 'slot' uniquement */}
                        <AdContainer slot="1234567890" />
                    </div>
                </div>
            )}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="components/CardVersionPickerModal.tsx">
// components/CardVersionPickerModal.tsx
'use client';

import { useState, useEffect, useMemo } from 'react';
import Image from 'next/image';
import { CardType } from '@/hooks/useCardCollection';
import { normalizeCardData, ScryfallRawData } from '@/lib/cardUtils'; 
// eslint-disable-next-line @typescript-eslint/no-unused-vars
import { WishlistMeta } from '@/hooks/useWishlists'; 
// On r√©utilise le type WishlistMeta car CollectionMeta a la m√™me structure (id, name, createdAt)
import { useAuth } from '@/lib/AuthContext'; 
import toast from 'react-hot-toast';

type ListMeta = {
  id: string;
  name: string;
  createdAt?: { seconds: number; nanoseconds: number };
};

type Props = {
  isOpen: boolean;
  onClose: () => void;
  baseCard: ScryfallRawData | null; 
  onConfirm: (card: CardType, targetListId?: string) => void;
  destination?: 'collection' | 'wishlist'; 
  availableLists?: ListMeta[]; // Peut √™tre des collections ou des wishlists
};

interface ScryfallSearchResponse {
  data: ScryfallRawData[];
  has_more: boolean;
  next_page?: string;
  total_cards: number;
}

export default function CardVersionPickerModal({ 
  isOpen, onClose, baseCard, onConfirm, destination, availableLists 
}: Props) {
  const { userProfile } = useAuth();
  const [versions, setVersions] = useState<ScryfallRawData[]>([]);
  const [loading, setLoading] = useState(false);
  
  const [selectedVersionId, setSelectedVersionId] = useState<string>('');
  const [isFoil, setIsFoil] = useState(false);
  const [quantity, setQuantity] = useState(1);
  const [isFlipped, setIsFlipped] = useState(false); 
  const [anyVersion, setAnyVersion] = useState(false);
  
  const [selectedListId, setSelectedListId] = useState<string>('default');

  // Tri pour coh√©rence index 0 = gratuit
  const sortedAvailableLists = useMemo(() => {
      if (!availableLists) return [];
      return [...availableLists].sort((a, b) => (a.createdAt?.seconds || 0) - (b.createdAt?.seconds || 0));
  }, [availableLists]);

  const isPremium = userProfile?.isPremium ?? false;
  const MAX_FREE_LISTS = 1;

  useEffect(() => {
    const fetchVersions = async (oracleId: string) => {
        setLoading(true);
        try {
          const res = await fetch(`https://api.scryfall.com/cards/search?q=oracle_id:${oracleId}%20game:paper&unique=prints&order=released`);
          const data: ScryfallSearchResponse = await res.json();
          
          if (data.data && data.data.length > 0) {
            setVersions(data.data); 
            const defaultVer = data.data.find((c: ScryfallRawData) => c.id === baseCard?.id) || data.data[0];
            setSelectedVersionId(defaultVer.id);
          }
        } catch (e) {
          console.error(e);
          toast.error("Impossible de charger les versions");
        } finally {
          setLoading(false);
        }
    };

    if (isOpen && baseCard?.oracle_id) {
      fetchVersions(baseCard.oracle_id as string);
    }

    setQuantity(1);
    setIsFlipped(false);
    setAnyVersion(false);
    
    // On s√©lectionne par d√©faut la premi√®re liste accessible (la gratuite)
    if (sortedAvailableLists.length > 0) {
        setSelectedListId(sortedAvailableLists[0].id);
    } else {
        setSelectedListId('default');
    }
  }, [isOpen, baseCard, sortedAvailableLists]); 

  const currentCardRaw = useMemo(() => {
    return versions.find(v => v.id === selectedVersionId) || baseCard;
  }, [versions, selectedVersionId, baseCard]);

  const priceNormal = parseFloat(currentCardRaw?.prices?.eur || "0");
  const priceFoil = parseFloat(currentCardRaw?.prices?.eur_foil || "0");
  
  const hasFoilVersion = currentCardRaw?.finishes?.includes('foil') || priceFoil > 0;
  const hasNonFoilVersion = currentCardRaw?.finishes?.includes('nonfoil') || priceNormal > 0;

  useEffect(() => {
    if (!currentCardRaw) return;

    if (isFoil && !hasFoilVersion && hasNonFoilVersion) {
        setIsFoil(false);
    } else if (!isFoil && !hasNonFoilVersion && hasFoilVersion) {
        setIsFoil(true);
    }
  }, [isFoil, hasFoilVersion, hasNonFoilVersion, currentCardRaw]);

  if (!isOpen || !currentCardRaw) return null;

  const { imageUrl, imageBackUrl, name, setName, setCode } = normalizeCardData(currentCardRaw);

  const currentPrice = isFoil 
    ? (priceFoil > 0 ? priceFoil : 0) 
    : (priceNormal > 0 ? priceNormal : 0);

  const handleConfirm = () => {
    const finalCard: CardType = {
        id: currentCardRaw.id,
        name: name,
        imageUrl: imageUrl,
        imageBackUrl: imageBackUrl || null,
        quantity: quantity,
        price: currentPrice,
        setName: setName,
        setCode: setCode,
        isFoil: isFoil,
        isSpecificVersion: !anyVersion,
        scryfallData: currentCardRaw,
        // On assigne l'ID de la liste cible selon la destination
        wishlistId: destination === 'wishlist' ? selectedListId : undefined,
        // Note: Pour 'collection', l'ID est g√©r√© par le parent (onConfirm) via le second argument
        uid: '',
        quantityForTrade: 0
    };
    
    onConfirm(finalCard, selectedListId);
    onClose();
  };

  const handleAnyVersionChange = (checked: boolean) => {
      setAnyVersion(checked);
      if (checked && versions.length > 0) {
          const sorted = [...versions].sort((a, b) => 
              (b.released_at || '').localeCompare(a.released_at || '')
          );
          const newest = sorted[0];
          if (newest) {
              setSelectedVersionId(newest.id);
              setIsFlipped(false);
          }
      }
  };

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black/90 backdrop-blur-sm animate-in fade-in duration-200">
      <div className="bg-surface w-full max-w-md rounded-2xl overflow-hidden shadow-2xl border border-border flex flex-col max-h-[90vh]">
        
        <div className="p-4 flex justify-between items-center border-b border-border bg-surface">
            <h3 className="text-foreground font-bold truncate pr-4">{name}</h3>
            <button onClick={onClose} className="text-muted hover:text-foreground px-2 text-sm font-bold">Fermer</button>
        </div>

        <div className="overflow-y-auto p-6 flex flex-col items-center space-y-6 custom-scrollbar bg-background">
            
            <div 
              className="relative w-72 aspect-[2.5/3.5] group cursor-pointer bg-transparent" 
              onClick={() => imageBackUrl && setIsFlipped(!isFlipped)}
            >
                {loading ? (
                    <div className="w-full h-full bg-secondary animate-pulse flex items-center justify-center text-muted rounded-[4.5%]">Chargement...</div>
                ) : (
                    <div className="relative w-full h-full shadow-[0_20px_50px_rgba(0,0,0,0.5)] rounded-[4.5%] overflow-hidden">
                        <Image 
                          src={isFlipped && imageBackUrl ? imageBackUrl : imageUrl} 
                          alt={name} 
                          fill
                          sizes="300px"
                          priority
                          className={`object-cover transition-transform duration-300 ${anyVersion ? 'opacity-80 grayscale-50' : ''}`} 
                        />
                        {isFoil && !anyVersion && (
                            <div className="absolute inset-0 bg-linear-to-tr from-purple-500/20 via-transparent to-white/10 mix-blend-overlay pointer-events-none" />
                        )}
                    </div>
                )}
                {anyVersion && (
                    <div className="absolute inset-0 flex items-center justify-center pointer-events-none z-10">
                        <span className="bg-primary text-primary-foreground font-bold px-3 py-1 rounded-full text-sm shadow-lg border border-white/20">Generique</span>
                    </div>
                )}
            </div>

            {/* S√âLECTEUR DE LISTE (COLLECTION OU WISHLIST) */}
            {sortedAvailableLists.length > 0 && (
                <div className="w-full space-y-1 bg-purple-500/10 p-3 rounded-xl border border-purple-500/30">
                    <label className="text-xs text-purple-600 dark:text-purple-300 font-bold uppercase tracking-wider">
                        Ajouter a la {destination === 'wishlist' ? 'liste' : 'collection'} :
                    </label>
                    <select 
                        value={selectedListId}
                        onChange={(e) => setSelectedListId(e.target.value)}
                        className="w-full bg-surface text-foreground border border-border rounded-lg p-2 text-sm focus:ring-2 focus:ring-purple-500 outline-none"
                    >
                        {sortedAvailableLists.map((list, index) => {
                            // VERROUILLAGE : Index >= 1 et pas Premium
                            const isLocked = !isPremium && index >= MAX_FREE_LISTS;
                            
                            return (
                                <option 
                                    key={list.id} 
                                    value={list.id}
                                    disabled={isLocked} // Emp√™che de s√©lectionner une liste verrouill√©e
                                >
                                    {list.name} {isLocked ? '(Verrouill√©)' : ''}
                                </option>
                            );
                        })}
                    </select>
                </div>
            )}

            <div className={`w-full space-y-2 transition-opacity ${anyVersion ? 'opacity-50 pointer-events-none' : 'opacity-100'}`}>
                <label className="text-xs text-muted uppercase font-bold tracking-wider">Edition / Set</label>
                <div className="relative">
                    <select 
                        className="w-full bg-surface text-foreground border border-border rounded-xl p-3 appearance-none focus:ring-2 focus:ring-primary outline-none text-sm"
                        value={selectedVersionId}
                        onChange={(e) => { setSelectedVersionId(e.target.value); setIsFlipped(false); }}
                    >
                        {versions.map((v) => (
                            <option key={v.id} value={v.id}>{v.set_name} ({v.set.toUpperCase()}) #{v.collector_number}</option>
                        ))}
                    </select>
                </div>
            </div>

            <div className="w-full space-y-4">
                {destination === 'wishlist' && (
                    <label className="flex items-center justify-between bg-primary/10 p-3 rounded-xl border border-primary/20 cursor-pointer hover:bg-primary/20 transition">
                        <div className="flex flex-col">
                            <span className="text-sm font-bold text-primary">Peu importe l&apos;edition</span>
                            <span className="text-[10px] text-muted">Selectionnera la version la plus recente</span>
                        </div>
                        <div className="relative inline-flex items-center cursor-pointer">
                            <input 
                                type="checkbox" 
                                className="sr-only peer" 
                                checked={anyVersion} 
                                onChange={(e) => handleAnyVersionChange(e.target.checked)} 
                            />
                            <div className="w-11 h-6 bg-gray-200 dark:bg-gray-700 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-0.5 after:left-0.5 after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-primary"></div>
                        </div>
                    </label>
                )}

                <div className="flex gap-4">
                    <div className={`flex-1 bg-surface rounded-xl p-2 flex flex-col items-center justify-center gap-1 border border-border transition-opacity ${anyVersion ? 'opacity-30 pointer-events-none' : ''}`}>
                        <span className="text-[10px] text-muted font-bold uppercase">Finition</span>
                        <div className="flex bg-secondary rounded-lg p-1 w-full">
                            <button 
                                onClick={() => setIsFoil(false)} 
                                disabled={!hasNonFoilVersion} 
                                className={`flex-1 text-[10px] py-1 rounded transition 
                                    ${!isFoil ? 'bg-surface text-foreground font-bold shadow-sm' : 'text-muted'} 
                                    ${!hasNonFoilVersion && 'opacity-30 cursor-not-allowed'}`}
                            >
                                {hasNonFoilVersion ? 'Normal' : 'N/A'}
                            </button>
                            <button 
                                onClick={() => setIsFoil(true)} 
                                disabled={!hasFoilVersion} 
                                className={`flex-1 text-[10px] py-1 rounded transition 
                                    ${isFoil ? 'bg-purple-600 text-white font-bold shadow-sm' : 'text-muted'} 
                                    ${!hasFoilVersion && 'opacity-30 cursor-not-allowed'}`}
                            >
                                {hasFoilVersion ? 'Foil' : 'N/A'}
                            </button>
                        </div>
                    </div>

                    <div className="flex-1 bg-surface rounded-xl p-2 flex flex-col items-center justify-center gap-1 border border-border">
                         <span className="text-[10px] text-muted font-bold uppercase">Quantite</span>
                         <div className="flex items-center gap-3">
                            <button onClick={() => setQuantity(Math.max(1, quantity - 1))} className="w-6 h-6 rounded-full bg-secondary text-foreground font-bold hover:bg-border transition">-</button>
                            <span className="text-lg font-bold text-foreground w-4 text-center">{quantity}</span>
                            <button onClick={() => setQuantity(quantity + 1)} className="w-6 h-6 rounded-full bg-primary text-primary-foreground font-bold hover:opacity-90 transition">+</button>
                         </div>
                    </div>
                </div>

                <div className="w-full text-center p-2 bg-secondary rounded-lg border border-border">
                    <p className="text-sm font-medium text-foreground">
                        Prix estime : 
                        <span className={`font-bold ml-2 ${currentPrice > 0 ? 'text-success' : 'text-muted'}`}>
                           {currentPrice > 0 ? `${currentPrice.toFixed(2)} EUR` : 'N/A'}
                        </span>
                    </p>
                </div>
            </div>
        </div>

        <div className="p-4 bg-surface border-t border-border">
            <button 
                onClick={handleConfirm}
                className={`w-full font-bold py-4 rounded-xl text-lg transition shadow-lg transform active:scale-95 flex justify-center items-center gap-2 ${anyVersion ? 'bg-primary text-primary-foreground hover:opacity-90' : 'bg-amber-500 hover:bg-amber-400 text-black'}`}
            >
                <span>{anyVersion ? 'Ajouter (Generique)' : 'Ajouter (Exact)'}</span>
                {quantity > 1 && <span className="bg-black/20 px-2 py-0.5 rounded text-sm">{quantity}x</span>}
            </button>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="hooks/useTradeMatcher.ts">
// hooks/useTradeMatcher.ts
import { useState } from 'react';
import { useAuth } from '@/lib/AuthContext';
import { runServerScan, ScannedProposal } from '@/app/actions/scanner';
import { FriendProfile } from './useFriends';
import { CardType } from '@/hooks/useCardCollection';

// Export du type n√©cessaire pour app/trades/page.tsx
export type TradeProposal = {
  friend: FriendProfile;
  toReceive: CardType[]; 
  toGive: CardType[];    
  balance: number;       
};

export function useTradeMatcher() {
  const { user } = useAuth();
  
  const [proposals, setProposals] = useState<TradeProposal[]>([]);
  const [loading, setLoading] = useState(false);
  const [status, setStatus] = useState("");

  const runScan = async () => {
    if (!user) return;
    setLoading(true);
    setStatus("Analyse cloud en cours...");

    try {
        // Appel de la Server Action d√©finie dans app/actions/scanner.ts
        const result = await runServerScan(user.uid);

        if (!result.success || !result.proposals) {
            setStatus("Erreur lors de l'analyse.");
            setLoading(false);
            return;
        }

        // Mapping des r√©sultats du serveur (ScannedProposal) vers le format client (TradeProposal)
        const mappedProposals: TradeProposal[] = result.proposals.map((p: ScannedProposal) => ({
            friend: {
                uid: p.partnerInfo.uid,
                username: 'Utilisateur', // Valeur par d√©faut car non critique pour l'affichage ici
                displayName: p.partnerInfo.displayName,
                photoURL: p.partnerInfo.photoURL || undefined // Conversion null -> undefined pour le type FriendProfile
            },
            toReceive: p.toReceive,
            toGive: p.toGive,
            balance: p.balance
        }));

        setProposals(mappedProposals);
        
        if (mappedProposals.length > 0) {
            setStatus("Scan termine avec succes.");
        } else {
            setStatus("Aucun echange trouve.");
        }

    } catch (error: unknown) {
        console.error("Erreur hook scanner:", error);
        setStatus("Erreur technique lors du scan.");
    } finally {
        setLoading(false);
    }
  };

  return { proposals, loading, status, runScan }; 
}
</file>

<file path="app/page.tsx">
// app/page.tsx
'use client';

import { useAuth } from '@/lib/AuthContext';
import { useCardCollection, CardType } from '@/hooks/useCardCollection';
import { useTradeSystem } from '@/hooks/useTradeSystem';
import Link from 'next/link';
import Image from 'next/image';
import { useState, useEffect } from 'react';
import { db } from '@/lib/firebase';
import { collection, query, orderBy, limit, getDocs } from 'firebase/firestore';

export default function DashboardPage() {
  const { user, loading: authLoading, friendRequestCount, username } = useAuth();
  const { totalPrice, cards } = useCardCollection('collection'); 
  const { incomingTrades, outgoingTrades } = useTradeSystem(); 
  
  const [recentCards, setRecentCards] = useState<CardType[]>([]);

  useEffect(() => {
    const fetchRecent = async () => {
      if (!user) return;
      try {
        const q = query(
            collection(db, 'users', user.uid, 'collection'), 
            orderBy('addedAt', 'desc'), 
            limit(5)
        );
        const snap = await getDocs(q);
        setRecentCards(snap.docs.map(d => ({ id: d.id, ...d.data() } as CardType)));
      } catch (e) { console.error(e); }
    };
    fetchRecent();
  }, [user]);

  if (authLoading) return <div className="flex h-screen items-center justify-center animate-pulse text-primary">Chargement...</div>;

  // --- VUE D√âCONNECT√âE (LANDING PAGE) ---
  if (!user) {
    return (
      <div className="flex flex-col min-h-[90vh]">
        
        {/* HERO SECTION */}
        <section className="flex-1 flex flex-col items-center justify-center text-center p-6 space-y-8 max-w-4xl mx-auto mt-10">
            <div className="space-y-4">
                <span className="bg-primary/10 text-primary px-4 py-1.5 rounded-full text-xs font-bold uppercase tracking-wider">
                    B√™ta v1.0
                </span>
                <h1 className="text-5xl md:text-7xl font-black text-foreground tracking-tight">
                    G√©rez vos cartes <br/>
                    <span className="bg-linear-to-r from-primary to-purple-600 bg-clip-text text-transparent">Magic: The Gathering</span>
                </h1>
                <p className="text-xl text-muted max-w-2xl mx-auto leading-relaxed">
                    Importez votre collection, cr√©ez des wishlists et trouvez automatiquement des √©changes avec vos amis gr√¢ce √† notre scanner intelligent.
                </p>
            </div>

            <div className="flex flex-col sm:flex-row gap-4 w-full justify-center">
                <Link 
                    href="/login"
                    className="btn-primary py-4 px-8 rounded-xl text-lg shadow-lg shadow-primary/25 transition transform hover:scale-105"
                >
                    Commencer gratuitement
                </Link>
                
            </div>
        </section>

        {/* FEATURES GRID */}
        <section id="features" className="container mx-auto px-4 py-20">
            <div className="grid md:grid-cols-3 gap-8">
                {/* Feature 1 */}
                <div className="bg-surface p-8 rounded-2xl border border-border shadow-sm hover:shadow-md transition">
                    <div className="w-12 h-12 bg-blue-100 dark:bg-blue-900/30 rounded-xl flex items-center justify-center text-2xl mb-4">üìö</div>
                    <h3 className="text-xl font-bold text-foreground mb-2">Collection & Prix</h3>
                    <p className="text-muted">Suivez la valeur de votre collection en temps r√©el gr√¢ce √† l&apos;int√©gration Scryfall.</p>
                </div>
                {/* Feature 2 */}
                <div className="bg-surface p-8 rounded-2xl border border-border shadow-sm hover:shadow-md transition">
                    <div className="w-12 h-12 bg-purple-100 dark:bg-purple-900/30 rounded-xl flex items-center justify-center text-2xl mb-4">ü§ù</div>
                    <h3 className="text-xl font-bold text-foreground mb-2">√âchanges Intelligents</h3>
                    <p className="text-muted">Notre algorithme croise votre collection avec les wishlists de vos amis pour proposer des deals.</p>
                </div>
                {/* Feature 3 */}
                <div className="bg-surface p-8 rounded-2xl border border-border shadow-sm hover:shadow-md transition">
                    <div className="w-12 h-12 bg-green-100 dark:bg-green-900/30 rounded-xl flex items-center justify-center text-2xl mb-4">‚ú®</div>
                    <h3 className="text-xl font-bold text-foreground mb-2">Wishlist Centralis√©e</h3>
                    <p className="text-muted">G√©rez vos recherches et partagez-les automatiquement avec votre cercle de jeu.</p>
                </div>
            </div>
        </section>

      </div>
    );
  }

  // --- VUE CONNECT√âE (DASHBOARD) ---
  const cardStyle = "p-6 rounded-2xl border border-border transition-all duration-200 shadow-sm hover:shadow-md hover:-translate-y-1 group bg-surface hover:border-primary";

  return (
    <main className="container mx-auto p-4 max-w-5xl">
      <div className="mb-8">
        <h1 className="text-3xl font-bold text-foreground">
          Bonjour, <span className="text-primary">{username || user.displayName}</span>
        </h1>
        <p className="text-muted">Tableau de bord</p>
      </div>

      <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-8">
        
        {/* CARTE ECHANGES (Redirection intelligente) */}
        <Link 
            href={incomingTrades.length > 0 ? "/trades?tab=requests" : "/trades"} 
            className={`${cardStyle} 
            ${incomingTrades.length > 0 ? 'bg-orange-50 border-orange-300 dark:bg-orange-900/20 dark:border-orange-800' : ''}`}
        >
            <div className="flex justify-between items-start mb-2">
                <span className={`font-bold text-lg group-hover:text-primary transition-colors ${incomingTrades.length > 0 ? 'text-orange-700 dark:text-orange-400' : 'text-foreground'}`}>
                    √âchanges
                </span>
                {incomingTrades.length > 0 && <span className="bg-orange-500 text-white text-xs font-bold px-2 py-1 rounded-full animate-pulse">{incomingTrades.length}</span>}
            </div>
            <p className="text-sm text-muted group-hover:text-foreground">
                {incomingTrades.length > 0 ? "Propositions en attente !" : `${outgoingTrades.length} propositions en cours.`}
            </p>
        </Link>

        {/* CARTE CONTACTS */}
        <Link href="/contacts" className={`${cardStyle} ${friendRequestCount > 0 ? 'bg-primary/5 border-primary/30' : ''}`}>
            <div className="flex justify-between items-start mb-2">
                <span className={`font-bold text-lg group-hover:text-primary transition-colors ${friendRequestCount > 0 ? 'text-primary' : 'text-foreground'}`}>
                    Contacts
                </span>
                {friendRequestCount > 0 && <span className="bg-primary text-primary-foreground text-xs font-bold px-2 py-1 rounded-full">{friendRequestCount}</span>}
            </div>
            <p className="text-sm text-muted group-hover:text-foreground">
                {friendRequestCount > 0 ? "Nouvelles demandes d'amis." : "G√©rer ma liste d'amis."}
            </p>
        </Link>

        {/* CARTE TOTAL */}
        <Link href="/collection" className={cardStyle}>
            <div className="flex justify-between items-start mb-2">
                <span className="font-bold text-lg text-foreground group-hover:text-primary transition-colors">Total</span>
                <span className="text-success font-bold bg-success/10 px-2 py-1 rounded text-xs">{totalPrice.toFixed(2)} ‚Ç¨</span>
            </div>
            <p className="text-sm text-muted group-hover:text-foreground">
                {cards.length} cartes collectionn√©es.
            </p>
        </Link>
      </div>

      <div className="grid lg:grid-cols-3 gap-8">
          {/* LISTE R√âCENTS */}
          <div className="lg:col-span-2 space-y-4">
              <div className="flex justify-between items-center">
                  <h2 className="font-bold text-lg text-foreground">Derniers ajouts</h2>
                  <Link href="/collection" className="text-sm text-primary hover:underline font-medium">Tout voir</Link>
              </div>
              
              <div className="bg-surface rounded-xl border border-border overflow-hidden shadow-sm">
                  {recentCards.length === 0 ? (
                      <div className="p-8 text-center text-muted">
                          Pas encore de cartes ? <Link href="/collection" className="text-primary underline">Importez-en !</Link>
                      </div>
                  ) : (
                      recentCards.map((card) => (
                          <div key={card.id} className="flex items-center gap-4 p-3 border-b border-border last:border-0 hover:bg-secondary/50 transition">
                              <div className="w-10 h-14 bg-secondary rounded overflow-hidden shrink-0">
                                  <Image src={card.imageUrl} width={40} height={56} className="w-full h-full object-cover" alt={card.name} />
                              </div>
                              <div className="grow">
                                  <p className="font-semibold text-sm text-foreground">{card.name}</p>
                                  <p className="text-xs text-muted">{card.setName} {card.isFoil && <span className="text-amber-600 bg-amber-50 dark:bg-amber-900/30 dark:text-amber-400 px-1 rounded text-[9px] font-bold">Foil</span>}</p>
                              </div>
                              <div className="text-right">
                                  <span className="font-medium text-foreground text-sm">{(card.customPrice ?? card.price ?? 0).toFixed(2)} ‚Ç¨</span>
                              </div>
                          </div>
                      ))
                  )}
              </div>
          </div>

          {/* ACTION RAPIDE */}
          <div className="space-y-6">
              <div className="bg-primary rounded-xl p-6 text-primary-foreground shadow-lg shadow-primary/20">
                  <h3 className="font-bold text-lg mb-2">Action Rapide</h3>
                  <p className="text-primary-foreground/80 text-sm mb-6">Ajout rapide apr√®s ouverture de boosters ?</p>
                  
                  <Link href="/search" className="block w-full bg-surface text-primary font-bold text-center py-3 rounded-lg hover:bg-secondary transition shadow-sm mb-3">
                      Ajouter des cartes
                  </Link>
                  <Link href="/trades/manual" className="block w-full bg-black/20 hover:bg-black/30 text-white font-bold text-center py-3 rounded-lg transition border border-white/10">
                      √âchange Manuel
                  </Link>
              </div>

              {/* ASTUCE */}
              <div className="bg-surface rounded-xl border-l-4 shadow-sm p-6 border-y border-r border-border">
                  <h3 className="font-bold text-foreground mb-2">Astuce</h3>
                  <p className="text-sm text-muted mb-4">
                      Remplissez votre Wishlist pour aider le scanner √† trouver des √©changes.
                  </p>
                  <Link href="/wishlist" className="text-sm font-bold text-primary hover:underline">
                      G√©rer ma Wishlist
                  </Link>
              </div>
          </div>
      </div>
    </main>
  );
}
</file>

<file path="components/Header.tsx">
// components/Header.tsx
'use client';

import { useState, useRef, useMemo } from 'react';
import Link from 'next/link';
import Image from 'next/image';
import { useAuth } from '@/lib/AuthContext';
import { usePathname, useRouter, useSearchParams } from 'next/navigation';
import ThemeToggle from './ThemeToggle';
import { useCollections } from '@/hooks/useCollections';
import { useWishlists } from '@/hooks/useWishlists';
import { CreditsDisplay } from '@/components/CreditsDisplay';
import { Lock } from 'lucide-react'; // Ic√¥ne professionnelle

export default function Header() {
  const { user, userProfile, friendRequestCount, logOut } = useAuth();
  
  const { lists: collectionLists, createList: createCollection } = useCollections();
  const { lists: wishlistLists, createList: createWishlist } = useWishlists();

  const router = useRouter();
  const pathname = usePathname();
  const searchParams = useSearchParams();
  
  const [isMenuOpen, setIsMenuOpen] = useState(false);
  
  const [showCollectionSubmenu, setShowCollectionSubmenu] = useState(false);
  const [showWishlistSubmenu, setShowWishlistSubmenu] = useState(false);
  
  const collectionTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const wishlistTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  
  const [isMobileCollectionOpen, setIsMobileCollectionOpen] = useState(false);
  const [isMobileWishlistOpen, setIsMobileWishlistOpen] = useState(false);
  const [isMobileSocialOpen, setIsMobileSocialOpen] = useState(false);

  // --- LOGIQUE PREMIUM ---
  const isPremium = userProfile?.isPremium ?? false;
  const MAX_FREE_LISTS = 1;

  // Cr√©ation bloqu√©e si limite atteinte
  const canCreateCollection = isPremium || collectionLists.length < MAX_FREE_LISTS;
  const canCreateWishlist = isPremium || wishlistLists.length < MAX_FREE_LISTS;

  // --- TRI DES LISTES ---
  // On trie par date pour que la liste "Gratuite" (la plus ancienne) soit toujours en premier
  const sortedWishlists = useMemo(() => {
    return [...wishlistLists].sort((a, b) => (a.createdAt?.seconds || 0) - (b.createdAt?.seconds || 0));
  }, [wishlistLists]);

  const sortedCollections = useMemo(() => {
    return [...collectionLists].sort((a, b) => (a.createdAt?.seconds || 0) - (b.createdAt?.seconds || 0));
  }, [collectionLists]);

  const linkClass = (path: string) => `
    text-sm font-medium transition-colors block py-2 md:py-0
    ${pathname === path 
      ? 'text-primary font-bold' 
      : 'text-muted hover:text-foreground'}
  `;

  const isSocialActive = ['/contacts', '/groups', '/stats'].includes(pathname);
  
  const showHeader = !pathname.startsWith('/life');

  if (!showHeader) return null;
  
  // --- ACTIONS ---

  const handleCreateCollection = () => {
      if (!canCreateCollection) {
          if (confirm("Limite atteinte (1 collection max). Passez Premium pour cr√©er des collections illimit√©es.")) {
             router.push('/pricing');
          }
          return;
      }
      const listName = prompt("Nom de la nouvelle collection:");
      if (listName && listName.trim()) {
          createCollection(listName.trim());
          setShowCollectionSubmenu(false);
          setIsMobileCollectionOpen(false);
      }
  };
  
  const handleCollectionSelect = (listId: string) => {
      router.push(`/collection?listId=${listId}`);
      setShowCollectionSubmenu(false);
      setIsMobileCollectionOpen(false);
      setIsMenuOpen(false);
  };

  const handleCreateWishlist = () => {
      if (!canCreateWishlist) {
        if (confirm("Limite atteinte (1 wishlist max). Passez Premium pour cr√©er des listes illimit√©es.")) {
           router.push('/pricing');
        }
        return;
      }
      const listName = prompt("Nom de la nouvelle wishlist:");
      if (listName && listName.trim()) {
          createWishlist(listName.trim());
          setShowWishlistSubmenu(false);
          setIsMobileWishlistOpen(false);
      }
  };

  const handleWishlistSelect = (listId: string) => {
      router.push(`/wishlist?listId=${listId}`);
      setShowWishlistSubmenu(false);
      setIsMobileWishlistOpen(false);
      setIsMenuOpen(false);
  };
  
  const currentCollectionId = pathname.startsWith('/collection') 
    ? (searchParams.get('listId') || 'default') : 'default';
    
  const currentWishlistId = pathname.startsWith('/wishlist') 
    ? (searchParams.get('listId') || 'default') : 'default';

  // --- MOUSE EVENTS ---

  const openCollectionMenu = () => {
      if (collectionTimeoutRef.current) clearTimeout(collectionTimeoutRef.current);
      setShowCollectionSubmenu(true);
  };
  const closeCollectionMenu = () => {
      collectionTimeoutRef.current = setTimeout(() => setShowCollectionSubmenu(false), 200);
  };

  const openWishlistMenu = () => {
      if (wishlistTimeoutRef.current) clearTimeout(wishlistTimeoutRef.current);
      setShowWishlistSubmenu(true);
  };
  const closeWishlistMenu = () => {
      wishlistTimeoutRef.current = setTimeout(() => setShowWishlistSubmenu(false), 200);
  };

  return (
    <header className="bg-surface/80 backdrop-blur-md border-b border-border p-4 sticky top-0 z-40 transition-colors duration-300">
      <div className="container mx-auto">
        <div className="flex justify-between items-center">
          
          <Link 
            href="/" 
            className="text-2xl font-black tracking-tight text-primary hover:opacity-80 transition"
            onClick={() => setIsMenuOpen(false)}
          >
            MagicWish
          </Link>

          <div className="flex items-center gap-4">
            <div className="hidden md:block">
               <CreditsDisplay />
            </div>

            <ThemeToggle />

            {user ? (
              <>
                <nav className="hidden md:flex gap-6 mr-4 items-center h-full">
                  <Link href="/search" className={linkClass('/search')}>Recherche</Link> 
                  
                  {/* --- MENU WISHLIST DESKTOP --- */}
                  <div 
                      className="relative h-full flex items-center"
                      onMouseEnter={openWishlistMenu}
                      onMouseLeave={closeWishlistMenu}
                  >
                      <Link href="/wishlist" className={linkClass('/wishlist')}>
                          Ma Wishlist
                      </Link>
                      
                      {showWishlistSubmenu && (
                           <div className="absolute top-full left-0 pt-2 w-64 z-50">
                               <div className="bg-surface border border-border rounded-lg shadow-xl overflow-hidden animate-in fade-in zoom-in-95 duration-200">
                                  <div className="px-3 py-2 text-xs font-bold text-muted uppercase tracking-wider bg-secondary/30">
                                      Mes Listes
                                  </div>
                                  <div className="py-1 max-h-64 overflow-y-auto custom-scrollbar">
                                      {sortedWishlists.map((list, index) => {
                                          // Une liste est "Verrouill√©e" si index >= 1 et User non premium
                                          const isLocked = !isPremium && index >= MAX_FREE_LISTS;
                                          
                                          return (
                                              <button 
                                                  key={list.id}
                                                  onClick={() => handleWishlistSelect(list.id)}
                                                  className={`w-full text-left px-4 py-2 text-sm transition flex justify-between items-center group
                                                      ${currentWishlistId === list.id ? 'text-primary font-bold bg-secondary' : 'text-foreground hover:bg-secondary'}
                                                      ${isLocked ? 'opacity-70' : ''}
                                                  `}
                                                  title={list.name}
                                              >
                                                  <span className="truncate pr-2">{list.name}</span>
                                                  {isLocked && (
                                                      <Lock className="w-3.5 h-3.5 text-muted-foreground/60" />
                                                  )}
                                              </button>
                                          );
                                      })}
                                  </div>
                                  <div className="border-t border-border">
                                      <button 
                                          onClick={handleCreateWishlist} 
                                          className={`w-full text-left px-4 py-2 text-sm font-bold flex justify-between items-center ${
                                            canCreateWishlist ? 'text-primary hover:bg-secondary' : 'text-muted bg-secondary/50 cursor-not-allowed'
                                          }`}
                                      >
                                          <span>+ Nouvelle Liste</span>
                                          {!canCreateWishlist && <span className="text-[10px] bg-muted text-surface px-1 rounded">MAX</span>}
                                      </button>
                                  </div>
                              </div>
                           </div>
                      )}
                  </div>
                  
                  {/* --- MENU COLLECTION DESKTOP --- */}
                  <div 
                      className="relative h-full flex items-center"
                      onMouseEnter={openCollectionMenu}
                      onMouseLeave={closeCollectionMenu}
                  >
                      <Link href="/collection" className={linkClass('/collection')}>
                          Ma Collection
                      </Link>
                      
                      {showCollectionSubmenu && (
                           <div className="absolute top-full left-0 pt-2 w-64 z-50">
                               <div className="bg-surface border border-border rounded-lg shadow-xl overflow-hidden animate-in fade-in zoom-in-95 duration-200">
                                  <div className="px-3 py-2 text-xs font-bold text-muted uppercase tracking-wider bg-secondary/30">
                                      Mes Classeurs
                                  </div>
                                  <div className="py-1 max-h-64 overflow-y-auto custom-scrollbar">
                                      {sortedCollections.map((list, index) => {
                                          const isLocked = !isPremium && index >= MAX_FREE_LISTS;

                                          return (
                                              <button 
                                                  key={list.id}
                                                  onClick={() => handleCollectionSelect(list.id)}
                                                  className={`w-full text-left px-4 py-2 text-sm transition flex justify-between items-center group
                                                      ${currentCollectionId === list.id ? 'text-primary font-bold bg-secondary' : 'text-foreground hover:bg-secondary'}
                                                      ${isLocked ? 'opacity-70' : ''}
                                                  `}
                                                  title={list.name}
                                              >
                                                  <span className="truncate pr-2">{list.name}</span>
                                                  {isLocked && (
                                                      <Lock className="w-3.5 h-3.5 text-muted-foreground/60" />
                                                  )}
                                              </button>
                                          );
                                      })}
                                  </div>
                                  <div className="border-t border-border">
                                      <button 
                                          onClick={handleCreateCollection} 
                                          className={`w-full text-left px-4 py-2 text-sm font-bold flex justify-between items-center ${
                                            canCreateCollection ? 'text-primary hover:bg-secondary' : 'text-muted bg-secondary/50 cursor-not-allowed'
                                          }`}
                                      >
                                          <span>+ Nouveau Classeur</span>
                                          {!canCreateCollection && <span className="text-[10px] bg-muted text-surface px-1 rounded">MAX</span>}
                                      </button>
                                  </div>
                              </div>
                           </div>
                      )}
                  </div>
                  
                  <Link href="/trades" className={linkClass('/trades')}>Echanges</Link>
                    
                  {/* --- SOCIAL --- */}
                  <div className="relative group h-full flex items-center">
                    <button className={`text-sm font-medium transition-colors flex items-center gap-1 ${isSocialActive ? 'text-primary font-bold' : 'text-muted hover:text-foreground'}`}>
                      Social
                      {friendRequestCount > 0 && (
                        <span className="bg-primary text-primary-foreground text-[10px] font-bold px-1.5 py-0.5 rounded-full">
                          {friendRequestCount}
                        </span>
                      )}
                      <span className="text-[10px] transform group-hover:rotate-180 transition-transform">‚ñº</span>
                    </button>
                    
                    <div className="absolute top-full right-0 pt-2 w-48 z-50 invisible group-hover:visible opacity-0 group-hover:opacity-100 transition-all duration-200">
                      <div className="bg-surface border border-border rounded-lg shadow-xl overflow-hidden">
                        <div className="py-1">
                            <Link href="/stats" className="flex w-full px-4 py-2 text-sm text-foreground hover:bg-secondary transition items-center">
                            Panth√©on
                            </Link>
                            <Link href="/contacts" className="flex w-full px-4 py-2 text-sm text-foreground hover:bg-secondary transition justify-between items-center">
                            Mes Contacts
                            {friendRequestCount > 0 && (
                                <span className="bg-primary text-primary-foreground text-[10px] font-bold px-1.5 py-0.5 rounded-full">
                                {friendRequestCount}
                                </span>
                            )}
                            </Link>
                            <Link href="/groups" className="flex w-full px-4 py-2 text-sm text-foreground hover:bg-secondary transition items-center">
                            Mes Playgroups
                            </Link>
                        </div>
                      </div>
                    </div>
                  </div>

                  <Link href="/settings" className={linkClass('/settings')}>Param√®tres</Link>
                </nav>

                <div className="h-5 w-px bg-border hidden md:block"></div>

                <div className="flex items-center gap-3">
                  {user.photoURL && (
                    <Image 
                      src={user.photoURL} 
                      alt="Avatar" 
                      width={32}
                      height={32}
                      className="w-8 h-8 rounded-full bg-secondary border border-border object-cover"
                    />
                  )}
                  
                  <button 
                    onClick={() => setIsMenuOpen(!isMenuOpen)}
                    className="md:hidden p-2 text-foreground hover:bg-secondary rounded-lg font-bold text-sm"
                  >
                    Menu
                  </button>
                  
                  <button
                    onClick={() => logOut()}
                    className="hidden md:block text-xs font-medium text-muted hover:text-primary transition"
                  >
                    Quitter
                  </button>
                </div>
              </>
            ) : (
              <Link
                href="/login"
                className="bg-primary text-primary-foreground px-5 py-2 rounded-lg text-sm font-bold hover:opacity-90 transition shadow-md"
              >
                Se connecter
              </Link>
            )}
          </div>
        </div>
        
        {/* MOBILE MENU */}
        {user && isMenuOpen && (
          <div className="md:hidden mt-4 pt-4 border-t border-border animate-in slide-in-from-top-2">
             <div className="mb-4 flex justify-center">
                 <CreditsDisplay />
             </div>
             
             <nav className="flex flex-col space-y-3">
               <Link href="/search" className={linkClass('/search')} onClick={() => setIsMenuOpen(false)}>Recherche</Link>
               
               {/* --- MOBILE WISHLIST --- */}
               <div className="border-b border-border/50">
                  <button 
                      onClick={() => setIsMobileWishlistOpen(!isMobileWishlistOpen)}
                      className={`${linkClass('/wishlist')} w-full text-left py-2 flex justify-between items-center`}
                  >
                      Ma Wishlist
                      <span className={`text-[10px] transform transition-transform ${isMobileWishlistOpen ? 'rotate-180' : ''}`}>‚ñº</span>
                  </button>
                  
                  {isMobileWishlistOpen && (
                      <div className="bg-background/50 p-2 space-y-1 animate-in fade-in slide-in-from-top-2 mb-2 rounded-lg">
                          <div className="text-xs font-bold text-muted uppercase tracking-wider px-2 py-1">Mes Listes</div>
                          {sortedWishlists.map((list, index) => {
                              const isLocked = !isPremium && index >= MAX_FREE_LISTS;
                              return (
                                  <button 
                                      key={list.id}
                                      onClick={() => handleWishlistSelect(list.id)}
                                      className={`w-full text-left px-2 py-2 text-sm rounded transition flex justify-between items-center
                                          ${currentWishlistId === list.id ? 'text-primary font-bold bg-secondary' : 'text-foreground hover:bg-secondary'}
                                          ${isLocked ? 'opacity-70' : ''}
                                      `}
                                  >
                                      <span>{list.name}</span>
                                      {isLocked && <Lock className="w-3.5 h-3.5 text-muted-foreground/60" />}
                                  </button>
                              );
                          })}
                          <div className="border-t border-border my-1"></div>
                          <button 
                              onClick={handleCreateWishlist} 
                              className={`w-full text-left px-2 py-2 text-sm font-bold flex justify-between ${canCreateWishlist ? 'text-primary hover:bg-secondary' : 'text-muted cursor-not-allowed'}`}
                          >
                              <span>+ Nouvelle Liste</span>
                              {!canCreateWishlist && <span className="text-[10px] bg-muted text-surface px-1 rounded">MAX</span>}
                          </button>
                      </div>
                  )}
               </div>
               
               {/* --- MOBILE COLLECTION --- */}
               <div className="border-b border-border/50">
                  <button 
                      onClick={() => setIsMobileCollectionOpen(!isMobileCollectionOpen)}
                      className={`${linkClass('/collection')} w-full text-left py-2 flex justify-between items-center`}
                  >
                      Ma Collection
                      <span className={`text-[10px] transform transition-transform ${isMobileCollectionOpen ? 'rotate-180' : ''}`}>‚ñº</span>
                  </button>
                  
                  {isMobileCollectionOpen && (
                      <div className="bg-background/50 p-2 space-y-1 animate-in fade-in slide-in-from-top-2 mb-2 rounded-lg">
                          <div className="text-xs font-bold text-muted uppercase tracking-wider px-2 py-1">Mes Classeurs</div>
                          {sortedCollections.map((list, index) => {
                              const isLocked = !isPremium && index >= MAX_FREE_LISTS;
                              return (
                                  <button 
                                      key={list.id}
                                      onClick={() => handleCollectionSelect(list.id)}
                                      className={`w-full text-left px-2 py-2 text-sm rounded transition flex justify-between items-center
                                          ${currentCollectionId === list.id ? 'text-primary font-bold bg-secondary' : 'text-foreground hover:bg-secondary'}
                                          ${isLocked ? 'opacity-70' : ''}
                                      `}
                                  >
                                      <span>{list.name}</span>
                                      {isLocked && <Lock className="w-3.5 h-3.5 text-muted-foreground/60" />}
                                  </button>
                              );
                          })}
                          <div className="border-t border-border my-1"></div>
                          <button 
                              onClick={handleCreateCollection} 
                              className={`w-full text-left px-2 py-2 text-sm font-bold flex justify-between ${canCreateCollection ? 'text-primary hover:bg-secondary' : 'text-muted cursor-not-allowed'}`}
                          >
                              <span>+ Nouveau Classeur</span>
                              {!canCreateCollection && <span className="text-[10px] bg-muted text-surface px-1 rounded">MAX</span>}
                          </button>
                      </div>
                  )}
               </div>
               
               <Link href="/trades" className={linkClass('/trades')} onClick={() => setIsMenuOpen(false)}>Echanges</Link>
               
               {/* --- MOBILE SOCIAL --- */}
               <div className="border-b border-border/50">
                  <button 
                      onClick={() => setIsMobileSocialOpen(!isMobileSocialOpen)}
                      className={`${linkClass('/contacts')} w-full text-left py-2 flex justify-between items-center`}
                  >
                      <span className="flex items-center gap-2">
                        Social
                        {friendRequestCount > 0 && (
                          <span className="bg-primary text-primary-foreground text-[10px] font-bold px-1.5 py-0.5 rounded-full">
                            {friendRequestCount}
                          </span>
                        )}
                      </span>
                      <span className={`text-[10px] transform transition-transform ${isMobileSocialOpen ? 'rotate-180' : ''}`}>‚ñº</span>
                  </button>
                  
                  {isMobileSocialOpen && (
                    <div className="bg-background/50 p-2 space-y-1 animate-in fade-in slide-in-from-top-2 mb-2 rounded-lg">
                        <Link href="/stats" className="block w-full text-left px-2 py-2 text-sm text-foreground hover:bg-secondary rounded" onClick={() => setIsMenuOpen(false)}>Panth√©on</Link>
                        <Link href="/contacts" className="flex justify-between items-center w-full text-left px-2 py-2 text-sm text-foreground hover:bg-secondary rounded" onClick={() => setIsMenuOpen(false)}>
                          Mes Contacts
                          {friendRequestCount > 0 && <span className="bg-primary text-white text-[10px] px-1.5 rounded-full">{friendRequestCount}</span>}
                        </Link>
                        <Link href="/groups" className="block w-full text-left px-2 py-2 text-sm text-foreground hover:bg-secondary rounded" onClick={() => setIsMenuOpen(false)}>Mes Playgroups</Link>
                    </div>
                  )}
               </div>

               <Link href="/settings" className={linkClass('/settings')} onClick={() => setIsMenuOpen(false)}>Param√®tres</Link>
               <button onClick={() => { logOut(); setIsMenuOpen(false); }} className="text-left py-2 text-danger text-sm font-bold">D√©connexion</button>
             </nav>
          </div>
        )}
      </div>
    </header>
  );
}
</file>

<file path="app/trades/manual/page.tsx">
'use client';

import { useState, useMemo, useTransition } from 'react';
import { useAuth } from '@/lib/AuthContext';
import { useCardCollection, CardType } from '@/hooks/useCardCollection';
import { executeManualTrade } from '@/app/actions/trade'; 
import toast from 'react-hot-toast';
import CardVersionPickerModal from '@/components/CardVersionPickerModal';
import { ScryfallRawData } from '@/lib/cardUtils';
import MagicCard from '@/components/MagicCard';
import Image from 'next/image'; // 1. IMPORT AJOUT√â

// --- DEFINITIONS ---

// On d√©finit le Payload pour correspondre aux donn√©es attendues par le serveur
interface ServerCardPayload {
    id: string;
    name: string;
    imageUrl: string;
    imageBackUrl: string | null;
    quantity: number;
    quantityForTrade: number; // Requis par CardType
    price: number;
    customPrice?: number;
    setName: string;
    setCode: string;
    isFoil: boolean;
    isSpecificVersion: boolean;
    scryfallData: ScryfallRawData | null; // Typage strict ici aussi
    wishlistId: string | null;
}

const mapCardsForServer = (cards: CardType[]): ServerCardPayload[] => {
    return cards.map(c => {
        // On s'assure que scryfallData est du bon type ou null
        const scryData = (c.scryfallData as ScryfallRawData) || null;

        const payload: ServerCardPayload = {
            id: c.id,
            name: c.name,
            imageUrl: c.imageUrl,
            imageBackUrl: c.imageBackUrl ?? null,
            quantity: c.quantity,
            quantityForTrade: c.quantityForTrade ?? 0,
            price: c.price ?? 0,
            customPrice: c.customPrice,
            setName: c.setName ?? '',
            setCode: c.setCode ?? '',
            isFoil: c.isFoil ?? false,
            isSpecificVersion: c.isSpecificVersion ?? false,
            scryfallData: scryData,
            wishlistId: c.wishlistId ?? null,
        };
        
        // Nettoyage si undefined
        if (payload.customPrice === undefined) delete payload.customPrice;
        
        return payload;
    });
};

function isCollectionCard(item: CardType | ScryfallRawData): item is CardType {
    return (item as CardType).quantity !== undefined;
}

// --- TABLEAU DE S√âLECTION (Panier) ---
const TradeSelectionTable = ({ 
    cards, 
    onRemove, 
    onUpdatePrice, 
    onUpdateQuantity,
    getMaxQuantity,
    colorClass, 
    emptyLabel,
    onCardClick
}: { 
    cards: CardType[], 
    onRemove: (id: string) => void, 
    onUpdatePrice: (id: string, price: number) => void,
    onUpdateQuantity: (id: string, delta: number) => void,
    getMaxQuantity?: (id: string) => number,
    colorClass: 'text-danger' | 'text-success',
    emptyLabel: string,
    onCardClick: (card: CardType) => void
}) => {
    if (cards.length === 0) return <div className="flex-1 flex items-center justify-center border-b border-border bg-secondary/10 text-muted text-sm italic p-8">{emptyLabel}</div>;

    return (
        <div className="flex-1 overflow-hidden flex flex-col bg-surface border-b border-border shadow-sm">
            <div className="overflow-y-auto custom-scrollbar flex-1">
                <table className="w-full text-xs text-left border-collapse">
                    <thead className="bg-secondary text-muted sticky top-0 z-10 font-semibold uppercase">
                        <tr>
                            <th className="px-2 py-2 text-center w-24">Qt√©</th>
                            <th className="px-2 py-2">Nom</th>
                            <th className="px-2 py-2 w-10 text-center">Set</th>
                            <th className="px-2 py-2 w-10 text-center">Foil</th>
                            <th className="px-2 py-2 text-right w-16">Prix</th>
                            <th className="px-2 py-2 w-8"></th>
                        </tr>
                    </thead>
                    <tbody className="divide-y divide-border">
                        {cards.map((card, i) => {
                            const currentPrice = card.customPrice !== undefined ? card.customPrice : (card.price || 0);
                            
                            const maxQty = getMaxQuantity ? getMaxQuantity(card.id) : Infinity;
                            const isMaxReached = card.quantity >= maxQty;
                            const isMinReached = card.quantity <= 1;

                            return (
                                <tr 
                                    key={`${card.id}-${i}`} 
                                    className="hover:bg-secondary/50 transition-colors text-foreground select-none cursor-pointer"
                                    onClick={() => onCardClick(card)}
                                >
                                    {/* CELLULE QUANTIT√â INTERACTIVE */}
                                    <td className="px-2 py-1.5 text-center">
                                        <div 
                                            className={`flex items-center justify-center gap-1 bg-background/50 rounded border border-border p-0.5 ${colorClass}`}
                                            onClick={(e) => e.stopPropagation()}
                                        >
                                            <button 
                                                onClick={() => onUpdateQuantity(card.id, -1)} 
                                                disabled={isMinReached}
                                                className="w-5 h-5 flex items-center justify-center bg-surface hover:bg-secondary rounded text-xs font-bold disabled:opacity-30 transition-colors border border-border"
                                            >
                                                -
                                            </button>
                                            
                                            <span className="font-mono font-bold w-8 text-center text-[10px]">
                                                {card.quantity}
                                                {maxQty !== Infinity && <span className="opacity-50 font-normal">/{maxQty}</span>}
                                            </span>
                                            
                                            <button 
                                                onClick={() => onUpdateQuantity(card.id, 1)} 
                                                disabled={isMaxReached}
                                                className="w-5 h-5 flex items-center justify-center bg-surface hover:bg-secondary rounded text-xs font-bold disabled:opacity-30 transition-colors border border-border"
                                            >
                                                +
                                            </button>
                                        </div>
                                    </td>

                                    <td className="px-2 py-1.5 font-medium truncate max-w-[120px]" title={card.name}>{card.name}</td>
                                    <td className="px-2 py-1.5 text-center"><span className="text-[9px] font-mono bg-secondary text-muted px-1 rounded border border-border">{card.setCode?.toUpperCase()}</span></td>
                                    <td className="px-2 py-1.5 text-center">{card.isFoil && <span className="text-[9px] font-bold text-amber-600 bg-amber-100 px-1 rounded">Foil</span>}</td>
                                    
                                    <td className="px-2 py-1.5 text-right">
                                        <div className="flex items-center justify-end gap-1" onClick={(e) => e.stopPropagation()}>
                                            <input 
                                                type="number" min="0" step="0.01"
                                                className="w-14 p-1 text-right bg-background border border-border rounded text-xs outline-none focus:border-primary [appearance:textfield] [&::-webkit-outer-spin-button]:appearance-none [&::-webkit-inner-spin-button]:appearance-none"
                                                value={currentPrice}
                                                onChange={(e) => onUpdatePrice(card.id, parseFloat(e.target.value) || 0)}
                                            />
                                            <span className="text-muted">‚Ç¨</span>
                                        </div>
                                    </td>
                                    <td className="px-2 py-1.5 text-center">
                                        <button 
                                            onClick={(e) => { e.stopPropagation(); onRemove(card.id); }} 
                                            className="text-muted hover:text-danger transition px-1 font-bold"
                                        >
                                            ‚úï
                                        </button>
                                    </td>
                                </tr>
                            );
                        })}
                    </tbody>
                </table>
            </div>
        </div>
    );
};

// --- TABLEAU SOURCE (RESULTATS RECHERCHE) ---
const TradeSourceTable = ({ cards, onAdd, buttonColorClass, loading }: { cards: (CardType | ScryfallRawData)[], onAdd: (c: CardType | ScryfallRawData) => void, buttonColorClass: 'text-danger' | 'text-success', loading?: boolean }) => {
    if (loading) return <p className="text-xs text-muted text-center py-4">Chargement...</p>;
    if (cards.length === 0) return null; 
    
    return (
        <div className="overflow-y-auto custom-scrollbar bg-surface border-t border-border max-h-[300px]">
            <table className="w-full text-xs text-left border-collapse">
                <tbody className="divide-y divide-border">
                    {cards.map((item, i) => {
                        const name = item.name;
                        const setCode = isCollectionCard(item) ? item.setCode || '' : item.set || '';
                        const isFoil = isCollectionCard(item) ? !!item.isFoil : false;
                        const qty = isCollectionCard(item) ? item.quantity : '-';

                        return (
                            <tr key={`${item.id}-${i}`} className="hover:bg-secondary/50 transition-colors text-foreground cursor-pointer group select-none" onClick={() => onAdd(item)}>
                                <td className="px-2 py-1.5 text-center text-muted font-mono">{qty}</td>
                                <td className="px-2 py-1.5 font-medium truncate max-w-[120px]" title={name}>{name}</td>
                                <td className="px-2 py-1.5 text-center"><span className="text-[9px] font-mono bg-secondary text-muted px-1 rounded border border-border">{setCode.toUpperCase()}</span></td>
                                <td className="px-2 py-1.5 text-center">{isFoil && <span className="text-[9px] font-bold text-amber-600 bg-amber-100 px-1 rounded">Foil</span>}</td>
                                <td className="px-2 py-1.5 text-center">
                                    <button className={`${buttonColorClass} font-bold hover:scale-125 transition-transform`}>+</button>
                                </td>
                            </tr>
                        );
                    })}
                </tbody>
            </table>
        </div>
    );
};

// --- MODALE DE S√âLECTION COLLECTION ---
const CollectionPickerModal = ({ 
    isOpen, 
    onClose, 
    cardName, 
    matchingCards, 
    onConfirm 
}: { 
    isOpen: boolean;
    onClose: () => void;
    cardName: string;
    matchingCards: CardType[];
    onConfirm: (card: CardType) => void;
}) => {
    if (!isOpen) return null;

    return (
        <div className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black/50 backdrop-blur-sm animate-in fade-in">
            <div className="bg-surface border border-border rounded-xl shadow-2xl w-full max-w-lg overflow-hidden flex flex-col max-h-[80vh]">
                <div className="p-4 border-b border-border flex justify-between items-center bg-secondary/30">
                    <h3 className="font-bold text-lg text-foreground">S√©lectionner une version</h3>
                    <button onClick={onClose} className="text-muted hover:text-foreground">‚úï</button>
                </div>
                
                <div className="p-4 overflow-y-auto custom-scrollbar space-y-2">
                    <p className="text-sm text-muted mb-2">Versions disponibles pour <strong>{cardName}</strong> :</p>
                    {matchingCards.length === 0 ? (
                        <p className="text-center text-muted italic">Aucune carte correspondante trouv√©e.</p>
                    ) : (
                        <div className="grid gap-2">
                            {matchingCards.map(card => (
                                <div 
                                    key={card.id} 
                                    onClick={() => { onConfirm(card); onClose(); }}
                                    className="flex items-center gap-3 p-2 rounded-lg border border-border hover:border-primary cursor-pointer hover:bg-primary/5 transition-all group"
                                >
                                    {/* 2. REMPLACEMENT DE <IMG> PAR <IMAGE> */}
                                    <div className="w-10 h-14 bg-black/10 rounded overflow-hidden shrink-0 relative">
                                        <Image 
                                            src={card.imageUrl} 
                                            alt={card.name} 
                                            fill // S'adapte au parent w-10 h-14
                                            className="object-cover"
                                            sizes="40px" // Optimisation : indique que l'image est petite
                                        />
                                    </div>
                                    <div className="grow">
                                        <div className="flex items-center gap-2">
                                            <span className="font-bold text-sm text-foreground">{card.name}</span>
                                            {card.isFoil && <span className="text-[10px] font-bold bg-amber-100 text-amber-700 px-1.5 rounded border border-amber-200">Foil</span>}
                                        </div>
                                        <div className="flex items-center gap-2 text-xs text-muted mt-0.5">
                                            <span className="bg-secondary px-1.5 rounded text-foreground border border-border font-mono">{card.setName}</span>
                                            <span>‚Ä¢</span>
                                            <span>Stock: <strong className="text-foreground">{card.quantity}</strong></span>
                                            {card.quantityForTrade !== undefined && (
                                                <span>(Trade: {card.quantityForTrade})</span>
                                            )}
                                        </div>
                                    </div>
                                    <button className="bg-primary text-primary-foreground px-3 py-1.5 rounded text-xs font-bold opacity-0 group-hover:opacity-100 transition-opacity">
                                        Choisir
                                    </button>
                                </div>
                            ))}
                        </div>
                    )}
                </div>
            </div>
        </div>
    );
};

// --- PAGE PRINCIPALE ---
export default function ManualTradePage() {
    const { user } = useAuth();
    const { cards: myCollection, loading } = useCardCollection('collection'); 
    const [isPending, startTransition] = useTransition();

    // Etats S√©lection
    const [toGive, setToGive] = useState<CardType[]>([]);
    const [toReceive, setToReceive] = useState<CardType[]>([]);
    
    // Etats Recherche
    const [localSearch, setLocalSearch] = useState('');
    const [remoteSearch, setRemoteSearch] = useState('');
    const [searchResults, setSearchResults] = useState<ScryfallRawData[]>([]);
    const [isSearching, setIsSearching] = useState(false);
    
    // Etats Modales
    const [cardToPick, setCardToPick] = useState<ScryfallRawData | null>(null);
    const [collectionPickOpen, setCollectionPickOpen] = useState(false);
    const [selectedCollectionName, setSelectedCollectionName] = useState('');
    
    // Preview
    const [previewCard, setPreviewCard] = useState<CardType | null>(null);

    // --- TOGGLE VUE ---
    const [showFullCollection, setShowFullCollection] = useState(false);

    // --- LOGIQUE METIER ---

    // 1. Mise √† jour des prix
    const handleUpdatePrice = (cardId: string, newPrice: number, listType: 'give' | 'receive') => {
        const setTarget = listType === 'give' ? setToGive : setToReceive;
        setTarget(prev => prev.map(c => c.id === cardId ? { ...c, customPrice: newPrice } : c));
    };

    // 2. Gestion stock max pour la colonne "DONNER"
    const getGiveMaxQuantity = (cardId: string) => {
        const sourceCard = myCollection.find(c => c.id === cardId);
        if (!sourceCard) return 0;
        return showFullCollection ? sourceCard.quantity : (sourceCard.quantityForTrade || 0);
    };

    // 3. Mise √† jour Quantit√© (Boutons +/-)
    const handleUpdateQuantity = (cardId: string, delta: number, listType: 'give' | 'receive') => {
        const setTarget = listType === 'give' ? setToGive : setToReceive;
        
        setTarget(prev => {
            return prev.map(c => {
                if (c.id !== cardId) return c;

                const newQty = c.quantity + delta;
                if (newQty < 1) return c; 

                // V√©rification du stock max SEULEMENT si on DONNE
                if (listType === 'give') {
                    const max = getGiveMaxQuantity(cardId);
                    if (newQty > max) {
                        toast.error("Stock insuffisant");
                        return c;
                    }
                }
                
                return { ...c, quantity: newQty };
            });
        });
    };

    // 4. Filtrage de la collection (Pour la recherche)
    const accessibleCollection = useMemo(() => {
        if (showFullCollection) return myCollection;
        return myCollection.filter(c => (c.quantityForTrade || 0) > 0);
    }, [myCollection, showFullCollection]);

    const localSearchResults = useMemo(() => {
        if (!localSearch.trim()) return [];
        const lower = localSearch.toLowerCase();
        const matches = accessibleCollection.filter(c => c.name.toLowerCase().includes(lower));
        const uniqueNames = Array.from(new Set(matches.map(c => c.name))).slice(0, 10);
        return uniqueNames.map(name => matches.find(c => c.name === name)!);
    }, [accessibleCollection, localSearch]);

    const matchingCollectionCards = useMemo(() => {
        if (!selectedCollectionName) return [];
        return accessibleCollection.filter(c => c.name === selectedCollectionName);
    }, [accessibleCollection, selectedCollectionName]);

    // 5. Handlers Ajout
    const handleLocalResultClick = (item: CardType | ScryfallRawData) => {
        setSelectedCollectionName(item.name);
        setCollectionPickOpen(true);
    };

    const confirmAddFromCollection = (card: CardType) => {
        const existing = toGive.find(c => c.id === card.id);
        const maxStock = getGiveMaxQuantity(card.id);

        if (existing) {
            if (existing.quantity < maxStock) {
                setToGive(prev => prev.map(c => c.id === card.id ? { ...c, quantity: c.quantity + 1 } : c));
                toast.success("+1 ajout√©");
            } else {
                toast.error("Stock max atteint");
            }
        } else {
            setToGive(prev => [...prev, { ...card, quantity: 1, customPrice: card.price }]);
            toast.success("Carte ajout√©e");
        }
        setCollectionPickOpen(false);
        setLocalSearch(''); 
    };

    const handleSearchScryfall = async (e: React.FormEvent) => {
        e.preventDefault();
        if (!remoteSearch.trim()) return;
        setIsSearching(true);
        try {
            const res = await fetch(`/api/search?q=${remoteSearch}`); 
            const data = await res.json();
            setSearchResults(data.data || []);
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        } catch (e) { toast.error("Erreur recherche"); }
        finally { setIsSearching(false); }
    };

    const handleConfirmReceive = (card: CardType) => {
        const existing = toReceive.find(c => c.id === card.id && c.isFoil === card.isFoil); 
        if (existing) {
            setToReceive(prev => prev.map(c => (c.id === card.id && c.isFoil === card.isFoil) ? { ...c, quantity: c.quantity + card.quantity } : c));
        } else {
            setToReceive(prev => [...prev, { ...card, customPrice: card.price }]);
        }
        setSearchResults([]); setRemoteSearch(""); toast.success(`Ajout√©`);
    };

    const handleValidate = async () => {
        if (!user) return;
        if (toGive.length === 0 && toReceive.length === 0) return;
        if (!confirm("Confirmer cet √©change ? Vos cartes donn√©es seront retir√©es de votre collection.")) return;

        const toastId = toast.loading("Validation...");
        startTransition(async () => {
            // CORRECTION: Utilisation de "as unknown as CardType[]" au lieu de "as any[]"
            // Cela permet de transformer notre Payload (DTO) en CardType pour l'action serveur
            // sans d√©sactiver la v√©rification de type globale.
            const cleanToGive = mapCardsForServer(toGive) as unknown as CardType[]; 
            const cleanToReceive = mapCardsForServer(toReceive) as unknown as CardType[]; 
            
            // Typage explicite du retour de l'action server
            const result = await executeManualTrade(user.uid, cleanToGive, cleanToReceive) as { success: boolean; error?: string; };
            
            if (result.success) {
                toast.success("Echange valid√© !", { id: toastId });
                setToGive([]); setToReceive([]); setLocalSearch("");
            } else {
                toast.error(result.error || "Erreur", { id: toastId });
            }
        });
    };

    const valGive = toGive.reduce((acc, c) => acc + (c.customPrice ?? c.price ?? 0) * c.quantity, 0);
    const valReceive = toReceive.reduce((acc, c) => acc + (c.customPrice ?? c.price ?? 0) * c.quantity, 0);

    const uniqueSearchResults = useMemo(() => {
        const seen = new Set();
        return searchResults.filter(card => {
            const name = card.name.split(' // ')[0];
            if (seen.has(name)) return false;
            seen.add(name);
            return true;
        });
    }, [searchResults]);

    if (!user) return <div className="p-10 text-center text-muted">Connectez-vous.</div>;

    return (
        <div className="container mx-auto p-4 h-[calc(100vh-64px)] flex flex-col">
            <h1 className="text-2xl font-bold mb-4 flex-none text-foreground">√âchange Manuel</h1>
            
            <div className="grid lg:grid-cols-2 gap-4 grow overflow-hidden pb-24">
                
                {/* COLONNE GAUCHE : JE DONNE */}
                <div className="flex flex-col h-full bg-danger/5 rounded-xl border border-danger/20 overflow-hidden shadow-sm">
                    <div className="p-4 pb-0 flex-none space-y-3">
                        
                        {/* Header + Toggle */}
                        <div className="flex justify-between items-start">
                            <h2 className="font-bold text-red-600">√Ä DONNER ({toGive.reduce((a,c)=>a+c.quantity,0)}) - {valGive.toFixed(2)} ‚Ç¨</h2>
                            
                            <label className="flex items-center gap-2 cursor-pointer select-none">
                                <input 
                                    type="checkbox" 
                                    className="w-3.5 h-3.5 text-danger rounded border-danger/30 focus:ring-danger accent-danger"
                                    checked={showFullCollection}
                                    onChange={(e) => setShowFullCollection(e.target.checked)}
                                />
                                <span className="text-[10px] font-semibold text-danger/80 hover:text-danger">
                                    Acc√©der √† toute la collection
                                </span>
                            </label>
                        </div>

                        {/* Search Bar */}
                        <input 
                            type="text" 
                            placeholder="Rechercher une carte √† donner..." 
                            className="w-full p-2 rounded border text-sm bg-background text-foreground focus:ring-2 focus:ring-danger/50 outline-none" 
                            value={localSearch} 
                            onChange={e => setLocalSearch(e.target.value)} 
                        />
                    </div>

                    {/* Table des s√©lections */}
                    <TradeSelectionTable 
                        cards={toGive} 
                        onRemove={(id) => setToGive(p => p.filter(c => c.id !== id))} 
                        onUpdatePrice={(id, p) => handleUpdatePrice(id, p, 'give')} 
                        onUpdateQuantity={(id, d) => handleUpdateQuantity(id, d, 'give')}
                        getMaxQuantity={getGiveMaxQuantity}
                        colorClass="text-danger" 
                        emptyLabel="Recherchez vos cartes ci-dessus..." 
                        onCardClick={setPreviewCard}
                    />
                    
                    {/* R√©sultats de recherche */}
                    {localSearch && (
                        <div className="flex-none max-h-[200px] border-t border-danger/20 bg-surface shadow-inner">
                            <TradeSourceTable 
                                cards={localSearchResults} 
                                onAdd={handleLocalResultClick} 
                                buttonColorClass="text-danger" 
                                loading={loading} 
                            />
                        </div>
                    )}
                </div>

                {/* COLONNE DROITE : JE RECOIS */}
                <div className="flex flex-col h-full bg-success/5 rounded-xl border border-success/20 overflow-hidden shadow-sm">
                    <div className="p-4 pb-0 flex-none">
                        <h2 className="font-bold text-green-600 mb-2">√Ä RECEVOIR ({toReceive.reduce((a,c)=>a+c.quantity,0)}) - {valReceive.toFixed(2)} ‚Ç¨</h2>
                        <form onSubmit={handleSearchScryfall} className="flex gap-2 mb-2">
                            <input type="text" placeholder="Carte √† recevoir..." className="grow p-2 rounded-lg border border-border bg-background text-foreground text-sm focus:ring-2 focus:ring-success outline-none" value={remoteSearch} onChange={e => setRemoteSearch(e.target.value)} />
                            <button type="submit" className="bg-success hover:opacity-90 text-primary-foreground px-3 rounded-lg shadow-sm font-bold text-xs">GO</button>
                        </form>
                    </div>
                    
                    <TradeSelectionTable 
                        cards={toReceive} 
                        onRemove={(id) => setToReceive(p => p.filter((_, idx) => p[idx].id !== id || idx !== p.findIndex(x => x.id === id)))} 
                        onUpdatePrice={(id, p) => handleUpdatePrice(id, p, 'receive')} 
                        onUpdateQuantity={(id, d) => handleUpdateQuantity(id, d, 'receive')}
                        colorClass="text-success" 
                        emptyLabel="Recherchez des cartes en bas..." 
                        onCardClick={setPreviewCard}
                    />
                    
                    <div className="flex-none max-h-[200px] border-t border-success/20 bg-surface shadow-inner">
                        <TradeSourceTable 
                            cards={uniqueSearchResults} 
                            onAdd={(item) => { if (!isCollectionCard(item)) setCardToPick(item); }} 
                            buttonColorClass="text-success" 
                            loading={isSearching} 
                        />
                    </div>
                </div>
            </div>

            {/* Footer */}
            <div className="fixed bottom-0 left-0 right-0 h-20 bg-surface border-t border-border flex justify-between items-center px-6 z-40 shadow-sm">
                <div className="hidden sm:block flex-1"></div>
                <div className="flex-1 flex flex-col items-center justify-center">
                    <span className="text-[10px] text-muted font-bold uppercase tracking-widest">Balance Estim√©e</span>
                    <div className={`text-2xl font-black ${valGive - valReceive >= 0 ? 'text-success' : 'text-danger'}`}>{valGive - valReceive > 0 ? '+' : ''}{(valGive - valReceive).toFixed(2)} ‚Ç¨</div>
                </div>
                <div className="flex-1 flex justify-end">
                    <button onClick={handleValidate} disabled={isPending || (toGive.length === 0 && toReceive.length === 0)} className="btn-primary px-6 py-3 disabled:opacity-50 text-sm">{isPending ? 'Validation...' : 'Valider'}</button>
                </div>
            </div>

            {/* MODALES */}
            <CardVersionPickerModal isOpen={!!cardToPick} baseCard={cardToPick} onClose={() => setCardToPick(null)} onConfirm={handleConfirmReceive} />
            
            <CollectionPickerModal 
                isOpen={collectionPickOpen} 
                onClose={() => setCollectionPickOpen(false)} 
                cardName={selectedCollectionName} 
                matchingCards={matchingCollectionCards} 
                onConfirm={confirmAddFromCollection}
            />

            {/* MODALE DE PREVISUALISATION */}
            {previewCard && (
                <div 
                    className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black/60 backdrop-blur-sm animate-in fade-in cursor-pointer"
                    onClick={() => setPreviewCard(null)}
                >
                    <div className="relative transform transition-all scale-100 p-4" onClick={e => e.stopPropagation()}>
                        <button 
                            onClick={() => setPreviewCard(null)} 
                            className="absolute -top-2 -right-2 bg-surface text-foreground rounded-full p-2 shadow-lg z-10 border border-border hover:bg-secondary transition-colors"
                        >
                            ‚úï
                        </button>
                       <div className="w-[300px] h-[420px] shadow-2xl rounded-xl overflow-hidden pointer-events-none">
                            {/* AJOUT DE HIDEFOOTER ICI */}
                            <MagicCard {...previewCard} readOnly={true} quantity={previewCard.quantity} hideFooter={true} />
                        </div>
                    </div>
                </div>
            )}
        </div>
    );
}
</file>

<file path="app/trades/page.tsx">
// app/trades/page.tsx
'use client';

import { useState, useTransition, useEffect } from 'react';
import { useAuth } from '@/lib/AuthContext';
import { useTradeMatcher, TradeProposal } from '@/hooks/useTradeMatcher';
import { useTradeSystem, TradeRequest } from '@/hooks/useTradeSystem';
import Link from 'next/link';
import Image from 'next/image';
import { CardType } from '@/hooks/useCardCollection';
import { ScryfallRawData } from '@/lib/cardUtils';
import { useSearchParams } from 'next/navigation';
import MagicCard from '@/components/MagicCard'; 

// --- COMPOSANT LISTE (TEXTE) ---
const TradeListText = ({ 
    cards, 
    allowPriceEdit = false, 
    onPriceChange,
    onPreview 
}: { 
    cards: CardType[], 
    allowPriceEdit?: boolean, 
    onPriceChange?: (id: string, val: number) => void,
    onPreview: (c: CardType) => void
}) => {
    return (
        <div className="max-h-60 overflow-y-auto custom-scrollbar bg-surface rounded-lg border border-border">
            <table className="w-full text-xs text-left border-collapse">
                <thead className="bg-secondary text-muted sticky top-0 z-10 font-semibold uppercase tracking-wider">
                    <tr>
                        <th className="px-2 py-2 text-center w-8">Qt√©</th>
                        <th className="px-2 py-2">Nom</th>
                        <th className="px-2 py-2 w-12 text-center">Set</th>
                        <th className="px-2 py-2 w-10 text-center">N¬∞</th>
                        <th className="px-2 py-2 w-10 text-center">Foil</th>
                        <th className="px-2 py-2 text-right w-16">Prix</th>
                    </tr>
                </thead>
                <tbody className="divide-y divide-border">
                    {cards.map((c, i) => {
                        const price = c.customPrice !== undefined ? c.customPrice : (c.price || 0);
                        const scryData = c.scryfallData as ScryfallRawData | undefined;
                        const collectorNum = scryData?.collector_number || '?';
                        
                        return (
                            <tr 
                                key={`${c.id}-${i}`} 
                                className="hover:bg-secondary/50 transition-colors text-foreground select-none cursor-pointer"
                                onClick={() => onPreview(c)}
                            >
                                <td className="px-2 py-1.5 text-center font-bold text-muted">
                                    {c.quantity}
                                </td>
                                <td className="px-2 py-1.5 font-medium truncate max-w-[120px]" title={c.name}>
                                    {c.name}
                                </td>
                                <td className="px-2 py-1.5 text-center">
                                    <span className="text-[9px] font-mono bg-secondary text-muted px-1 rounded border border-border">
                                        {c.setCode?.toUpperCase()}
                                    </span>
                                </td>
                                <td className="px-2 py-1.5 text-center text-muted font-mono text-[10px]">
                                    {collectorNum}
                                </td>
                                <td className="px-2 py-1.5 text-center">
                                    {c.isFoil && <span className="text-[9px] font-bold text-amber-600 bg-amber-50 px-1 rounded">Foil</span>}
                                </td>
                                <td className="px-2 py-1.5 text-right" onClick={e => e.stopPropagation()}>
                                    {allowPriceEdit ? (
                                        <input 
                                            type="number" 
                                            min="0" 
                                            step="0.01" 
                                            value={price}
                                            onChange={(e) => onPriceChange?.(c.id, parseFloat(e.target.value) || 0)}
                                            className="w-14 p-1 text-right bg-background border border-border rounded text-xs outline-none focus:border-primary [appearance:textfield] [&::-webkit-outer-spin-button]:appearance-none [&::-webkit-inner-spin-button]:appearance-none"
                                        />
                                    ) : (
                                        <span className="font-medium">{price.toFixed(2)} ‚Ç¨</span>
                                    )}
                                </td>
                            </tr>
                        );
                    })}
                </tbody>
            </table>
        </div>
    );
};

// --- COMPOSANT PROPOSITION (MOI -> AMI) ---
const TradeRowProposal = ({ 
    proposal, 
    onProposalSent,
    onPreview
}: { 
    proposal: TradeProposal, 
    onProposalSent: () => void,
    onPreview: (c: CardType) => void
}) => {
    const { proposeTrade } = useTradeSystem();
    const [isPending, startTransition] = useTransition();

    const [localGiven, setLocalGiven] = useState<CardType[]>(proposal.toGive);
    const [localReceived, setLocalReceived] = useState<CardType[]>(proposal.toReceive);

    useEffect(() => {
        setLocalGiven(proposal.toGive);
        setLocalReceived(proposal.toReceive);
    }, [proposal]);

    const totalGive = localGiven.reduce((acc, c) => acc + (c.customPrice ?? c.price ?? 0) * c.quantity, 0);
    const totalReceive = localReceived.reduce((acc, c) => acc + (c.customPrice ?? c.price ?? 0) * c.quantity, 0);
    const delta = totalGive - totalReceive;

    const handleLocalPriceChange = (id: string, newVal: number, side: 'give' | 'receive') => {
        const updater = side === 'give' ? setLocalGiven : setLocalReceived;
        updater(prev => prev.map(c => c.id === id ? { ...c, customPrice: newVal } : c));
    };

    const handlePropose = () => {
        startTransition(async () => {
            const success = await proposeTrade(
                proposal.friend.uid,
                proposal.friend.displayName,
                localGiven, 
                localReceived
            );
            if (success) onProposalSent();
        });
    };

    return (
        <div className="bg-surface rounded-2xl shadow-sm border border-border overflow-hidden mb-8 shrink-0">
            <div className="bg-secondary/30 p-4 border-b border-border flex flex-col sm:flex-row justify-between items-center gap-4 select-none">
                <div className="flex items-center gap-3">
                    <div className="w-10 h-10 rounded-full bg-linear-to-br from-primary to-purple-600 flex items-center justify-center text-white font-bold overflow-hidden shadow-sm relative">
                        {proposal.friend.photoURL ? (
                            <Image 
                                src={proposal.friend.photoURL} 
                                alt={proposal.friend.displayName} 
                                fill
                                className="object-cover"
                                sizes="40px"
                            />
                        ) : (
                            proposal.friend.username[0].toUpperCase()
                        )}
                    </div>
                    <div>
                        <h2 className="text-xl font-bold text-foreground">Match avec {proposal.friend.displayName}</h2>
                        <Link href={`/user/${proposal.friend.uid}`} className="text-sm text-primary hover:underline">Voir son profil</Link>
                    </div>
                </div>
                
                <button 
                    onClick={handlePropose} 
                    disabled={isPending}
                    className="btn-primary w-full sm:w-auto disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center gap-2"
                >
                    {isPending ? 'Envoi en cours...' : 'Envoyer la proposition'}
                </button>
            </div>

            <div className="grid md:grid-cols-2 divide-y md:divide-y-0 md:divide-x border-border">
                <div className="p-4 bg-danger/5">
                    <h3 className="font-bold text-danger mb-3 flex justify-between items-center text-sm uppercase tracking-wide">
                        Vous donnez ({localGiven.length})
                        <span className="bg-surface px-2 py-1 rounded shadow-sm border border-border text-foreground normal-case">
                            {totalGive.toFixed(2)} ‚Ç¨
                        </span>
                    </h3>
                    <TradeListText 
                        cards={localGiven} 
                        allowPriceEdit={true} 
                        onPriceChange={(id, val) => handleLocalPriceChange(id, val, 'give')} 
                        onPreview={onPreview}
                    />
                </div>

                <div className="p-4 bg-success/5">
                    <h3 className="font-bold text-success mb-3 flex justify-between items-center text-sm uppercase tracking-wide">
                        Vous recevez ({localReceived.length})
                        <span className="bg-surface px-2 py-1 rounded shadow-sm border border-border text-foreground normal-case">
                            {totalReceive.toFixed(2)} ‚Ç¨
                        </span>
                    </h3>
                    <TradeListText 
                        cards={localReceived} 
                        allowPriceEdit={true} 
                        onPriceChange={(id, val) => handleLocalPriceChange(id, val, 'receive')} 
                        onPreview={onPreview}
                    />
                </div>
            </div>

            <div className="p-3 text-center bg-secondary/20 border-t border-border">
                <span className="text-xs text-muted uppercase font-bold mr-2">Balance estim√©e :</span>
                <span className={`font-bold ${delta > 0 ? 'text-success' : 'text-danger'}`}>
                    {delta > 0 ? '+' : ''}{delta.toFixed(2)} EUR
                </span>
                <span className="text-xs text-muted ml-2">(Positif = Vous donnez plus de valeur)</span>
            </div>
        </div>
    );
};

// --- COMPOSANT DEMANDE ENTRANTE (AMI -> MOI) ---
const IncomingRequestCard = ({ 
    trade, 
    onPreview 
}: { 
    trade: TradeRequest,
    onPreview: (c: CardType) => void
}) => {
    const { acceptTrade, rejectTrade } = useTradeSystem();
    const [isOpen, setIsOpen] = useState(false);
    const [isProcessing, setIsProcessing] = useState(false);

    const valGive = trade.itemsReceived.reduce((acc, c) => acc + (c.customPrice ?? c.price ?? 0) * c.quantity, 0);
    const valReceive = trade.itemsGiven.reduce((acc, c) => acc + (c.customPrice ?? c.price ?? 0) * c.quantity, 0);

    return (
        <div className="bg-surface p-4 rounded-xl border border-border shadow-sm animate-in fade-in">
            <div className="flex flex-col sm:flex-row justify-between sm:items-center gap-3">
                <div>
                    <h3 className="font-bold text-foreground">Proposition de {trade.senderName}</h3>
                    <p className="text-sm text-muted">
                        Tu re√ßois <span className="text-success font-bold">{trade.itemsGiven.length} cartes</span> (~{valReceive.toFixed(0)}‚Ç¨) 
                        contre <span className="text-danger font-bold">{trade.itemsReceived.length} cartes</span> (~{valGive.toFixed(0)}‚Ç¨)
                    </p>
                </div>
                <div className="flex gap-2 self-end sm:self-auto">
                    <button onClick={() => setIsOpen(!isOpen)} className="text-sm text-muted hover:text-foreground underline mr-2">
                        {isOpen ? 'Masquer' : 'D√©tails'}
                    </button>
                    <button 
                        onClick={() => rejectTrade(trade.id)} 
                        disabled={isProcessing}
                        className="px-3 py-1.5 bg-secondary hover:bg-danger/20 text-danger rounded-lg text-sm font-medium transition"
                    >
                        Refuser
                    </button>
                    <button 
                        onClick={() => { setIsProcessing(true); acceptTrade(trade).finally(() => setIsProcessing(false)); }} 
                        disabled={isProcessing}
                        className="px-3 py-1.5 bg-primary hover:bg-primary/90 text-primary-foreground rounded-lg text-sm font-medium transition shadow-sm"
                    >
                        {isProcessing ? '...' : 'Accepter'}
                    </button>
                </div>
            </div>

            {isOpen && (
                <div className="mt-4 pt-4 border-t border-border grid md:grid-cols-2 gap-4">
                    <div className="bg-success/5 p-3 rounded">
                        <p className="text-xs font-bold text-success mb-2">Tu vas recevoir :</p>
                        <div className="flex flex-wrap gap-2">
                            {trade.itemsGiven.map((c: CardType) => (
                                <div 
                                    key={c.id} 
                                    className="relative group w-12 h-16 bg-black/10 rounded overflow-hidden cursor-pointer hover:scale-105 transition-transform"
                                    onClick={() => onPreview(c)}
                                >
                                    <Image 
                                        src={c.imageUrl} 
                                        alt={c.name} 
                                        fill
                                        className="object-cover"
                                        sizes="48px"
                                    />
                                    <div className="absolute bottom-0 right-0 bg-black/50 text-white text-[8px] px-1 font-bold">{c.quantity}x</div>
                                </div>
                            ))}
                        </div>
                    </div>

                    <div className="bg-danger/5 p-3 rounded">
                        <p className="text-xs font-bold text-danger mb-2">Tu vas donner :</p>
                        <div className="flex flex-wrap gap-2">
                            {trade.itemsReceived.map((c: CardType) => (
                                <div 
                                    key={c.id} 
                                    className="relative group w-12 h-16 bg-black/10 rounded overflow-hidden cursor-pointer hover:scale-105 transition-transform"
                                    onClick={() => onPreview(c)}
                                >
                                    <Image 
                                        src={c.imageUrl} 
                                        alt={c.name} 
                                        fill
                                        className="object-cover"
                                        sizes="48px"
                                    />
                                    <div className="absolute bottom-0 right-0 bg-black/50 text-white text-[8px] px-1 font-bold">{c.quantity}x</div>
                                </div>
                            ))}
                        </div>
                    </div>
                </div>
            )}
        </div>
    );
};

// --- COMPOSANT PAGE PRINCIPALE ---
export default function TradesPageContent() {
    const { user } = useAuth();
    const { proposals, loading, status, runScan } = useTradeMatcher();
    const { incomingTrades, outgoingTrades } = useTradeSystem();
    const searchParams = useSearchParams();
    
    const initialTab = searchParams.get('tab') === 'requests' ? 'requests' : 'scan';
    const [activeTab, setActiveTab] = useState<'scan' | 'requests'>(initialTab);
    const [previewCard, setPreviewCard] = useState<CardType | null>(null);

    if (!user) return <div className="p-10 text-center text-muted">Connectez-vous pour voir vos √©changes.</div>;

    return (
        <div className="container mx-auto p-4 max-w-5xl h-[calc(100vh-64px)] flex flex-col">
            
            <div className="flex-none mb-6">
                <h1 className="text-3xl font-bold text-foreground mb-4">Centre d&apos;√âchanges</h1>
                <div className="flex gap-4 border-b border-border">
                    <button 
                        onClick={() => setActiveTab('scan')}
                        className={`pb-3 text-sm font-bold transition-colors border-b-2 ${activeTab === 'scan' ? 'border-primary text-primary' : 'border-transparent text-muted hover:text-foreground'}`}
                    >
                        Scanner Intelligent ({proposals.length})
                    </button>
                    <button 
                        onClick={() => setActiveTab('requests')}
                        className={`pb-3 text-sm font-bold transition-colors border-b-2 ${activeTab === 'requests' ? 'border-primary text-primary' : 'border-transparent text-muted hover:text-foreground'}`}
                    >
                        Demandes ({incomingTrades.length + outgoingTrades.length})
                    </button>
                    
                    <Link 
                        href="/trades/history"
                        className="pb-3 text-sm font-bold transition-colors border-b-2 border-transparent text-muted hover:text-foreground ml-auto flex items-center gap-1"
                    >
                        Historique
                    </Link>
                </div>
            </div>

            <div className="grow overflow-y-auto custom-scrollbar pb-10">
                
                {activeTab === 'scan' && (
                    <div className="animate-in fade-in">
                        <div className="flex flex-col sm:flex-row justify-end mb-6 gap-3 sticky top-0 bg-background/95 backdrop-blur-sm z-10 py-2 border-b border-border/50">
                            <Link href="/trades/manual" className="bg-secondary hover:bg-border text-foreground px-4 py-2 rounded-lg font-bold transition text-sm flex items-center justify-center">
                                Mode Manuel
                            </Link>
                            <button 
                                onClick={runScan} 
                                disabled={loading}
                                className="bg-primary hover:bg-primary/90 text-primary-foreground px-4 py-2 rounded-lg font-bold shadow transition text-sm disabled:opacity-50 w-full sm:w-auto"
                            >
                                {loading ? status : "Lancer le Scanner"}
                            </button>
                        </div>

                        {proposals.length === 0 && !loading && (
                            <div className="text-center py-20 text-muted border-2 border-dashed border-border rounded-xl">
                                Lancez le scanner pour trouver des &quot;matchs&quot; avec vos amis.
                            </div>
                        )}

                        <div className="space-y-8">
                            {proposals.map(proposal => (
                                <TradeRowProposal 
                                    key={proposal.friend.uid} 
                                    proposal={proposal} 
                                    onProposalSent={runScan}
                                    onPreview={setPreviewCard}
                                />
                            ))}
                        </div>
                    </div>
                )}

                {activeTab === 'requests' && (
                    <div className="animate-in fade-in space-y-8">
                        <div>
                            <h2 className="font-bold text-muted uppercase text-xs mb-4 sticky top-0 bg-background py-2 z-10">
                                √Ä traiter ({incomingTrades.length})
                            </h2>
                            {incomingTrades.length === 0 && <p className="text-muted italic text-sm">Aucune demande en attente.</p>}
                            <div className="space-y-4">
                                {incomingTrades.map((trade: TradeRequest) => (
                                    <IncomingRequestCard 
                                        key={trade.id} 
                                        trade={trade} 
                                        onPreview={setPreviewCard}
                                    />
                                ))}
                            </div>
                        </div>

                        <div>
                            <h2 className="font-bold text-muted uppercase text-xs mb-4 pt-4 border-t border-border">
                                En attente de r√©ponse ({outgoingTrades.length})
                            </h2>
                            {outgoingTrades.length === 0 && <p className="text-muted italic text-sm">Aucune proposition en cours.</p>}
                            <div className="space-y-3">
                                {outgoingTrades.map((trade: TradeRequest) => (
                                    <div key={trade.id} className="flex justify-between items-center p-3 bg-secondary/30 rounded-lg border border-border">
                                        <div>
                                            <span className="font-bold text-foreground">Pour {trade.receiverName}</span>
                                            <p className="text-xs text-muted">Envoy√© le {new Date(trade.createdAt.seconds * 1000).toLocaleDateString()}</p>
                                        </div>
                                        <span className="text-xs bg-secondary px-2 py-1 rounded text-muted font-medium">En attente</span>
                                    </div>
                                ))}
                            </div>
                        </div>
                    </div>
                )}
            </div>

            {previewCard && (
                <div 
                    className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black/60 backdrop-blur-sm animate-in fade-in cursor-pointer"
                    onClick={() => setPreviewCard(null)}
                >
                    <div className="relative transform transition-all scale-100 p-4" onClick={e => e.stopPropagation()}>
                        <button 
                            onClick={() => setPreviewCard(null)} 
                            className="absolute -top-2 -right-2 bg-surface text-foreground rounded-full p-2 shadow-lg z-10 border border-border hover:bg-secondary transition-colors"
                        >
                            ‚úï
                        </button>
                        <div className="w-[300px] h-[420px] shadow-2xl rounded-xl overflow-hidden pointer-events-none">
                            <MagicCard {...previewCard} readOnly={true} quantity={previewCard.quantity} />
                        </div>
                    </div>
                </div>
            )}
        </div>
    );
}
</file>

<file path="hooks/useCardCollection.ts">
// hooks/useCardCollection.ts
import { useState, useEffect, useMemo } from 'react';
import { db } from '@/lib/firebase';
import { collection, onSnapshot, doc, updateDoc, deleteDoc, increment, writeBatch, DocumentData } from 'firebase/firestore';
import { useAuth } from '@/lib/AuthContext';
import toast from 'react-hot-toast';
import { updateUserStats } from '@/app/actions/stats';
import { checkAutoMatch, removeAutoMatchNotification } from '@/app/actions/matching';
import { refreshUserCollectionPrices } from '@/app/actions/collection';

interface FirestoreCardData extends DocumentData {
    name?: string;
    imageUrl?: string;
    imageBackUrl?: string;
    quantity?: number;
    price?: number;
    purchasePrice?: number;
    customPrice?: number;
    setName?: string;
    setCode?: string;
    isFoil?: boolean;
    isSpecificVersion?: boolean;
    quantityForTrade?: number;
    isForTrade?: boolean;
    lastPriceUpdate?: { toDate: () => Date } | Date;
    scryfallData?: Record<string, unknown>;
    cmc?: number;
    colors?: string[];
}

export type CardType = {
    uid?: string;
    id: string;
    name: string;
    imageUrl: string;
    imageBackUrl: string | null;
    quantity: number;
    price?: number;
    purchasePrice?: number;
    customPrice?: number;
    setName: string;
    setCode: string;
    wishlistId?: string | null;
    isFoil: boolean;
    isSpecificVersion: boolean;
    quantityForTrade: number;
    isForTrade?: boolean;
    cmc?: number;
    colors?: string[];
    lastPriceUpdate?: Date | null;
    scryfallData?: Record<string, unknown> | null;
};

export function useCardCollection(target: 'collection' | 'wishlist', listId: string = 'default', targetUid?: string) {
    const { user, loading: authLoading } = useAuth();
    const [cards, setCards] = useState<CardType[]>([]);
    const [loading, setLoading] = useState(true);

    const effectiveUid = targetUid || user?.uid;
    const isOwner = !!user && user.uid === effectiveUid;

    useEffect(() => {
        if (!effectiveUid || authLoading) {
            if (!authLoading && !effectiveUid) {
                setLoading(false);
                setCards([]);
            }
            return;
        }

        setLoading(true);
        let collectionPath = '';

        if (target === 'collection') {
            if (listId === 'default') collectionPath = `users/${effectiveUid}/collection`;
            else collectionPath = `users/${effectiveUid}/collections_data/${listId}/cards`;
        } else {
            if (listId === 'default') collectionPath = `users/${effectiveUid}/wishlist`;
            else collectionPath = `users/${effectiveUid}/wishlists_data/${listId}/cards`;
        }

        const colRef = collection(db, collectionPath);

        const unsubscribe = onSnapshot(colRef, (snapshot) => {
            const items = snapshot.docs.map((doc) => {
                const data = doc.data() as FirestoreCardData;
                
                let lastUpdate: Date | null = null;
                if (data.lastPriceUpdate && typeof (data.lastPriceUpdate as { toDate: () => Date }).toDate === 'function') {
                    lastUpdate = (data.lastPriceUpdate as { toDate: () => Date }).toDate();
                } else if (data.lastPriceUpdate instanceof Date) {
                    lastUpdate = data.lastPriceUpdate;
                }

                // --- FALLBACK ROBUSTE ---
                let finalColors = Array.isArray(data.colors) ? data.colors : undefined;
                let finalCmc = typeof data.cmc === 'number' ? data.cmc : undefined;

                if (data.scryfallData) {
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    const sd = data.scryfallData as any;
                    if (finalCmc === undefined && typeof sd.cmc === 'number') finalCmc = sd.cmc;
                    if (!finalColors) {
                        if (Array.isArray(sd.color_identity)) {
                            finalColors = sd.color_identity;
                        } else if (Array.isArray(sd.colors)) {
                            finalColors = sd.colors;
                        }
                    }
                }
                if (finalColors && finalColors.length === 0 && Array.isArray(data.colors) && data.colors.length > 0) {
                    finalColors = data.colors;
                }
                // -----------------------

                return {
                    id: doc.id,
                    uid: effectiveUid,
                    wishlistId: target === 'wishlist' ? (listId === 'default' ? null : listId) : null,
                    name: data.name || 'Carte Inconnue',
                    imageUrl: data.imageUrl || '',
                    imageBackUrl: data.imageBackUrl ?? null,
                    quantity: typeof data.quantity === 'number' ? data.quantity : 1,
                    price: typeof data.price === 'number' ? data.price : 0,
                    purchasePrice: typeof data.purchasePrice === 'number' ? data.purchasePrice : undefined,
                    customPrice: typeof data.customPrice === 'number' ? data.customPrice : undefined,
                    setName: data.setName || '',
                    setCode: data.setCode || '',
                    isFoil: !!data.isFoil,
                    isSpecificVersion: !!data.isSpecificVersion,
                    quantityForTrade: typeof data.quantityForTrade === 'number' ? data.quantityForTrade : 0,
                    isForTrade: !!data.isForTrade,
                    cmc: finalCmc,
                    colors: finalColors,
                    lastPriceUpdate: lastUpdate,
                    scryfallData: data.scryfallData || null
                } as CardType;
            });

            const validItems = items.filter(card => card.quantity > 0);
            setCards(validItems);
            setLoading(false);
        }, (error) => {
            console.error(error);
            setLoading(false);
        });

        return () => unsubscribe();
    }, [effectiveUid, target, listId, authLoading]);

    // --- ACTIONS ---

    const triggerStatsUpdate = () => {
        if (user?.uid && isOwner && target === 'collection' && listId === 'default') {
            updateUserStats(user.uid).catch(console.error);
        }
    };

    const getDocRef = (cardId: string) => {
        if (!isOwner || !effectiveUid) return null;
        let path = '';
        if (target === 'collection') {
            if (listId === 'default') path = `users/${effectiveUid}/collection`;
            else path = `users/${effectiveUid}/collections_data/${listId}/cards`;
        } else if (listId === 'default') path = `users/${effectiveUid}/wishlist`;
        else path = `users/${effectiveUid}/wishlists_data/${listId}/cards`;
        
        return doc(db, path, cardId);
    };

    const setPurchasePrice = async (cardId: string, price: number) => {
        if (!isOwner) return;
        const ref = getDocRef(cardId);
        if (ref) {
            await updateDoc(ref, { purchasePrice: price });
            toast.success("Prix d'acquisition enregistr√©");
        }
    };

    const setCustomPrice = async (cardId: string, price: number) => {
        if (!isOwner) return;
        const ref = getDocRef(cardId);
        if (ref) {
            await updateDoc(ref, { customPrice: price });
            triggerStatsUpdate();
        }
    };

    // Nouvelle fonction pour le debounce
    const setCardQuantity = async (cardId: string, newQuantity: number) => {
        if (!isOwner) return;
        const ref = getDocRef(cardId);
        if (!ref) return;
        
        // S√©curit√© : on ne g√®re pas la suppression ici (le bouton '-' g√®re le cas 0)
        if (newQuantity <= 0) return;

        try {
            await updateDoc(ref, { quantity: newQuantity });
            triggerStatsUpdate();
        } catch (error) {
            console.error("Erreur setCardQuantity", error);
            toast.error("Erreur de sauvegarde");
        }
    };

    const setTradeQuantity = async (cardId: string, quantity: number) => {
        if (!isOwner || !user || target !== 'collection') return;
        const card = cards.find(c => c.id === cardId);
        if (!card) return;

        const maxQty = card.quantity;
        const safeQty = Math.min(maxQty, Math.max(0, quantity));

        const ref = getDocRef(cardId);
        if (ref) {
            await updateDoc(ref, { quantityForTrade: safeQty, isForTrade: safeQty > 0 });
            
            if (safeQty > 0) {
                checkAutoMatch(user.uid, [{ id: card.id, name: card.name, isFoil: !!card.isFoil }])
                    .then(res => {
                        if (res.matches && res.matches > 0) {
                            toast(`Match trouv√© !`, { icon: 'üîî' });
                        }
                    });
            } else {
                removeAutoMatchNotification(user.uid, [card.id]);
            }
        }
    };

    const toggleAttribute = async (
        cardId: string, 
        field: 'isFoil' | 'isSpecificVersion', 
        currentValue: boolean
    ) => {
        if (!isOwner) return;
        const ref = getDocRef(cardId);
        if (ref) {
            await updateDoc(ref, { [field]: !currentValue });
            if (field === 'isFoil') triggerStatsUpdate();
        }
    };

    const updateQuantity = async (cardId: string, amount: number, currentQuantity: number) => {
        if (!isOwner) return;
        const ref = getDocRef(cardId);
        if (!ref) return;

        if (currentQuantity + amount <= 0) return 'shouldDelete';

        try {
            await updateDoc(ref, { quantity: increment(amount) });
            triggerStatsUpdate();
            return 'updated';
        } catch {
            return 'error';
        }
    };

    const removeCard = async (cardId: string) => {
        if (!isOwner) return;
        const ref = getDocRef(cardId);
        if(ref) {
            await deleteDoc(ref);
            toast.success('Carte retir√©e');
            triggerStatsUpdate();
            if (target === 'collection') {
                removeAutoMatchNotification(user?.uid || '', [cardId]);
            }
        }
    };

    // --- MISE √Ä JOUR GLOBALE DES PRIX ---
    const refreshCollectionPricesAction = async () => {
        await refreshUserCollectionPrices(user?.uid || '');
        // Note: Cette fonction appelle d√©sormais la Server Action, 
        // mais pour l'instant je garde votre logique existante si vous n'avez pas encore migr√©
        // Je r√©utilise votre code existant pour ne pas casser la logique
        await refreshCollectionPrices(); 
    };

    // Votre ancienne fonction (gard√©e pour compatibilit√© imm√©diate)
    const refreshCollectionPrices = async () => {
        if (!isOwner || cards.length === 0) return;
        const toastId = toast.loading(`Mise √† jour de ${cards.length} cartes...`);

        try {
            const chunks = [];
            for (let i = 0; i < cards.length; i += 75) {
                chunks.push(cards.slice(i, i + 75));
            }

            for (const chunk of chunks) {
                const identifiers = chunk.map(c => ({ id: c.id }));
                const res = await fetch('https://api.scryfall.com/cards/collection', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ identifiers })
                });

                if (!res.ok) continue;

                const data = await res.json();
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                const foundCards = (data.data as any[]) || [];
                const batch = writeBatch(db);
                let batchHasOps = false;

                foundCards.forEach(scryCard => {
                    const localCard = chunk.find(c => c.id === scryCard.id);
                    const newPrice = parseFloat(scryCard.prices?.eur || "0");

                    if (localCard) {
                        const ref = getDocRef(localCard.id);
                        if (ref) {
                            batch.update(ref, { 
                                price: newPrice,
                                scryfallData: scryCard as Record<string, unknown>
                            });
                            batchHasOps = true;
                        }
                    }
                });

                if (batchHasOps) await batch.commit();
                await new Promise(r => setTimeout(r, 100)); 
            }
            toast.success("Collection mise √† jour avec succ√®s !", { id: toastId });
        } catch (e) {
            console.error(e);
            toast.error("Erreur lors de la mise √† jour", { id: toastId });
        }
    };

    // --- GESTION DE MASSE DU CLASSEUR D'√âCHANGE ---
    const bulkSetTradeStatus = async (
        action: 'excess' | 'all' | 'reset', 
        threshold: number = 4
    ) => {
        if (!isOwner || cards.length === 0) return;

        const batch = writeBatch(db);
        let opCount = 0;
        let label = "";

        cards.forEach(card => {
            let shouldUpdate = false;
            let newValue = false;

            if (action === 'reset') {
                if (card.isForTrade) {
                    shouldUpdate = true;
                    newValue = false;
                }
                label = "Remise √† z√©ro";
            } else if (action === 'all') {
                if (!card.isForTrade) {
                    shouldUpdate = true;
                    newValue = true;
                }
                label = "Tout ajouter";
            } else if (action === 'excess') {
                if (card.quantity > threshold && !card.isForTrade) {
                    shouldUpdate = true;
                    newValue = true;
                }
            }

            if (shouldUpdate) {
                const ref = getDocRef(card.id);
                if (ref) {
                    batch.update(ref, { isForTrade: newValue });
                    opCount++;
                }
            }
        });

        if (opCount > 0) {
            await batch.commit();
            toast.success(`${opCount} cartes mises √† jour (${action === 'excess' ? `Quantit√© > ${threshold}` : label})`);
        } else {
            toast(`Aucune carte ne correspond aux crit√®res.`);
        }
    };

    // --- ACTIONS DE S√âLECTION MULTIPLE ---
    const bulkRemoveCards = async (cardIds: string[]) => {
        if (!isOwner || cardIds.length === 0) return;
        const batch = writeBatch(db);
        cardIds.forEach(id => {
            const ref = getDocRef(id);
            if (ref) batch.delete(ref);
        });
        await batch.commit();
        toast.success(`${cardIds.length} cartes supprim√©es`);
    };

    const bulkUpdateAttribute = async (cardIds: string[], field: 'isForTrade' | 'isFoil', value: boolean) => {
        if (!isOwner || cardIds.length === 0) return;
        const batch = writeBatch(db);
        cardIds.forEach(id => {
            const ref = getDocRef(id);
            if (ref) batch.update(ref, { [field]: value });
        });
        await batch.commit();
        toast.success("Mise √† jour effectu√©e");
    };

    const totalPrice = useMemo(() => {
        return cards.reduce((acc, card) => {
            const effectivePrice = card.customPrice !== undefined ? card.customPrice : (card.price || 0);
            return acc + effectivePrice * card.quantity;
        }, 0);
    }, [cards]);

    return { 
        cards, loading, isOwner, totalPrice,
        updateQuantity, setCardQuantity, // Export de la nouvelle fonction
        removeCard, setCustomPrice, toggleAttribute,
        refreshCollectionPrices: refreshCollectionPricesAction, 
        bulkSetTradeStatus, bulkRemoveCards, bulkUpdateAttribute,
        setTradeQuantity,
        setPurchasePrice
    };
}
</file>

<file path="app/collection/page.tsx">
// app/collection/page.tsx
'use client';

import { useState, useMemo, useEffect, Suspense } from 'react';
import { useAuth } from '@/lib/AuthContext';
import { useCardCollection } from '@/hooks/useCardCollection';
import MagicCard from '@/components/MagicCard';
import ConfirmModal from '@/components/ConfirmModal';
import CollectionToolsModal from '@/components/CollectionToolsModal';
import DataTransferHubModal from '@/components/DataTransferHubModal';
import ImportModal from '@/components/ImportModal';
import ExportModal from '@/components/ExportModal';
import { useColumnPreference } from '@/hooks/useColumnPreference';
import { useSortPreference, SortOption } from '@/hooks/useSortPreference';
import CardListFilterBar from '@/components/common/CardListFilterBar';
import CollectionToolbar from '@/components/collection/CollectionToolbar';
import { useCollections } from '@/hooks/useCollections';
import { useSearchParams, useRouter } from 'next/navigation';
import { LockedListModal } from '@/components/LockedListModal';
import { Lock } from 'lucide-react'; // AJOUT DE L'IMPORT

const ITEMS_PER_PAGE = 50;

function CollectionContent() {
    const { user, userProfile } = useAuth();
    const searchParams = useSearchParams();
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const router = useRouter();
    const selectedListId = searchParams.get('listId') || 'default';

    const { lists: collectionsMeta } = useCollections();
    const { 
        cards, loading, updateQuantity, setCardQuantity,
        removeCard, setCustomPrice, setTradeQuantity, toggleAttribute, 
        refreshCollectionPrices, bulkSetTradeStatus, bulkRemoveCards, totalPrice 
    } = useCardCollection('collection', selectedListId);

    // --- LOGIQUE DE VERROUILLAGE (Soft Lock) ---
    const isLocked = useMemo(() => {
        if (selectedListId === 'default' || selectedListId === 'GLOBAL_VIEW') return false;
        if (userProfile?.isPremium) return false;

        const sortedLists = [...collectionsMeta].sort((a, b) => (a.createdAt?.seconds || 0) - (b.createdAt?.seconds || 0));
        const index = sortedLists.findIndex(l => l.id === selectedListId);
        
        return index >= 1;
    }, [selectedListId, collectionsMeta, userProfile]);

    const [isHubOpen, setIsHubOpen] = useState(false);
    const [isImportOpen, setIsImportOpen] = useState(false);
    const [isExportOpen, setIsExportOpen] = useState(false);
    const [isToolsOpen, setIsToolsOpen] = useState(false);
    const [cardToDelete, setCardToDelete] = useState<string | null>(null);
    
    const [isSelectMode, setIsSelectMode] = useState(false);
    const [selectedIds, setSelectedIds] = useState<string[]>([]);
    
    const [visibleCount, setVisibleCount] = useState(ITEMS_PER_PAGE);
    const { columns, setColumns } = useColumnPreference('mw_cols_collection', 5);
    
    // Filtres
    const [searchQuery, setSearchQuery] = useState('');
    const { sortBy, setSortBy } = useSortPreference('mw_sort_collection', 'date_desc' as SortOption);
    const [filterSet, setFilterSet] = useState<string>('all');
    const [filterTrade, setFilterTrade] = useState(false);
    const [filterFoil, setFilterFoil] = useState(false);
    const [minPriceFilter, setMinPriceFilter] = useState<string>('');
    const [maxPriceFilter, setMaxPriceFilter] = useState<string>('');
    const [filterCMC, setFilterCMC] = useState<string>('');
    const [filterColors, setFilterColors] = useState<string[]>([]);

    const currentListName = useMemo(() => {
        return collectionsMeta.find(l => l.id === selectedListId)?.name || 'Collection Principale';
    }, [collectionsMeta, selectedListId]);

    const closeAllModals = () => {
        setIsHubOpen(false);
        setIsImportOpen(false);
        setIsExportOpen(false);
    };

    const openHub = () => {
        setIsImportOpen(false);
        setIsExportOpen(false);
        setIsHubOpen(true);
    };

    const handleSelectImport = () => { setIsHubOpen(false); setIsImportOpen(true); };
    const handleSelectExport = () => { setIsHubOpen(false); setIsExportOpen(true); };

    useEffect(() => {
        if (visibleCount !== ITEMS_PER_PAGE) {
            setVisibleCount(ITEMS_PER_PAGE);
        }
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [searchQuery, sortBy, filterSet, filterTrade, filterFoil, minPriceFilter, maxPriceFilter, filterCMC, filterColors, selectedListId]);

    const filteredAndSortedCards = useMemo(() => {
        let result = [...cards];
        const minPrice = parseFloat(minPriceFilter);
        const maxPrice = parseFloat(maxPriceFilter);

        if (searchQuery) {
            const lowerQ = searchQuery.toLowerCase();
            result = result.filter(c => c.name.toLowerCase().includes(lowerQ));
        }
        if (filterSet !== 'all') result = result.filter(c => c.setName === filterSet);
        if (filterTrade) result = result.filter(c => (c.quantityForTrade ?? 0) > 0);
        if (filterFoil) result = result.filter(c => c.isFoil);

        if (!isNaN(minPrice) || !isNaN(maxPrice)) {
            result = result.filter(c => {
                const cardPrice = c.customPrice ?? c.price ?? 0;
                const isAboveMin = isNaN(minPrice) || cardPrice >= minPrice;
                const isBelowMax = isNaN(maxPrice) || cardPrice <= maxPrice;
                return isAboveMin && isBelowMax;
            });
        }

        if (filterCMC) { 
            const t = parseFloat(filterCMC); 
            if (!isNaN(t)) result = result.filter(c => c.cmc === t); 
        }

        if (filterColors.length > 0) {
            result = result.filter(c => {
                if (!c.colors || c.colors.length === 0) return filterColors.includes('C');
                return c.colors.every(col => filterColors.includes(col));
            });
        }

        result.sort((a, b) => {
            const priceA = a.customPrice ?? a.price ?? 0;
            const priceB = b.customPrice ?? b.price ?? 0;
            const dateA = a.lastPriceUpdate ? new Date(a.lastPriceUpdate).getTime() : 0;
            const dateB = b.lastPriceUpdate ? new Date(b.lastPriceUpdate).getTime() : 0;
            const cmcA = a.cmc ?? 0;
            const cmcB = b.cmc ?? 0;

            switch (sortBy) {
                case 'name_asc': return a.name.localeCompare(b.name);
                case 'name_desc': return b.name.localeCompare(a.name);
                case 'name': return a.name.localeCompare(b.name);
                case 'price_asc': return priceA - priceB;
                case 'price_desc': return priceB - priceA;
                case 'quantity_asc': return a.quantity - b.quantity;
                case 'quantity_desc': return b.quantity - a.quantity;
                case 'quantity': return b.quantity - a.quantity;
                case 'date_asc': return dateA - dateB;
                case 'date_desc': return dateB - dateA;
                case 'date': return dateB - dateA;
                case 'cmc_asc': return cmcA - cmcB;
                case 'cmc_desc': return cmcB - cmcA;
                case 'set_asc': return (a.setName || '').localeCompare(b.setName || '');
                case 'set_desc': return (b.setName || '').localeCompare(a.setName || '');
                default: return 0;
            }
        });

        return result;
    }, [cards, searchQuery, sortBy, filterSet, filterTrade, filterFoil, minPriceFilter, maxPriceFilter, filterCMC, filterColors]);

    const visibleCards = useMemo(() => {
        return filteredAndSortedCards.slice(0, visibleCount);
    }, [filteredAndSortedCards, visibleCount]);

    const handleDecrement = async (cardId: string, currentQty: number) => {
        if (isLocked) return;
        if (currentQty === 1) {
            setCardToDelete(cardId);
        } else {
            await updateQuantity(cardId, -1, currentQty);
        }
    };

    const confirmDeleteSingle = async () => {
        if (isLocked) return;
        if (cardToDelete) {
            await removeCard(cardToDelete);
            setCardToDelete(null);
        }
    };

    const toggleSelection = (id: string) => {
        if (isLocked) return;
        if (selectedIds.includes(id)) {
            setSelectedIds(selectedIds.filter(pid => pid !== id));
        } else {
            setSelectedIds([...selectedIds, id]);
        }
    };

    const handleSelectAll = () => {
        if (isLocked) return;
        if (selectedIds.length === filteredAndSortedCards.length) {
            setSelectedIds([]);
        } else {
            setSelectedIds(filteredAndSortedCards.map(c => c.id));
        }
    };

    const handleBulkDelete = async () => {
        if (isLocked) return;
        if (!confirm(`Supprimer ces ${selectedIds.length} cartes d√©finitivement ?`)) return;
        await bulkRemoveCards(selectedIds);
        setSelectedIds([]);
        setIsSelectMode(false);
    };

    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const handleBulkTrade = async (isForTrade: boolean) => {
        if (isLocked) return;
        alert("Fonction √† venir pour la s√©lection multiple sp√©cifique.");
    };

    const handleIncrementTrade = (cardId: string, currentTradeQty: number, totalQty: number) => {
        if (isLocked) return;
        if (currentTradeQty < totalQty) {
            setTradeQuantity(cardId, currentTradeQty + 1);
        }
    };

    const handleDecrementTrade = (cardId: string, currentTradeQty: number) => {
        if (isLocked) return;
        if (currentTradeQty > 0) {
            setTradeQuantity(cardId, currentTradeQty - 1);
        }
    };

    if (!user) return <p className="p-10 text-center text-muted">Veuillez vous connecter.</p>;

    return (
        <main className="container mx-auto p-4 pb-24 relative">
            <LockedListModal isOpen={isLocked} listName={currentListName} />

            <div className="flex justify-between items-end mb-6 bg-surface p-4 rounded-xl border border-border shadow-sm">
                <div>
                    <h1 className="text-2xl font-bold text-foreground flex items-center gap-2">
                        {currentListName}
                        {/* UTILISATION DE L'IC√îNE LOCK */}
                        {isLocked && <Lock className="w-5 h-5 text-muted-foreground" />}
                    </h1>
                    <p className="text-sm text-muted mt-1">
                        {filteredAndSortedCards.length} cartes {isLocked && "(Lecture Seule)"} ‚Ä¢ <span className="text-success font-bold">{totalPrice.toFixed(2)} ‚Ç¨</span>
                    </p>
                </div>
            </div>

            {!isLocked && (
                <CollectionToolbar 
                    isSelectMode={isSelectMode} 
                    setIsSelectMode={setIsSelectMode} 
                    onOpenTools={() => setIsToolsOpen(true)}
                    onOpenHub={openHub}
                />
            )}

            <CardListFilterBar
                context="collection"
                cards={cards}
                searchQuery={searchQuery}
                setSearchQuery={setSearchQuery}
                sortBy={sortBy}
                setSortBy={setSortBy}
                filterSet={filterSet}
                setFilterSet={setFilterSet}
                filterTrade={filterTrade}
                setFilterTrade={setFilterTrade}
                filterFoil={filterFoil}
                setFilterFoil={setFilterFoil}
                minPriceFilter={minPriceFilter}
                setMinPriceFilter={setMinPriceFilter}
                maxPriceFilter={maxPriceFilter}
                setMaxPriceFilter={setMaxPriceFilter}
                filterCMC={filterCMC}
                setFilterCMC={setFilterCMC}
                filterColors={filterColors}
                setFilterColors={setFilterColors}
                columns={columns}
                setColumns={setColumns}
            />

            {isSelectMode && !isLocked && (
                <div className="mb-4 flex items-center justify-between bg-primary/10 p-3 rounded-lg border border-primary/30 animate-in fade-in">
                    <span className="font-bold text-primary pl-2">{selectedIds.length} carte(s) s√©lectionn√©e(s)</span>
                    <button 
                        onClick={handleSelectAll}
                        className="text-sm text-primary font-bold px-3 py-1 rounded hover:bg-primary/10 transition"
                    >
                        {selectedIds.length === filteredAndSortedCards.length ? 'Tout d√©s√©lectionner' : 'Tout s√©lectionner'}
                    </button>
                </div>
            )}

            {loading ? (
                <p className="text-center p-10 text-muted">Chargement de votre collection...</p>
            ) : filteredAndSortedCards.length === 0 ? (
                <div className="text-center py-20 bg-secondary/50 rounded-xl border-2 border-dashed border-border">
                    <p className="text-xl text-muted mb-4">Aucun r√©sultat ne correspond √† vos filtres.</p>
                    <button onClick={() => { setSearchQuery(''); setFilterSet('all'); }} className="text-primary hover:underline">R√©initialiser les filtres</button>
                </div>
            ) : (
                <>
                    <div 
                        className="grid gap-4 grid-cols-2 md:grid-cols-[repeat(var(--cols),minmax(0,1fr))]"
                        style={{ '--cols': columns } as React.CSSProperties}
                    >
                        {visibleCards.map((card) => (
                            <div key={card.id} className="relative group">
                                <MagicCard 
                                    {...card} 
                                    hideFooter={isLocked}
                                    isSelectMode={isSelectMode && !isLocked}
                                    isSelected={selectedIds.includes(card.id)}
                                    onSelect={() => toggleSelection(card.id)}
                                    onQuantityChange={!isLocked ? (newVal) => setCardQuantity(card.id, newVal) : undefined}
                                    onDecrement={!isLocked ? () => handleDecrement(card.id, card.quantity) : undefined}
                                    onEditPrice={!isLocked ? (newPrice) => setCustomPrice(card.id, newPrice) : undefined}
                                    onToggleAttribute={!isLocked ? (field, val) => toggleAttribute(card.id, field, val) : undefined}
                                    onIncrementTrade={!isLocked ? () => handleIncrementTrade(card.id, card.quantityForTrade ?? 0, card.quantity) : undefined}
                                    onDecrementTrade={!isLocked ? () => handleDecrementTrade(card.id, card.quantityForTrade ?? 0) : undefined}
                                    allowPriceEdit={!isLocked}
                                />
                            </div>
                        ))}
                    </div>

                    {visibleCount < filteredAndSortedCards.length && (
                        <div className="mt-8 flex justify-center pb-10">
                            <button 
                                onClick={() => setVisibleCount(prev => prev + ITEMS_PER_PAGE)}
                                className="bg-surface hover:bg-secondary text-foreground border border-border px-8 py-3 rounded-full font-bold shadow-sm transition flex items-center gap-2"
                            >
                                Afficher plus ({filteredAndSortedCards.length - visibleCount})
                            </button>
                        </div>
                    )}
                </>
            )}

            {isSelectMode && selectedIds.length > 0 && !isLocked && (
                <div className="fixed bottom-6 left-4 right-4 md:left-1/2 md:right-auto md:-translate-x-1/2 bg-surface shadow-2xl border border-border p-2 rounded-2xl flex items-center justify-around gap-2 z-50 animate-in slide-in-from-bottom-6 duration-300">
                    <button onClick={() => handleBulkTrade(true)} className="px-4 py-2 bg-success/10 hover:bg-success/20 text-success rounded-xl text-sm font-bold transition flex flex-col items-center leading-none gap-1">
                        <span>Trade</span>
                    </button>
                    <button onClick={() => handleBulkTrade(false)} className="px-4 py-2 bg-secondary hover:bg-border text-foreground rounded-xl text-sm font-bold transition flex flex-col items-center leading-none gap-1">
                        <span>Priv√©</span>
                    </button>
                    <div className="w-px h-8 bg-border mx-1"></div>
                    <button onClick={handleBulkDelete} className="px-4 py-2 bg-danger hover:bg-red-600 text-white rounded-xl text-sm font-bold transition flex flex-col items-center leading-none gap-1 shadow-md">
                        <span>Suppr</span>
                    </button>
                </div>
            )}

            <DataTransferHubModal isOpen={isHubOpen} onClose={closeAllModals} onSelectImport={handleSelectImport} onSelectExport={handleSelectExport} targetLabel="Collection" />
            <ImportModal isOpen={isImportOpen} onClose={closeAllModals} onGoBack={openHub} onCloseAll={closeAllModals} targetCollection="collection" listId={selectedListId} />
            <ExportModal isOpen={isExportOpen} onClose={closeAllModals} onGoBack={openHub} onCloseAll={closeAllModals} cards={cards} listName={currentListName} targetType="collection" />
            
            <CollectionToolsModal isOpen={isToolsOpen} onClose={() => setIsToolsOpen(false)} totalCards={cards.length} onRefreshPrices={refreshCollectionPrices} onBulkTrade={bulkSetTradeStatus} />
            
            <ConfirmModal isOpen={!!cardToDelete} onClose={() => setCardToDelete(null)} onConfirm={confirmDeleteSingle} title="Retirer ?" message="Cette carte sera retir√©e de votre collection." />
        </main>
    );
}

export default function CollectionPage() {
    return (
        <Suspense fallback={<div className="flex h-screen items-center justify-center text-muted animate-pulse">Chargement de la collection...</div>}>
            <CollectionContent />
        </Suspense>
    );
}
</file>

<file path="components/MagicCard.tsx">
// components/MagicCard.tsx
'use client';

import { useState, useEffect, memo, useRef } from 'react';
import { useRouter } from 'next/navigation';
import Image from 'next/image';

// Imports des sous-composants
import CardImage from '@/components/magic-card/CardImage';
import CardTags from '@/components/magic-card/CardTags';
import CardQuantity from '@/components/magic-card/CardQuantity';
import CardTradeQuantity from '@/components/magic-card/CardTradeQuantity';
import CardPrice from '@/components/magic-card/CardPrice';

import { useDebouncedUpdate } from '@/hooks/useDebounceUpdate';
import { ScryfallRawData } from '@/lib/cardUtils';

type MatchStatus = 'my_wishlist' | 'my_trade_binder' | 'none';

type MagicCardProps = {
    id?: string;
    name: string;
    imageUrl: string;
    imageBackUrl?: string | null;
    quantity?: number;
    price?: number;
    customPrice?: number; 
    setName?: string;
    isFoil?: boolean;
    isSpecificVersion?: boolean;
    quantityForTrade?: number;
    
    scryfallData?: ScryfallRawData | Record<string, unknown> | null;
    
    onIncrement?: () => void;
    onDecrement?: () => void;
    onQuantityChange?: (newQuantity: number) => void;
    
    onMove?: () => void;
    onEditPrice?: (newPrice: number) => void;
    onToggleAttribute?: (field: 'isFoil' | 'isSpecificVersion', currentValue: boolean) => void;
    onIncrementTrade?: () => void; 
    onDecrementTrade?: () => void;
    
    isWishlist?: boolean;
    readOnly?: boolean;
    isTradeView?: boolean;
    allowPriceEdit?: boolean;
    isSelectMode?: boolean;
    isSelected?: boolean;
    onSelect?: () => void;
    returnTo?: string;
    matchStatus?: MatchStatus;
    hideFooter?: boolean; // AJOUT : pour masquer le bloc infos/actions
};

const CARD_BACK_URL = "https://cards.scryfall.io/large/front/a/6/a6984342-f723-4e80-8e69-902d287a915f.jpg";

function MagicCard(props: MagicCardProps) {
    const router = useRouter();
    const { 
        name, imageUrl, imageBackUrl, quantity = 1, 
        price, customPrice, setName, 
        isFoil, isSpecificVersion, quantityForTrade, scryfallData,
        isTradeView, allowPriceEdit, 
        onEditPrice, onToggleAttribute, 
        readOnly, isWishlist,
        onIncrement, onDecrement, onQuantityChange,
        onMove,
        onIncrementTrade, onDecrementTrade, 
        isSelectMode, isSelected, onSelect,
        returnTo,
        matchStatus,
        hideFooter = false // AJOUT
    } = props;
    
    // --- GESTION DU FLIP ---
    const [isFlipped, setIsFlipped] = useState(false);
    
    // --- GESTION QUANTIT√â OPTIMIS√âE ---
    const [localQty, setLocalQty] = useState(quantity);
    
    // On utilise une Ref pour savoir si la mise √† jour vient de nous (local) ou du parent
    const isLocalUpdate = useRef(false);

    // Synchronisation Parent -> Enfant
    useEffect(() => {
        if (!isLocalUpdate.current) {
            // eslint-disable-next-line react-hooks/set-state-in-effect
            setLocalQty(quantity);
        }
        isLocalUpdate.current = false;
    }, [quantity]);

    // Cr√©ation de la fonction de debounce STABLE
    const debouncedCommit = useDebouncedUpdate((val: number) => {
        if (onQuantityChange) {
            onQuantityChange(val);
        }
    }, 600); 

    const handleOptimisticIncrement = () => {
        const newVal = localQty + 1;
        setLocalQty(newVal); 
        isLocalUpdate.current = true; 
        
        if (onQuantityChange) {
            debouncedCommit(newVal); 
        } else if (onIncrement) {
            onIncrement();
        }
    };

    const handleOptimisticDecrement = () => {
        if (localQty <= 1) {
            if (onDecrement) onDecrement();
            return;
        }
        const newVal = localQty - 1;
        setLocalQty(newVal);
        isLocalUpdate.current = true;

        if (onQuantityChange) {
            debouncedCommit(newVal);
        } else if (onDecrement) {
            onDecrement();
        }
    };

    // --- GESTION PRIX ---
    const [isEditingPrice, setIsEditingPrice] = useState(false);
    
    const displayPriceSource = (() => {
        if ((isTradeView || allowPriceEdit) && customPrice !== undefined) return customPrice;
        if (scryfallData && typeof scryfallData === 'object' && 'prices' in scryfallData) {
            const data = scryfallData as ScryfallRawData;
            const prices = data.prices;
            if (prices) {
                const rawPrice = isFoil ? prices.eur_foil : prices.eur;
                if (rawPrice) return parseFloat(rawPrice);
                if (isFoil && !rawPrice) return 0;
            }
        }
        return price || 0;
    })();

    const [tempPrice, setTempPrice] = useState(displayPriceSource.toString());

    useEffect(() => {
        // eslint-disable-next-line react-hooks/set-state-in-effect
        if (!isEditingPrice) setTempPrice(displayPriceSource.toString());
    }, [displayPriceSource, isEditingPrice]);

    const tradeQty = quantityForTrade ?? 0;
    const hasPrice = displayPriceSource > 0;
    const displayPriceString = hasPrice ? `${displayPriceSource.toFixed(2)} ‚Ç¨` : "N/A";

    const handleSavePrice = () => {
        if (onEditPrice) {
            onEditPrice(parseFloat(tempPrice));
            setIsEditingPrice(false);
        }
    };

    const currentImage = isFlipped && imageBackUrl ? imageBackUrl : imageUrl;

    const handleCardClick = () => {
        // MODIFICATION : Si readOnly est actif, on stoppe tout pour laisser 
        // l'overlay de SearchPage g√©rer le clic (notamment sur mobile)
        if (readOnly && !isSelectMode) return;

        if (isSelectMode && onSelect) {
            onSelect();
            return;
        } 
        if (isTradeView) {
           if (imageBackUrl) setIsFlipped(!isFlipped);
           return;
        }
        if (props.id) {
            const url = returnTo 
                ? `/card/${props.id}?returnTo=${encodeURIComponent(returnTo)}`
                : `/card/${props.id}`;
            router.push(url);
            return;
        }
        if (imageBackUrl) {
            setIsFlipped(!isFlipped);
        }
    };
      
    let matchClasses = 'border-border bg-surface hover:border-primary';
    if (matchStatus === 'my_wishlist' || matchStatus === 'my_trade_binder') {
        matchClasses = 'bg-green-500/10 border-green-500/30 hover:border-green-500'; 
    }

    // --- VUE LISTE (Trade View) ---
    if (isTradeView) {
        return (
          <div className="flex items-center gap-3 bg-surface p-2 rounded-lg border border-border content-visibility-auto transition-colors select-none">
              <div className="font-bold text-lg w-8 text-center">{quantity}x</div>
              <div className="w-10 h-14 bg-secondary rounded overflow-hidden shrink-0 relative group cursor-pointer" onClick={() => setIsFlipped(!isFlipped)}>
                   <Image src={currentImage || CARD_BACK_URL} className="w-full h-full object-cover" alt={name} fill sizes="40px" />
              </div>
              <div className="grow min-w-0">
                  <div className="flex items-center gap-2">
                      <p className="font-semibold text-sm truncate text-foreground" title={name}>{name}</p>
                      {isFoil && <span className="text-[10px] font-bold text-amber-600 bg-amber-50 px-1 rounded">FOIL</span>}
                  </div>
                  <div className="flex items-center gap-2 text-xs text-muted">
                      <p className="truncate">{setName}</p>
                  </div>
              </div>
              <div className="text-right flex flex-col items-end">
                  {isEditingPrice ? (
                      <div className="flex items-center gap-1">
                          <input type="number" value={tempPrice} onChange={(e) => setTempPrice(e.target.value)} className="w-16 p-1 text-xs border rounded bg-background text-foreground" autoFocus />
                          <button onClick={handleSavePrice} className="text-success text-xs font-bold">OK</button>
                      </div>
                  ) : (
                      <div 
                          className={`font-medium text-sm ${customPrice ? 'text-orange-600' : 'text-foreground'} ${allowPriceEdit ? 'cursor-pointer hover:text-primary' : ''}`}
                          onClick={(e) => { 
                              e.stopPropagation();
                              if (allowPriceEdit) { setTempPrice(displayPriceSource.toString()); setIsEditingPrice(true); }
                          }}
                      >
                          {displayPriceString}
                      </div>
                  )}
              </div>
          </div>
        );
    }

    // --- VUE GRILLE (Standard) ---
    return (
      <div 
          onClick={handleCardClick}
          className={`relative group flex flex-col rounded-xl overflow-hidden p-2 gap-1.5 h-full content-visibility-auto select-none
          transition-all duration-200 shadow-sm hover:shadow-md
          ${isSelected ? 'border-primary ring-1 ring-primary bg-primary/5' : matchClasses} 
          ${isSelectMode || (!isTradeView && !readOnly) ? 'cursor-pointer' : ''} 
          `}
      >
        <CardImage 
            imageUrl={imageUrl} 
            imageBackUrl={imageBackUrl} 
            name={name} 
            isFoil={isFoil} 
            isSelectMode={isSelectMode} 
            isSelected={isSelected} 
            isFlipped={isFlipped}
            onFlip={() => setIsFlipped(!isFlipped)}
        />
        
        {/* MODIFICATION : On conditionne tout le bloc texte/actions */}
        {!hideFooter && (
            <div className="flex-1 flex flex-col min-w-0">
                <div className="flex justify-between items-start mb-0.5">
                    <h3 className="font-semibold text-xs leading-tight text-foreground truncate grow" title={name}>{name}</h3>
                </div>
                <p className="text-[10px] text-muted truncate mb-1">{setName}</p>

                <CardTags 
                    isWishlist={isWishlist} 
                    readOnly={readOnly} 
                    isSelectMode={isSelectMode} 
                    isFoil={isFoil} 
                    isSpecificVersion={isSpecificVersion}
                    onToggleAttribute={onToggleAttribute}
                    onMove={onMove}
                />
                
                <div className={`mt-2 border-t border-border pt-1.5 flex justify-between items-center min-h-[26px] ${isSelectMode ? 'pointer-events-none opacity-50' : ''}`}>
                    
                    <div className="flex-1 flex justify-start items-center min-w-0">
                        <CardQuantity 
                            quantity={localQty} 
                            readOnly={readOnly} 
                            onIncrement={handleOptimisticIncrement} 
                            onDecrement={handleOptimisticDecrement} 
                        />
                    </div>

                    <div className="shrink-0 flex justify-center mx-1">
                        {!isWishlist && !readOnly && !isSelectMode && (
                            <CardTradeQuantity 
                                quantity={localQty} 
                                tradeQty={tradeQty} 
                                onIncrementTrade={onIncrementTrade} 
                                onDecrementTrade={onDecrementTrade} 
                            />
                        )}
                    </div>

                    <div className="flex-1 flex justify-end items-center min-w-0">
                        <CardPrice 
                            displayPriceString={displayPriceString} 
                            hasPrice={hasPrice}
                            isFoil={isFoil}
                        />
                    </div>
                </div>
            </div>
        )}
      </div>
    );
}

const arePropsEqual = (prev: MagicCardProps, next: MagicCardProps) => {
    return (
        prev.id === next.id &&
        prev.quantity === next.quantity &&
        prev.quantityForTrade === next.quantityForTrade &&
        prev.price === next.price &&
        prev.customPrice === next.customPrice &&
        prev.isFoil === next.isFoil &&
        prev.isSelected === next.isSelected &&
        prev.isSelectMode === next.isSelectMode &&
        prev.matchStatus === next.matchStatus &&
        prev.imageUrl === next.imageUrl &&
        prev.hideFooter === next.hideFooter // AJOUT√â
    );
};

export default memo(MagicCard, arePropsEqual);
</file>

</files>
