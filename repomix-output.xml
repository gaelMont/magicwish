This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
app/api/search/route.ts
app/collection/page.tsx
app/favicon.ico
app/globals.css
app/layout.tsx
app/login/page.tsx
app/page.tsx
app/wishlist/page.tsx
components/ConfirmModal.tsx
components/DeleteAllButton.tsx
components/Header.tsx
components/ImportModal.tsx
components/MagicCard.tsx
eslint.config.mjs
hooks/useCardCollection.ts
hooks/useWishlists.ts
lib/AuthContext.tsx
lib/cardUtils.ts
lib/firebase.ts
next.config.ts
package.json
postcss.config.mjs
public/file.svg
public/globe.svg
public/next.svg
public/vercel.svg
public/window.svg
README.md
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="hooks/useWishlists.ts">
// hooks/useWishlists.ts
import { useState, useEffect } from 'react';
import { db } from '@/lib/firebase';
import { collection, onSnapshot, addDoc, deleteDoc, doc, serverTimestamp, setDoc } from 'firebase/firestore';
import { useAuth } from '@/lib/AuthContext';
import toast from 'react-hot-toast';

export type WishlistMeta = {
  id: string;
  name: string;
  isDefault?: boolean; // Pour identifier la liste principale historique
};

export function useWishlists() {
  const { user } = useAuth();
  const [lists, setLists] = useState<WishlistMeta[]>([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    if (!user) {
      setLists([]);
      setLoading(false);
      return;
    }

    // On √©coute la collection des m√©tadonn√©es
    const metaRef = collection(db, 'users', user.uid, 'wishlists_meta');
    
    const unsubscribe = onSnapshot(metaRef, (snapshot) => {
      const fetchedLists = snapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data()
      })) as WishlistMeta[];

      // Si aucune liste n'existe (premier lancement V2), on cr√©e la liste "D√©faut"
      // qui pointera conceptuellement vers ton ancienne collection
      if (fetchedLists.length === 0 && !snapshot.metadata.fromCache) {
        createList("Liste principale", "default");
      } else {
        // On trie : D√©faut en premier, puis alphab√©tique
        fetchedLists.sort((a, b) => {
          if (a.id === 'default') return -1;
          if (b.id === 'default') return 1;
          return a.name.localeCompare(b.name);
        });
        setLists(fetchedLists);
      }
      setLoading(false);
    });

    return () => unsubscribe();
  }, [user]);

  const createList = async (name: string, customId?: string) => {
    if (!user) return;
    try {
      const data = { name, createdAt: serverTimestamp() };
      if (customId) {
        await setDoc(doc(db, 'users', user.uid, 'wishlists_meta', customId), { ...data, isDefault: true });
      } else {
        await addDoc(collection(db, 'users', user.uid, 'wishlists_meta'), data);
      }
      toast.success(`Liste "${name}" cr√©√©e`);
    } catch (err) {
      console.error(err);
      toast.error("Erreur cr√©ation liste");
    }
  };

  const deleteList = async (listId: string) => {
    if (!user || listId === 'default') return; // On prot√®ge la liste par d√©faut
    if (!confirm("Supprimer cette liste et toutes ses cartes ?")) return;
    
    try {
        // 1. Supprimer les m√©tadonn√©es
        await deleteDoc(doc(db, 'users', user.uid, 'wishlists_meta', listId));
        
        // 2. Note: Id√©alement, il faudrait aussi supprimer la sous-collection 'cards'.
        // C'est complexe c√¥t√© client. Pour l'instant on supprime juste l'acc√®s (meta).
        // Une Cloud Function serait id√©ale ici pour le nettoyage complet.
        
        toast.success("Liste supprim√©e");
    } catch (err) {
        console.error(err);
        toast.error("Erreur suppression");
    }
  };

  return { lists, loading, createList, deleteList };
}
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
</file>

<file path="app/globals.css">
@import "tailwindcss";

:root {
  --background: #ffffff;
  --foreground: #171717;
}

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

body {
  background: var(--background);
  color: var(--foreground);
  font-family: Arial, Helvetica, sans-serif;
}
</file>

<file path="app/layout.tsx">
// app/layout.tsx
import type { Metadata } from 'next';
import { Inter } from 'next/font/google';
import './globals.css';
import { AuthProvider } from '@/lib/AuthContext';
import Header from '@/components/Header'; 
import { Toaster } from 'react-hot-toast'; // <--- IMPORT ICI

const inter = Inter({ subsets: ['latin'] });

export const metadata: Metadata = {
  title: 'MagicWish',
  description: 'Votre wishlist de cartes Magic',
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="fr">
      <body className={inter.className}>
        <AuthProvider>
          <Header />
          {children}
          <Toaster position="bottom-right" /> {/* <--- AJOUTE √áA ICI */}
        </AuthProvider>
      </body>
    </html>
  );
}
</file>

<file path="app/login/page.tsx">
// Fichier : app/login/page.tsx

'use client'; // Cette page est interactive

import { useRouter } from 'next/navigation'; // Pour rediriger l'utilisateur
import { useAuth } from '@/lib/AuthContext'; // On utilise notre "raccourci" !

export default function LoginPage() {
  // On r√©cup√®re les infos de notre "carte d'identit√©"
  const { user, signInWithGoogle, loading } = useAuth();
  const router = useRouter(); // L'outil de redirection

  // Si le chargement est termin√© ET que l'utilisateur est D√âJ√Ä connect√©...
  if (!loading && user) {
    // ...on le renvoie √† la page d'accueil.
    router.push('/');
    return null; // On n'affiche rien sur cette page
  }

  // Si on charge, on affiche un message simple
  if (loading) {
    return <p>Chargement...</p>;
  }

  // C'est le HTML (JSX) qui s'affiche
  return (
    <main className="flex items-center justify-center min-h-screen">
      <div className="text-center">
        <h1 className="text-3xl font-bold mb-4">Bienvenue sur MagicWish</h1>
        <p className="mb-6">Veuillez vous connecter pour cr√©er votre wishlist.</p>
        
        {/* LE BOUTON DE CONNEXION */}
        <button
          onClick={signInWithGoogle} // Au clic, on appelle la fonction du Contexte
          className="bg-blue-500 text-white p-3 rounded-lg font-semibold"
        >
          Se connecter avec Google
        </button>
      </div>
    </main>
  );
}
</file>

<file path="components/ConfirmModal.tsx">
// components/ConfirmModal.tsx
'use client';

type ConfirmModalProps = {
  isOpen: boolean;
  onClose: () => void;
  onConfirm: () => void;
  title?: string;
  message?: string;
};

export default function ConfirmModal({ 
  isOpen, 
  onClose, 
  onConfirm, 
  title = "Confirmation", 
  message = "√ätes-vous s√ªr de vouloir faire √ßa ?" 
}: ConfirmModalProps) {
  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black/60 flex items-center justify-center z-50 p-4 backdrop-blur-sm">
      <div className="bg-white dark:bg-gray-800 rounded-xl p-6 max-w-sm w-full shadow-2xl border border-gray-100 dark:border-gray-700 animate-in fade-in zoom-in duration-200">
        <h3 className="text-lg font-bold text-gray-900 dark:text-white mb-2">{title}</h3>
        <p className="text-gray-500 dark:text-gray-300 mb-6">{message}</p>
        
        <div className="flex justify-end gap-3">
          <button
            onClick={onClose}
            className="px-4 py-2 text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-lg transition"
          >
            Annuler
          </button>
          <button
            onClick={() => {
              onConfirm();
              onClose();
            }}
            className="px-4 py-2 bg-red-600 hover:bg-red-700 text-white rounded-lg font-medium transition shadow-sm"
          >
            Supprimer
          </button>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="components/DeleteAllButton.tsx">
// components/DeleteAllButton.tsx
'use client';

import { useState } from 'react';
import { useAuth } from '@/lib/AuthContext';
import { db } from '@/lib/firebase';
import { collection, getDocs, writeBatch } from 'firebase/firestore';
import toast from 'react-hot-toast';
import ConfirmModal from './ConfirmModal';

type DeleteAllButtonProps = {
  targetCollection: 'wishlist' | 'collection';
};

export default function DeleteAllButton({ targetCollection }: DeleteAllButtonProps) {
  const { user } = useAuth();
  const [isDeleting, setIsDeleting] = useState(false);
  const [isConfirmOpen, setIsConfirmOpen] = useState(false);

  // Fonction utilitaire pour d√©couper en paquets de 500
  const chunkArray = <T,>(arr: T[], size: number): T[][] => {
    const chunks = [];
    for (let i = 0; i < arr.length; i += size) {
      chunks.push(arr.slice(i, i + size));
    }
    return chunks;
  };

  const handleDeleteAll = async () => {
    if (!user) return;

    setIsDeleting(true);
    const toastId = toast.loading("Suppression en cours...");

    try {
      // 1. On r√©cup√®re TOUTES les cartes
      const colRef = collection(db, 'users', user.uid, targetCollection);
      const snapshot = await getDocs(colRef);

      if (snapshot.empty) {
        toast.success("La liste est d√©j√† vide !", { id: toastId });
        setIsDeleting(false);
        return;
      }

      const docs = snapshot.docs;
      // 2. On d√©coupe en lots de 500 (limite technique Firestore)
      const batches = chunkArray(docs, 500);

      // 3. On supprime lot par lot
      for (const batchDocs of batches) {
        const batch = writeBatch(db);
        batchDocs.forEach((doc) => {
          batch.delete(doc.ref);
        });
        await batch.commit();
      }

      toast.success(`Tout a √©t√© supprim√© (${docs.length} cartes).`, { id: toastId });

    } catch (error) {
      console.error(error);
      toast.error("Erreur lors de la suppression.", { id: toastId });
    } finally {
      setIsDeleting(false);
    }
  };

  return (
    <>
      <button
        onClick={() => setIsConfirmOpen(true)}
        disabled={isDeleting}
        className="text-red-600 hover:text-red-800 hover:bg-red-50 dark:hover:bg-red-900/20 px-3 py-2 rounded-lg text-sm font-medium transition flex items-center gap-2"
        title="Tout effacer"
      >
        {isDeleting ? '...' : 'üóëÔ∏è Vider la liste'}
      </button>

      <ConfirmModal
        isOpen={isConfirmOpen}
        onClose={() => setIsConfirmOpen(false)}
        onConfirm={handleDeleteAll}
        title="‚ö†Ô∏è DANGER : Tout supprimer ?"
        message={`Vous √™tes sur le point de supprimer INT√âGRALEMENT votre ${targetCollection}. Cette action est irr√©versible.`}
      />
    </>
  );
}
</file>

<file path="components/MagicCard.tsx">
// components/MagicCard.tsx
'use client';

import { useState } from 'react';

type MagicCardProps = {
  name: string;
  imageUrl: string;
  imageBackUrl?: string | null; // Optionnel : Le dos de la carte
  quantity?: number;
  price?: number;
  setName?: string;
  
  // Fonctions d'action
  onDelete?: () => void;
  onIncrement?: () => void;
  onDecrement?: () => void;
  onMove?: () => void; // Pour la wishlist
  
  // Style
  isWishlist?: boolean;
};

const CARD_BACK_URL = "https://cards.scryfall.io/large/front/a/6/a6984342-f723-4e80-8e69-902d287a915f.jpg";

export default function MagicCard({
  name,
  imageUrl,
  imageBackUrl,
  quantity = 1,
  price,
  setName,
  onDelete,
  onIncrement,
  onDecrement,
  onMove,
  isWishlist = false
}: MagicCardProps) {
  const [isFlipped, setIsFlipped] = useState(false);

  const handleFlip = (e: React.MouseEvent) => {
    e.stopPropagation(); // Emp√™che de cliquer sur la carte si on clique sur le bouton flip
    setIsFlipped(!isFlipped);
  };

  const currentImage = isFlipped && imageBackUrl ? imageBackUrl : imageUrl;

  return (
    <div className="relative group flex flex-col bg-white dark:bg-gray-800 rounded-lg shadow overflow-hidden p-3 gap-3 border border-gray-100 dark:border-gray-700 hover:border-blue-300 dark:hover:border-blue-500 transition-colors h-full">
      
      {/* --- BOUTONS D'ACTION (Top) --- */}
      <div className="absolute top-2 left-2 right-2 flex justify-between z-20">
        {/* Bouton Wishlist -> Collection */}
        {isWishlist && onMove && (
          <button
            onClick={onMove}
            className="p-1.5 bg-green-100 text-green-700 hover:bg-green-600 hover:text-white rounded-full transition opacity-100 md:opacity-0 md:group-hover:opacity-100 shadow-sm"
            title="D√©placer vers Collection"
          >
            üì¶
          </button>
        )}
        
        {/* Spacer si pas de bouton gauche */}
        {!isWishlist && <div></div>}

        {/* Bouton Supprimer */}
        {onDelete && (
          <button
            onClick={onDelete}
            className="p-1.5 bg-red-50 text-gray-400 hover:text-white hover:bg-red-600 rounded-full transition opacity-100 md:opacity-0 md:group-hover:opacity-100"
            title="Supprimer"
          >
            üóëÔ∏è
          </button>
        )}
      </div>

      {/* --- IMAGE ET BOUTON FLIP --- */}
      <div className="relative w-full aspect-[2.5/3.5] bg-gray-200 rounded-lg overflow-hidden">
        <img
          src={currentImage || CARD_BACK_URL}
          alt={name}
          className="w-full h-full object-cover transition-transform duration-300"
          onError={(e) => { e.currentTarget.src = CARD_BACK_URL; }}
        />

        {/* BOUTON FLIP (Exactement comme Scryfall) */}
        {imageBackUrl && (
          <button
            onClick={handleFlip}
            className="absolute top-1/2 right-2 -translate-y-1/2 bg-black/50 hover:bg-black/80 text-white p-3 rounded-full backdrop-blur-sm transition-all shadow-lg border border-white/20 z-10"
            title="Retourner la carte"
          >
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={2} stroke="currentColor" className="w-8 h-8">
              <path strokeLinecap="round" strokeLinejoin="round" d="M16.023 9.348h4.992v-.001M2.985 19.644v-4.992m0 0h4.992m-4.993 0 3.181 3.183a8.25 8.25 0 0 0 13.803-3.7M4.031 9.865a8.25 8.25 0 0 1 13.803-3.7l3.181 3.182m0-4.991v4.99" />
            </svg>
          </button>
        )}
      </div>
      
      {/* --- INFO CARTE --- */}
      <div className="flex-1 flex flex-col min-w-0">
        <h3 className="font-bold text-sm md:text-base truncate mb-1" title={name}>
            {/* Si c'est retourn√©, on peut afficher le nom du dos si on veut, mais gardons le nom principal pour simplifier */}
            {name}
        </h3>
        
        {setName && <p className="text-xs text-blue-600 dark:text-blue-400 mb-2 truncate font-medium">{setName}</p>}
        
        <div className="mt-auto flex justify-between items-end border-t border-gray-100 dark:border-gray-700 pt-2">
          {/* Compteur */}
          <div className="flex items-center gap-2">
            <button onClick={onDecrement} className="bg-gray-200 dark:bg-gray-700 w-7 h-7 rounded hover:bg-gray-300 font-bold flex items-center justify-center">-</button>
            <span className="font-mono text-lg w-5 text-center">{quantity}</span>
            <button onClick={onIncrement} className="bg-blue-100 dark:bg-blue-900 text-blue-600 font-bold w-7 h-7 rounded hover:bg-blue-200 flex items-center justify-center">+</button>
          </div>
          
          {/* Prix */}
          <div className="text-right">
             <p className="text-[10px] text-gray-400">Unit: {price}‚Ç¨</p>
             <p className="font-bold text-gray-700 dark:text-gray-200">{(price ? price * quantity : 0).toFixed(2)} ‚Ç¨</p>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="eslint.config.mjs">
import { defineConfig, globalIgnores } from "eslint/config";
import nextVitals from "eslint-config-next/core-web-vitals";
import nextTs from "eslint-config-next/typescript";

const eslintConfig = defineConfig([
  ...nextVitals,
  ...nextTs,
  // Override default ignores of eslint-config-next.
  globalIgnores([
    // Default ignores of eslint-config-next:
    ".next/**",
    "out/**",
    "build/**",
    "next-env.d.ts",
  ]),
]);

export default eslintConfig;
</file>

<file path="hooks/useCardCollection.ts">
// hooks/useCardCollection.ts
import { useState, useEffect, useMemo } from 'react';
import { db } from '@/lib/firebase';
import { collection, onSnapshot, doc, updateDoc, deleteDoc, increment } from 'firebase/firestore';
import { useAuth } from '@/lib/AuthContext';
import toast from 'react-hot-toast';

export type CardType = {
  id: string;
  name: string;
  imageUrl: string;
  imageBackUrl?: string;
  quantity: number;
  price?: number;
  setName?: string;
  setCode?: string;
  wishlistId?: string; // Utile pour la vue globale
};

// MODIFICATION: On accepte maintenant un path explicite ou un listId
export function useCardCollection(target: 'collection' | 'wishlist', listId: string = 'default') {
  const { user, loading: authLoading } = useAuth();
  const [cards, setCards] = useState<CardType[]>([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    if (!user || authLoading) {
        if (!authLoading) setLoading(false);
        return;
    }

    setLoading(true);

    // LOGIQUE DE CHEMIN DYNAMIQUE
    let collectionPath = '';
    
    if (target === 'collection') {
        // La collection reste unique (pour l'instant)
        collectionPath = `users/${user.uid}/collection`;
    } else {
        // Gestion des Wishlists
        if (listId === 'default') {
            // R√©tro-compatibilit√© : l'ancienne wishlist
            collectionPath = `users/${user.uid}/wishlist`;
        } else {
            // Nouvelles wishlists
            collectionPath = `users/${user.uid}/wishlists_data/${listId}/cards`;
        }
    }

    const colRef = collection(db, collectionPath);

    const unsubscribe = onSnapshot(colRef, (snapshot) => {
      const items = snapshot.docs.map((doc) => ({
        id: doc.id,
        wishlistId: listId, // On marque l'origine
        ...doc.data(),
      })) as CardType[];
      
      setCards(items);
      setLoading(false);
    }, (error) => {
      console.error("Erreur Firestore:", error);
      setLoading(false);
    });

    return () => unsubscribe();
  }, [user, target, listId, authLoading]);

  // Tri
  const sortedCards = useMemo(() => {
    return [...cards].sort((a, b) => a.name.localeCompare(b.name));
  }, [cards]);

  // Helpers pour retrouver le bon chemin pour les updates
  const getDocRef = (cardId: string) => {
      if (!user) return null;
      let path = '';
      if (target === 'collection') path = `users/${user.uid}/collection`;
      else if (listId === 'default') path = `users/${user.uid}/wishlist`;
      else path = `users/${user.uid}/wishlists_data/${listId}/cards`;
      return doc(db, path, cardId);
  };

  const updateQuantity = async (cardId: string, amount: number, currentQuantity: number) => {
    if (!user) return;
    const ref = getDocRef(cardId);
    if (!ref) return;

    if (currentQuantity + amount <= 0) return 'shouldDelete';

    try {
      await updateDoc(ref, { quantity: increment(amount) });
      return 'updated';
    } catch (err) {
      toast.error("Erreur update");
      return 'error';
    }
  };

  const removeCard = async (cardId: string) => {
    if (!user) return;
    const ref = getDocRef(cardId);
    if(ref) {
        await deleteDoc(ref);
        toast.success('Carte retir√©e', { icon: 'üóëÔ∏è' });
    }
  };

  const totalPrice = useMemo(() => {
    return cards.reduce((acc, card) => acc + (card.price || 0) * card.quantity, 0);
  }, [cards]);

  return { cards: sortedCards, loading, updateQuantity, removeCard, totalPrice };
}
</file>

<file path="lib/cardUtils.ts">
// lib/cardUtils.ts

// Type g√©n√©rique pour une carte Scryfall (simplifi√©)
export type ScryfallRawData = {
  id: string;
  name: string;
  set: string;
  set_name: string;
  prices?: { eur?: string; usd?: string };
  image_uris?: { normal?: string };
  card_faces?: Array<{
    name: string;
    image_uris?: { normal?: string };
  }>;
};

// Fonction pour transformer la donn√©e brute en donn√©e propre pour notre app
export const normalizeCardData = (data: ScryfallRawData) => {
  // Gestion des cartes recto-verso
  const isDoubleFaced = data.card_faces && data.card_faces.length > 1;

  // 1. Nom : On prend le nom de la face avant si double face, sinon nom normal
  // On nettoie le " // " si Scryfall le laisse tra√Æner
  const rawName = isDoubleFaced ? data.card_faces![0].name : data.name;
  const name = rawName.split(' // ')[0];

  // 2. Images
  let imageUrl = data.image_uris?.normal;
  let imageBackUrl = undefined; // ou null selon ta pr√©f√©rence

  if (isDoubleFaced) {
    imageUrl = data.card_faces![0].image_uris?.normal;
    imageBackUrl = data.card_faces![1].image_uris?.normal;
  }

  // Fallback si pas d'image (dos de carte)
  if (!imageUrl) {
    imageUrl = "https://cards.scryfall.io/large/front/a/6/a6984342-f723-4e80-8e69-902d287a915f.jpg";
  }

  return {
    id: data.id,
    scryfallId: data.id,
    name,
    imageUrl,
    imageBackUrl,
    setName: data.set_name,
    setCode: data.set,
    price: parseFloat(data.prices?.eur || "0"),
  };
};
</file>

<file path="postcss.config.mjs">
const config = {
  plugins: {
    "@tailwindcss/postcss": {},
  },
};

export default config;
</file>

<file path="public/file.svg">
<svg fill="none" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.5 13.5V5.41a1 1 0 0 0-.3-.7L9.8.29A1 1 0 0 0 9.08 0H1.5v13.5A2.5 2.5 0 0 0 4 16h8a2.5 2.5 0 0 0 2.5-2.5m-1.5 0v-7H8v-5H3v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1M9.5 5V2.12L12.38 5zM5.13 5h-.62v1.25h2.12V5zm-.62 3h7.12v1.25H4.5zm.62 3h-.62v1.25h7.12V11z" clip-rule="evenodd" fill="#666" fill-rule="evenodd"/></svg>
</file>

<file path="public/globe.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g clip-path="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.27 14.1a6.5 6.5 0 0 0 3.67-3.45q-1.24.21-2.7.34-.31 1.83-.97 3.1M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m.48-1.52a7 7 0 0 1-.96 0H7.5a4 4 0 0 1-.84-1.32q-.38-.89-.63-2.08a40 40 0 0 0 3.92 0q-.25 1.2-.63 2.08a4 4 0 0 1-.84 1.31zm2.94-4.76q1.66-.15 2.95-.43a7 7 0 0 0 0-2.58q-1.3-.27-2.95-.43a18 18 0 0 1 0 3.44m-1.27-3.54a17 17 0 0 1 0 3.64 39 39 0 0 1-4.3 0 17 17 0 0 1 0-3.64 39 39 0 0 1 4.3 0m1.1-1.17q1.45.13 2.69.34a6.5 6.5 0 0 0-3.67-3.44q.65 1.26.98 3.1M8.48 1.5l.01.02q.41.37.84 1.31.38.89.63 2.08a40 40 0 0 0-3.92 0q.25-1.2.63-2.08a4 4 0 0 1 .85-1.32 7 7 0 0 1 .96 0m-2.75.4a6.5 6.5 0 0 0-3.67 3.44 29 29 0 0 1 2.7-.34q.31-1.83.97-3.1M4.58 6.28q-1.66.16-2.95.43a7 7 0 0 0 0 2.58q1.3.27 2.95.43a18 18 0 0 1 0-3.44m.17 4.71q-1.45-.12-2.69-.34a6.5 6.5 0 0 0 3.67 3.44q-.65-1.27-.98-3.1" fill="#666"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h16v16H0z"/></clipPath></defs></svg>
</file>

<file path="public/next.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>
</file>

<file path="public/vercel.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1155 1000"><path d="m577.3 0 577.4 1000H0z" fill="#fff"/></svg>
</file>

<file path="public/window.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2.5h13v10a1 1 0 0 1-1 1h-11a1 1 0 0 1-1-1zM0 1h16v11.5a2.5 2.5 0 0 1-2.5 2.5h-11A2.5 2.5 0 0 1 0 12.5zm3.75 4.5a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5M7 4.75a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0m1.75.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5" fill="#666"/></svg>
</file>

<file path="README.md">
This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "react-jsx",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts",
    ".next/dev/types/**/*.ts",
    "**/*.mts"
  ],
  "exclude": ["node_modules"]
}
</file>

<file path="lib/AuthContext.tsx">
'use client';

import { createContext, useContext, useEffect, useState, useMemo } from 'react';
import { 
  onAuthStateChanged, 
  signInWithPopup, 
  GoogleAuthProvider, 
  signOut, 
  User 
} from 'firebase/auth';
import { auth } from './firebase';
import toast from 'react-hot-toast';

type AuthContextType = {
  user: User | null;
  loading: boolean;
  signInWithGoogle: () => Promise<void>;
  logOut: () => Promise<void>;
};

const AuthContext = createContext<AuthContextType>({
  user: null,
  loading: true,
  signInWithGoogle: async () => {},
  logOut: async () => {},
});

export const useAuth = () => useContext(AuthContext);

export const AuthProvider = ({ children }: { children: React.ReactNode }) => {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const unsubscribe = onAuthStateChanged(auth, (currentUser) => {
      setUser(currentUser);
      setLoading(false);
    });
    return () => unsubscribe();
  }, []);

  const signInWithGoogle = async () => {
    try {
      const provider = new GoogleAuthProvider();
      await signInWithPopup(auth, provider);
      toast.success('Connexion r√©ussie !');
    } catch (error) {
      console.error(error);
      toast.error("Erreur lors de la connexion Google");
    }
  };

  const logOut = async () => {
    try {
      await signOut(auth);
      toast.success('D√©connect√©');
    } catch (error) {
      console.error(error);
      toast.error("Erreur d√©connexion");
    }
  };

  // Optimisation : on ne recr√©e l'objet value que si user ou loading change
  const value = useMemo(() => ({
    user,
    loading,
    signInWithGoogle,
    logOut
  }), [user, loading]);

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
};
</file>

<file path="lib/firebase.ts">
import { initializeApp, getApps, getApp } from 'firebase/app';
import { getAuth } from 'firebase/auth';
import { getFirestore } from 'firebase/firestore';

const firebaseConfig = {
  apiKey: process.env.NEXT_PUBLIC_FIREBASE_API_KEY,
  authDomain: process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN,
  projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID,
  storageBucket: process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET,
  messagingSenderId: process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID,
  appId: process.env.NEXT_PUBLIC_FIREBASE_APP_ID,
};

// Initialisation unique (√©vite les erreurs de re-init en dev)
const app = !getApps().length ? initializeApp(firebaseConfig) : getApp();

export const auth = getAuth(app);
export const db = getFirestore(app);
</file>

<file path="next.config.ts">
import type { NextConfig } from 'next';

const nextConfig: NextConfig = {
  // Mode strict pour d√©tecter les bugs en dev
  reactStrictMode: true,

  // Optimisation des images
  images: {
    formats: ['image/avif', 'image/webp'],
    remotePatterns: [
      {
        protocol: 'https',
        hostname: 'cards.scryfall.io', // Indispensable pour tes cartes
        port: '',
        pathname: '/**',
      },
      {
        protocol: 'https',
        hostname: '*.googleusercontent.com', // Indispensable pour les avatars Google Auth
        port: '',
        pathname: '/**',
      },
    ],
  },

  // S√©curit√© (Headers HTTP)
  async headers() {
    return [
      {
        source: '/(.*)',
        headers: [
          { key: 'X-Content-Type-Options', value: 'nosniff' },
          { key: 'X-Frame-Options', value: 'DENY' },
          { key: 'Referrer-Policy', value: 'strict-origin-when-cross-origin' },
        ],
      },
    ];
  },
};

export default nextConfig;
</file>

<file path="package.json">
{
  "name": "magicwish",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "eslint"
  },
  "dependencies": {
    "@types/papaparse": "^5.5.1",
    "firebase": "^12.5.0",
    "next": "^16.0.8",
    "papaparse": "^5.5.3",
    "react": "^19.2.1",
    "react-dom": "^19.2.1",
    "react-hot-toast": "^2.6.0"
  },
  "devDependencies": {
    "@tailwindcss/postcss": "^4",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "babel-plugin-react-compiler": "1.0.0",
    "eslint": "^9",
    "eslint-config-next": "16.0.3",
    "tailwindcss": "^4",
    "typescript": "^5"
  }
}
</file>

<file path="app/api/search/route.ts">
// app/api/search/route.ts
import { NextResponse } from 'next/server';

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const query = searchParams.get('q'); 

  if (!query) {
    return NextResponse.json(
      { error: 'Aucun terme de recherche fourni.' }, 
      { status: 400 } 
    );
  }

  // --- MODIFICATION ICI : Ajout des guillemets "${query}" ---
  // Cela force la recherche exacte de l'expression
  const scryfallUrl = `https://api.scryfall.com/cards/search?q="${query}"&unique=prints`;

  try {
    const scryfallResponse = await fetch(scryfallUrl);

    if (!scryfallResponse.ok) {
      const errorData = await scryfallResponse.json();
      console.error('Erreur Scryfall:', errorData);
      return NextResponse.json(
        { error: errorData.details || 'Carte non trouv√©e' }, 
        { status: scryfallResponse.status }
      );
    }

    const data = await scryfallResponse.json();
    return NextResponse.json(data);

  } catch (error) {
    console.error('Erreur interne du serveur:', error);
    return NextResponse.json(
      { error: 'Une erreur est survenue sur le serveur.' }, 
      { status: 500 }
    );
  }
}
</file>

<file path="components/Header.tsx">
// components/Header.tsx
'use client';

import { useState } from 'react';
import Link from 'next/link';
import { useAuth } from '@/lib/AuthContext';
import { usePathname } from 'next/navigation';

export default function Header() {
  const { user, logOut } = useAuth();
  const pathname = usePathname();
  const [isMenuOpen, setIsMenuOpen] = useState(false);

  // Petite fonction pour styliser le lien actif
  const linkClass = (path: string) => `
    font-medium transition-colors block py-2 md:py-0
    ${pathname === path 
      ? 'text-blue-600 dark:text-blue-400 font-bold' 
      : 'text-gray-700 dark:text-gray-200 hover:text-blue-600 dark:hover:text-blue-400'}
  `;

  return (
    <header className="bg-white dark:bg-gray-900 border-b border-gray-200 dark:border-gray-700 p-4 shadow-sm sticky top-0 z-40">
      <div className="container mx-auto">
        <div className="flex justify-between items-center">
          {/* LOGO */}
          <Link 
            href="/" 
            className="text-xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-blue-600 to-purple-600 hover:opacity-80 transition"
            onClick={() => setIsMenuOpen(false)}
          >
            ‚ú® MagicWish
          </Link>

          <div className="flex items-center gap-4">
            {user ? (
              <>
                {/* NAVIGATION DESKTOP (Cach√©e sur mobile) */}
                <nav className="hidden md:flex gap-6 mr-4">
                  <Link href="/" className={linkClass('/')}>Recherche</Link>
                  <Link href="/wishlist" className={linkClass('/wishlist')}>Ma Wishlist</Link>
                  <Link href="/collection" className={linkClass('/collection')}>Ma Collection</Link>
                </nav>

                <div className="h-6 w-px bg-gray-300 dark:bg-gray-600 hidden md:block"></div>

                {/* AVATAR + LOGOUT (Toujours visible si connect√©) */}
                <div className="flex items-center gap-3">
                  {user.photoURL && (
                    <img 
                      src={user.photoURL} 
                      alt="Avatar" 
                      className="w-8 h-8 rounded-full border border-gray-300"
                      title={user.displayName || ''}
                    />
                  )}
                  <button
                    onClick={logOut}
                    className="hidden md:block text-sm text-red-600 hover:bg-red-50 dark:hover:bg-red-900/20 px-3 py-1 rounded transition"
                  >
                    D√©connexion
                  </button>

                  {/* BOUTON BURGER MOBILE */}
                  <button 
                    onClick={() => setIsMenuOpen(!isMenuOpen)}
                    className="md:hidden p-2 text-gray-600 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-800 rounded-lg focus:outline-none"
                    aria-label="Menu"
                  >
                    {isMenuOpen ? (
                      // Ic√¥ne Croix (Fermer)
                      <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-6 h-6">
                        <path strokeLinecap="round" strokeLinejoin="round" d="M6 18L18 6M6 6l12 12" />
                      </svg>
                    ) : (
                      // Ic√¥ne Burger (Ouvrir)
                      <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-6 h-6">
                        <path strokeLinecap="round" strokeLinejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5" />
                      </svg>
                    )}
                  </button>
                </div>
              </>
            ) : (
              <Link
                href="/login"
                className="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 transition"
              >
                Se connecter
              </Link>
            )}
          </div>
        </div>
        
        {/* MENU MOBILE (Visible uniquement si ouvert + petit √©cran) */}
        {user && isMenuOpen && (
          <div className="md:hidden mt-4 pt-4 border-t border-gray-100 dark:border-gray-800 animate-in slide-in-from-top-2 duration-200">
             <nav className="flex flex-col space-y-2">
               <Link href="/" className={linkClass('/')} onClick={() => setIsMenuOpen(false)}>
                 üîç Recherche
               </Link>
               <Link href="/wishlist" className={linkClass('/wishlist')} onClick={() => setIsMenuOpen(false)}>
                 ‚ú® Ma Wishlist
               </Link>
               <Link href="/collection" className={linkClass('/collection')} onClick={() => setIsMenuOpen(false)}>
                 üìö Ma Collection
               </Link>
               <button 
                 onClick={() => { logOut(); setIsMenuOpen(false); }}
                 className="text-left py-2 text-red-600 font-medium hover:bg-red-50 dark:hover:bg-red-900/10 rounded"
               >
                 üö™ D√©connexion
               </button>
             </nav>
          </div>
        )}
      </div>
    </header>
  );
}
</file>

<file path="app/collection/page.tsx">
// app/collection/page.tsx
'use client';

import { useState } from 'react';
import { useAuth } from '@/lib/AuthContext';
import { useCardCollection } from '@/hooks/useCardCollection'; // <--- IMPORT DU HOOK
import MagicCard from '@/components/MagicCard';
import ImportModal from '@/components/ImportModal';
import ConfirmModal from '@/components/ConfirmModal';
import DeleteAllButton from '@/components/DeleteAllButton';

export default function CollectionPage() {
  const { user } = useAuth();
  
  // TOUTE LA LOGIQUE EST ICI :
  const { cards, loading, updateQuantity, removeCard, totalPrice } = useCardCollection('collection');

  const [isImportOpen, setIsImportOpen] = useState(false);
  const [cardToDelete, setCardToDelete] = useState<string | null>(null);

  // Gestion du clic sur "-"
  const handleDecrement = async (cardId: string, currentQty: number) => {
    const result = await updateQuantity(cardId, -1, currentQty);
    if (result === 'shouldDelete') {
      setCardToDelete(cardId);
    }
  };

  if (loading) return <p className="text-center p-10 text-gray-500">Chargement de votre collection...</p>;
  if (!user) return <p className="text-center p-10">Veuillez vous connecter.</p>;

  return (
    <main className="container mx-auto p-4 pb-20">
      {/* HEADER */}
      <div className="flex flex-col md:flex-row justify-between items-center mb-8 gap-4">
        <div className="flex items-center gap-4">
          <h1 className="text-3xl font-bold text-blue-700 dark:text-blue-400">
            Ma Collection <span className="ml-3 text-lg font-normal text-gray-500">({cards.reduce((acc, c) => acc + c.quantity, 0)})</span>
          </h1>
          <button 
            onClick={() => setIsImportOpen(true)} 
            className="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg text-sm font-medium transition flex items-center gap-2 shadow-sm"
          >
            üìÇ Importer CSV
          </button>
        </div>
        
        <div className="flex items-center gap-4">
           <DeleteAllButton targetCollection="collection" />
           <div className="bg-blue-50 dark:bg-blue-900/30 text-blue-800 dark:text-blue-100 px-6 py-3 rounded-xl shadow-sm border border-blue-200 dark:border-blue-700">
             <span className="text-sm uppercase tracking-wide opacity-80">Valeur</span>
             <div className="text-2xl font-bold">{totalPrice.toFixed(2)} ‚Ç¨</div>
           </div>
        </div>
      </div>

      {/* LISTE DES CARTES */}
      {cards.length === 0 ? (
        <div className="text-center py-20 bg-gray-50 dark:bg-gray-800/50 rounded-xl border-2 border-dashed border-gray-200 dark:border-gray-700">
          <p className="text-xl text-gray-500 mb-4">Votre collection est vide.</p>
        </div>
      ) : (
        <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
          {cards.map((card) => (
            <MagicCard 
              key={card.id}
              {...card}
              onIncrement={() => updateQuantity(card.id, 1, card.quantity)}
              onDecrement={() => handleDecrement(card.id, card.quantity)}
              onDelete={() => setCardToDelete(card.id)}
            />
          ))}
        </div>
      )}

      {/* MODALES */}
      <ImportModal isOpen={isImportOpen} onClose={() => setIsImportOpen(false)} targetCollection="collection" />
      
      <ConfirmModal 
        isOpen={!!cardToDelete} 
        onClose={() => setCardToDelete(null)} 
        onConfirm={() => { if(cardToDelete) removeCard(cardToDelete); }} 
        title="Retirer ?" 
        message="Cette carte sera retir√©e de votre collection."
      />
    </main>
  );
}
</file>

<file path="app/page.tsx">
// app/page.tsx
'use client'; 

import { useState } from 'react';
import { useAuth } from '@/lib/AuthContext';
import { db } from '@/lib/firebase';
import { doc, setDoc, updateDoc, getDoc, increment } from 'firebase/firestore'; 
import { useWishlists } from '@/hooks/useWishlists'; // <--- NOUVEL IMPORT
import toast from 'react-hot-toast';

// --- TYPES ---
type ScryfallCard = {
  id: string;
  oracle_id: string;
  name: string;
  set_name: string;
  set: string;
  released_at: string;
  image_uris?: {
    small: string;
    normal: string;
  };
  card_faces?: {
    image_uris?: {
      small: string;
      normal: string;
    };
  }[];
  prices?: {
    eur?: string;
  };
};

const CARD_BACK_URL = "https://cards.scryfall.io/large/front/a/6/a6984342-f723-4e80-8e69-902d287a915f.jpg";

// --- FONCTION UTILITAIRE IMAGE ---
const getCardImage = (card: ScryfallCard): string => {
  if (card.image_uris?.normal) return card.image_uris.normal;
  if (card.card_faces && card.card_faces[0]?.image_uris?.normal) {
    return card.card_faces[0].image_uris.normal;
  }
  return CARD_BACK_URL;
};

// --- SOUS-COMPOSANT : G√®re l'affichage d'une carte ---
// PROPS AJOUT√âE : targetListId
const CardGroup = ({ 
  name, 
  versions, 
  targetListId 
}: { 
  name: string, 
  versions: ScryfallCard[], 
  targetListId: string 
}) => {
  const { user } = useAuth();
  
  // Par d√©faut, on prend la premi√®re version
  const [selectedCard, setSelectedCard] = useState<ScryfallCard>(versions[0]);

  const handleVersionChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    const newVersion = versions.find(v => v.id === e.target.value);
    if (newVersion) setSelectedCard(newVersion);
  };

  const addToWishlist = async () => {
    if (!user) {
      toast.error("Connectez-vous pour ajouter des cartes !");
      return;
    }

    const card = selectedCard; 
    
    // --- LOGIQUE DE CHEMIN DYNAMIQUE ---
    let collectionPath = '';
    if (targetListId === 'default') {
        collectionPath = `users/${user.uid}/wishlist`;
    } else {
        collectionPath = `users/${user.uid}/wishlists_data/${targetListId}/cards`;
    }
    
    const wishlistRef = doc(db, collectionPath, card.id);
    // ------------------------------------

    const validImageUrl = getCardImage(card);
    const priceNumber = card.prices?.eur ? parseFloat(card.prices.eur) : 0;
    const cleanName = card.name.split(' // ')[0];

    try {
      const docSnap = await getDoc(wishlistRef);
      if (docSnap.exists()) {
        await updateDoc(wishlistRef, { 
          quantity: increment(1),
          price: priceNumber // Mise √† jour du prix au cas o√π il a chang√©
        });
        toast.success(`+1 exemplaire (${card.set_name})`);
      } else {
        await setDoc(wishlistRef, {
          name: cleanName,
          imageUrl: validImageUrl,
          quantity: 1,
          price: priceNumber,
          setName: card.set_name,
          setCode: card.set,
          addedAt: new Date()
        });
        toast.success(`Ajout√©e : ${card.set_name}`);
      }
    } catch (error) {
      console.error(error);
      toast.error("Erreur lors de l'ajout.");
    }
  };

  return (
    <div className="relative group flex flex-col h-full bg-white dark:bg-gray-800 rounded-xl shadow-md border border-gray-100 dark:border-gray-700 overflow-hidden">
      {/* Image */}
      <div className="relative w-full min-h-[250px] bg-gray-200 dark:bg-gray-900 flex items-center justify-center p-2">
        <img
          src={getCardImage(selectedCard)}
          alt={name}
          className="w-full h-full object-contain max-h-[350px]"
        />
      </div>

      <div className="p-3 flex flex-col flex-grow gap-2">
        <h3 className="font-bold text-center truncate" title={name}>{name}</h3>

        {/* --- S√âLECTEUR D'√âDITION --- */}
        <select 
          value={selectedCard.id}
          onChange={handleVersionChange}
          className="w-full p-2 text-xs border rounded bg-gray-50 dark:bg-gray-700 dark:border-gray-600 text-gray-900 dark:text-white outline-none cursor-pointer"
        >
          {versions.map((v) => (
            <option key={v.id} value={v.id}>
              {v.set_name} ({v.set.toUpperCase()}) - {v.prices?.eur ? `${v.prices.eur}‚Ç¨` : "N/A"}
            </option>
          ))}
        </select>

        {/* PRIX et BOUTON */}
        <div className="flex justify-between items-center mt-auto pt-2 border-t border-gray-100 dark:border-gray-700">
          <span className="font-bold text-blue-600 dark:text-blue-400">
             {selectedCard.prices?.eur ? `${selectedCard.prices.eur} ‚Ç¨` : "Prix N/A"}
          </span>

          {user && (
            <button
              onClick={addToWishlist}
              className="bg-blue-600 hover:bg-blue-700 text-white px-4 py-1.5 rounded-full text-sm font-medium transition shadow-sm"
            >
              Ajouter +
            </button>
          )}
        </div>
      </div>
    </div>
  );
};


// --- COMPOSANT PRINCIPAL ---
export default function HomePage() {
  const { user } = useAuth();
  
  // --- NOUVEAU HOOK POUR LES LISTES ---
  const { lists, loading: listsLoading } = useWishlists();
  const [selectedTargetList, setSelectedTargetList] = useState<string>('default');

  const [query, setQuery] = useState('');
  const [groupedResults, setGroupedResults] = useState<{ name: string, versions: ScryfallCard[] }[]>([]);
  const [isSearching, setIsSearching] = useState(false);

  const handleSearch = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!query.trim()) return;

    setIsSearching(true);
    setGroupedResults([]); 

    try {
      const response = await fetch(`/api/search?q=${query}`);
      if (!response.ok) throw new Error('Erreur');
      const data = await response.json();
      const rawCards: ScryfallCard[] = data.data || [];

      // Groupement
      const groups = new Map<string, ScryfallCard[]>();
      rawCards.forEach(card => {
        const cleanName = card.name.split(' // ')[0];
        if (!groups.has(cleanName)) groups.set(cleanName, []);
        groups.get(cleanName)?.push(card);
      });

      const resultsArray = Array.from(groups.entries()).map(([cleanName, versions]) => ({
        name: cleanName, 
        versions: versions
      }));

      setGroupedResults(resultsArray);

    } catch (err) {
      toast.error("Aucune carte trouv√©e.");
    } finally {
      setIsSearching(false);
    }
  };

  return (
    <main className="container mx-auto p-4 max-w-7xl">
      <h1 className="text-3xl font-bold mb-8 text-center mt-8 text-transparent bg-clip-text bg-gradient-to-r from-blue-600 to-purple-600">
        MagicWish ‚ú®
      </h1>

      <div className="max-w-xl mx-auto mb-10 space-y-3">
        {/* FORMULAIRE DE RECHERCHE */}
        <form onSubmit={handleSearch} className="flex gap-2">
            <input
            type="text"
            value={query}
            onChange={(e) => setQuery(e.target.value)}
            placeholder="Rechercher (ex: Black Lotus)..."
            className="flex-grow p-3 border rounded-lg shadow-sm outline-none transition-colors
                bg-white text-gray-900 border-gray-300 placeholder-gray-500
                dark:bg-gray-800 dark:text-white dark:border-gray-600 dark:placeholder-gray-400 focus:border-blue-500"
            />
            <button 
            type="submit" 
            disabled={isSearching}
            className="bg-blue-600 hover:bg-blue-700 text-white px-6 rounded-lg font-semibold disabled:opacity-50 transition shadow-sm"
            >
            {isSearching ? '...' : 'üîç'}
            </button>
        </form>

        {/* S√âLECTEUR DE LISTE CIBLE (Visible seulement si connect√©) */}
        {user && (
            <div className="flex justify-end items-center gap-2 animate-in fade-in slide-in-from-top-1">
                <label htmlFor="targetList" className="text-sm text-gray-500 dark:text-gray-400">
                    Ajouter dans :
                </label>
                <div className="relative">
                    <select
                        id="targetList"
                        value={selectedTargetList}
                        onChange={(e) => setSelectedTargetList(e.target.value)}
                        disabled={listsLoading}
                        className="appearance-none bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-700 text-gray-700 dark:text-gray-200 py-1.5 pl-3 pr-8 rounded-lg text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 cursor-pointer shadow-sm"
                    >
                        {/* Si chargement ou vide, option par d√©faut */}
                        {lists.length === 0 ? (
                            <option value="default">Liste principale</option>
                        ) : (
                            lists.map((list) => (
                                <option key={list.id} value={list.id}>
                                    {list.name}
                                </option>
                            ))
                        )}
                    </select>
                    {/* Petite fl√®che custom pour le style */}
                    <div className="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-500">
                        <svg className="fill-current h-4 w-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"/></svg>
                    </div>
                </div>
            </div>
        )}
      </div>

      {/* GRILLE D'AFFICHAGE */}
      <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6">
        {groupedResults.map((group) => (
          <CardGroup 
            key={group.name} 
            name={group.name} 
            versions={group.versions} 
            targetListId={selectedTargetList} // <--- ON PASSE L'ID DE LA LISTE CHOISIE
          />
        ))}
      </div>
    </main>
  );
}
</file>

<file path="app/wishlist/page.tsx">
// app/wishlist/page.tsx
'use client';

import { useState, useMemo } from 'react';
import { useAuth } from '@/lib/AuthContext';
import { useWishlists } from '@/hooks/useWishlists';
import { useCardCollection, CardType } from '@/hooks/useCardCollection';
import MagicCard from '@/components/MagicCard';
import { db } from '@/lib/firebase';
import { doc, runTransaction, increment } from 'firebase/firestore';
import toast from 'react-hot-toast';

// --- COMPOSANT INTERNE POUR AFFICHER UNE LISTE ---
const SingleWishlistView = ({ listId, listName }: { listId: string, listName: string }) => {
    const { cards, loading, updateQuantity, removeCard, totalPrice } = useCardCollection('wishlist', listId);
    const { user } = useAuth();
    
    // Logique de d√©placement vers Collection (inchang√©e mais adapt√©e au path)
    const moveToCollection = async (card: CardType) => {
        if (!user) return;
        const toastId = toast.loading("D√©placement...");
        try {
            // D√©termine le bon path source
            const sourcePath = listId === 'default' ? 'wishlist' : `wishlists_data/${listId}/cards`;
            const wishlistRef = doc(db, 'users', user.uid, sourcePath, card.id);
            const collectionRef = doc(db, 'users', user.uid, 'collection', card.id);

            await runTransaction(db, async (transaction) => {
                const colDoc = await transaction.get(collectionRef);
                if (colDoc.exists()) transaction.update(collectionRef, { quantity: increment(card.quantity) });
                else transaction.set(collectionRef, {
                    ...card,
                    wishlistId: null, // Nettoyage
                    addedAt: new Date()
                });
                transaction.delete(wishlistRef);
            });
            toast.success("Ajout√©e √† la collection !", { id: toastId });
        } catch (error) {
            console.error(error);
            toast.error("Erreur", { id: toastId });
        }
    };

    if (loading) return <div className="p-10 text-center">Chargement...</div>;

    return (
        <div className="animate-in fade-in duration-300">
            <div className="flex justify-between items-end mb-4 border-b pb-2 dark:border-gray-700">
                <h2 className="text-2xl font-bold">{listName}</h2>
                <div className="text-right">
                    <span className="text-sm text-gray-500">Total estim√©</span>
                    <p className="text-xl font-bold text-green-600">{totalPrice.toFixed(2)} ‚Ç¨</p>
                </div>
            </div>
            {cards.length === 0 ? (
                <p className="text-gray-500 italic">Cette liste est vide.</p>
            ) : (
                <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
                    {cards.map(card => (
                        <MagicCard 
                            key={card.id} 
                            {...card} 
                            isWishlist={true}
                            onIncrement={() => updateQuantity(card.id, 1, card.quantity)}
                            onDecrement={() => {
                                if(card.quantity === 1) {
                                    if(confirm("Supprimer ?")) removeCard(card.id);
                                } else {
                                    updateQuantity(card.id, -1, card.quantity);
                                }
                            }}
                            onDelete={() => { if(confirm("Supprimer ?")) removeCard(card.id); }}
                            onMove={() => moveToCollection(card)}
                        />
                    ))}
                </div>
            )}
        </div>
    );
};

export default function WishlistPage() {
  const { user } = useAuth();
  const { lists, createList, deleteList } = useWishlists();
  
  const [selectedListId, setSelectedListId] = useState<string>('default');
  const [newListName, setNewListName] = useState('');

  if (!user) return <p className="p-10 text-center">Connectez-vous.</p>;

  // Gestion de la cr√©ation
  const handleCreate = (e: React.FormEvent) => {
    e.preventDefault();
    if(newListName.trim()) {
        createList(newListName);
        setNewListName('');
    }
  };

  return (
    <main className="container mx-auto p-4 flex flex-col md:flex-row gap-6 min-h-[80vh]">
      
      {/* SIDEBAR NAVIGATION */}
      <aside className="w-full md:w-64 flex-none space-y-6">
        <div className="bg-white dark:bg-gray-800 p-4 rounded-xl shadow-sm border border-gray-100 dark:border-gray-700">
            <h3 className="font-bold mb-4 text-gray-900 dark:text-white flex items-center gap-2">
                üìë Mes Listes
            </h3>
            
            <div className="flex flex-col gap-1">
                {/* Bouton "Vue Globale" (Optionnel - voir note plus bas) */}
                {/* Pour l'instant on liste les listes individuelles */}
                
                {lists.map(list => (
                    <div key={list.id} className="group flex items-center">
                        <button
                            onClick={() => setSelectedListId(list.id)}
                            className={`flex-grow text-left px-3 py-2 rounded-lg text-sm transition-colors ${
                                selectedListId === list.id 
                                ? 'bg-blue-100 text-blue-700 font-bold dark:bg-blue-900/40 dark:text-blue-300' 
                                : 'hover:bg-gray-50 dark:hover:bg-gray-700 text-gray-600 dark:text-gray-300'
                            }`}
                        >
                            {list.name}
                        </button>
                        {list.id !== 'default' && (
                            <button 
                                onClick={() => deleteList(list.id)}
                                className="opacity-0 group-hover:opacity-100 p-2 text-red-400 hover:text-red-600 transition"
                                title="Supprimer la liste"
                            >
                                ‚úï
                            </button>
                        )}
                    </div>
                ))}
            </div>

            {/* Cr√©ation nouvelle liste */}
            <form onSubmit={handleCreate} className="mt-4 pt-4 border-t border-gray-100 dark:border-gray-700">
                <input 
                    type="text" 
                    placeholder="+ Nouvelle liste..." 
                    className="w-full text-sm p-2 border rounded mb-2 bg-transparent dark:border-gray-600"
                    value={newListName}
                    onChange={e => setNewListName(e.target.value)}
                />
            </form>
        </div>
      </aside>

      {/* CONTENU PRINCIPAL */}
      <section className="flex-grow">
          <SingleWishlistView 
            key={selectedListId} // Force le remount quand on change de liste
            listId={selectedListId} 
            listName={lists.find(l => l.id === selectedListId)?.name || 'Liste'} 
          />
      </section>

    </main>
  );
}
</file>

<file path="components/ImportModal.tsx">
// components/ImportModal.tsx
'use client';

import React, { useState, useMemo, useEffect } from 'react';
import Papa from 'papaparse';
import { useAuth } from '@/lib/AuthContext';
import { db } from '@/lib/firebase';
import { doc, writeBatch, increment } from 'firebase/firestore';
import toast from 'react-hot-toast';

// --- TYPES ---
type ManaboxRow = {
  "Binder Name": string;
  "Name": string;
  "Set code": string;
  "Set name": string;
  "Collector number": string;
  "Foil": string;
  "Rarity": string;
  "Quantity": string;
  "ManaBox ID": string;
  "Scryfall ID": string; 
  "Purchase price": string;
  "Language": string;
  "Condition": string;
};

type ScryfallCard = {
  id: string;
  name: string;
  set: string;
  collector_number: string;
  set_name: string;
  prices?: { eur?: string; usd?: string };
  image_uris?: { normal?: string };
  card_faces?: Array<{ 
    name: string;
    image_uris?: { normal?: string } 
  }>;
};

type ExistingCard = {
  scryfallId?: string; 
  id: string;
  quantity: number;
  foil?: boolean;
};

type ImportModalProps = {
  isOpen: boolean;
  onClose: () => void;
  targetCollection?: string;
  currentCollection?: ExistingCard[];
};

export default function ImportModal({ isOpen, onClose, targetCollection = 'collection', currentCollection = [] }: ImportModalProps) {
  const { user } = useAuth();
  
  const [inputType, setInputType] = useState<'file' | 'text'>('file');
  const [textInput, setTextInput] = useState('');
  
  const [data, setData] = useState<ManaboxRow[]>([]);
  const [columns, setColumns] = useState<string[]>([]);
  
  // On a retir√© 'success' des √©tapes
  const [step, setStep] = useState<'upload' | 'preview' | 'importing'>('upload');
  
  const [progress, setProgress] = useState(0);
  const [statusMsg, setStatusMsg] = useState('');
  const [importMode, setImportMode] = useState<'add' | 'sync'>('add'); 

  // Map pour acc√®s rapide
  const existingMap = useMemo(() => {
    const map = new Map<string, ExistingCard>();
    currentCollection.forEach(card => {
        const key = card.id; 
        map.set(key, card);
    });
    return map;
  }, [currentCollection]);

  // --- FERMETURE ---
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (isOpen && e.key === 'Escape' && step !== 'importing') handleClose();
    };
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [isOpen, step]);

  const handleClose = () => {
    if (step === 'importing') return; 
    onClose();
    // Reset diff√©r√©
    setTimeout(() => {
      setStep('upload');
      setData([]);
      setTextInput('');
      setProgress(0);
    }, 300);
  };

  const handleBackdropClick = (e: React.MouseEvent) => {
    if (e.target === e.currentTarget && step !== 'importing') handleClose();
  };

  if (!isOpen) return null;

  // --- PARSERS ---
  const handleFileUpload = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file) return;

    Papa.parse(file, {
      header: true,
      skipEmptyLines: true,
      delimiter: ",", 
      encoding: "UTF-8",
      complete: (results) => {
        setColumns(results.meta.fields || []);
        setData(results.data as ManaboxRow[]);
        setStep('preview');
      },
      error: (error) => toast.error("Erreur CSV : " + error.message)
    });
  };

  const handleTextParse = () => {
    if (!textInput.trim()) return;

    const rows: ManaboxRow[] = [];
    const lines = textInput.split('\n');
    const regex = /^(\d+)\s+(.+?)\s+\((\w+)\)\s+(\S+)(?:\s+\*(F)\*)?/;

    lines.forEach(line => {
        const cleanLine = line.trim();
        if (!cleanLine) return;
        const match = cleanLine.match(regex);
        if (match) {
            rows.push({
                "Quantity": match[1],
                "Name": match[2],
                "Set code": match[3].toLowerCase(),
                "Collector number": match[4],
                "Foil": match[5] === 'F' ? "true" : "false",
                "Scryfall ID": "", 
                "Binder Name": "Import Texte",
                "Set name": "",
                "Rarity": "",
                "ManaBox ID": "",
                "Purchase price": "0",
                "Language": "en",
                "Condition": "Near Mint"
            });
        }
    });

    if (rows.length === 0) {
        toast.error("Format non reconnu.");
        return;
    }
    setColumns(["Name", "Set code", "Quantity", "Foil", "Collector number"]);
    setData(rows);
    setStep('preview');
  };

  const chunkArray = <T,>(array: T[], size: number): T[][] => {
    const chunks = [];
    for (let i = 0; i < array.length; i += size) {
      chunks.push(array.slice(i, i + size));
    }
    return chunks;
  };

  const getCardInfo = (scryfallCard: ScryfallCard) => {
    let name = scryfallCard.name;
    let imageUrl = scryfallCard.image_uris?.normal;
    let imageBackUrl = null;

    if (scryfallCard.card_faces && scryfallCard.card_faces.length > 1) {
      name = scryfallCard.card_faces[0].name;
      if (!imageUrl && scryfallCard.card_faces[0].image_uris) {
        imageUrl = scryfallCard.card_faces[0].image_uris.normal;
      }
      if (scryfallCard.card_faces[1].image_uris) {
        imageBackUrl = scryfallCard.card_faces[1].image_uris.normal;
      }
    }
    if (!imageUrl) {
        imageUrl = "https://cards.scryfall.io/large/front/a/6/a6984342-f723-4e80-8e69-902d287a915f.jpg";
    }
    return { name, imageUrl, imageBackUrl };
  };

  // --- LOGIQUE IMPORTATION ---
  const startImport = async () => {
    if (!user) return;
    setStep('importing');
    setProgress(0);

    const rowsToFetch: ManaboxRow[] = [];
    const rowsToUpdateDirectly: ManaboxRow[] = [];
    let skippedCount = 0; // On garde le compte en interne juste pour le log si besoin

    data.forEach(row => {
        const scryfallId = row["Scryfall ID"];
        const csvQty = parseInt(row["Quantity"]) || 1;
        const csvFoil = row["Foil"] === "true";
        const existing = scryfallId ? existingMap.get(scryfallId) : undefined;

        if (existing) {
            if (importMode === 'sync') {
                const existingFoil = !!existing.foil;
                if (existing.quantity === csvQty && existingFoil === csvFoil) {
                    skippedCount++;
                } else {
                    rowsToUpdateDirectly.push(row);
                }
            } else {
                if (csvQty > 0) rowsToUpdateDirectly.push(row);
            }
        } else {
            rowsToFetch.push(row);
        }
    });

    let processedCount = skippedCount; 
    let successCount = 0; // Nombre d'√©critures r√©elles

    // 1. UPDATES RAPIDES
    if (rowsToUpdateDirectly.length > 0) {
        setStatusMsg("Mise √† jour rapide...");
        const updateChunks = chunkArray(rowsToUpdateDirectly, 400);

        for (const chunk of updateChunks) {
            const batch = writeBatch(db);
            chunk.forEach(row => {
                const cardRef = doc(db, 'users', user.uid, targetCollection, row["Scryfall ID"]);
                const qtyToAdd = parseInt(row["Quantity"]);
                
                if (importMode === 'sync') {
                    batch.update(cardRef, {
                        quantity: qtyToAdd,
                        foil: row["Foil"] === "true",
                        price: parseFloat(row["Purchase price"]) || 0,
                    });
                } else {
                    batch.update(cardRef, {
                        quantity: increment(qtyToAdd),
                        foil: row["Foil"] === "true",
                        importedAt: new Date()
                    });
                }
                successCount++;
            });
            await batch.commit();
            processedCount += chunk.length;
            setProgress(Math.round((processedCount / data.length) * 100));
        }
    }

    // 2. SCRYFALL + VERIF SECONDAIRE
    if (rowsToFetch.length > 0) {
        setStatusMsg("Identification des cartes...");
        const fetchChunks = chunkArray(rowsToFetch, 75);

        for (const chunk of fetchChunks) {
            try {
                const identifiers = chunk.map(row => {
                    if (row["Scryfall ID"]) return { id: row["Scryfall ID"] };
                    return { name: row["Name"], set: row["Set code"], collector_number: row["Collector number"] };
                });
                
                const response = await fetch('https://api.scryfall.com/cards/collection', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ identifiers })
                });

                const result = await response.json();
                const foundCards: ScryfallCard[] = result.data || [];
                const batch = writeBatch(db);
                let batchHasOps = false;
                
                foundCards.forEach(scryfallData => {
                    const matchingRow = chunk.find(r => 
                        r["Scryfall ID"] === scryfallData.id || 
                        (r["Set code"] === scryfallData.set && r["Collector number"] === scryfallData.collector_number)
                    );

                    if (matchingRow) {
                        const csvQty = parseInt(matchingRow["Quantity"]);
                        const csvFoil = matchingRow["Foil"] === "true";
                        
                        // Verif secondaire
                        const existing = existingMap.get(scryfallData.id);
                        let shouldWrite = true;

                        if (existing && importMode === 'sync') {
                            const existingFoil = !!existing.foil;
                            if (existing.quantity === csvQty && existingFoil === csvFoil) {
                                shouldWrite = false;
                                skippedCount++;
                            }
                        }

                        if (shouldWrite) {
                            const { name, imageUrl, imageBackUrl } = getCardInfo(scryfallData);
                            const cardRef = doc(db, 'users', user.uid, targetCollection, scryfallData.id);
                            
                            const cardData = {
                                name, imageUrl, imageBackUrl,
                                setName: scryfallData.set_name, setCode: scryfallData.set,
                                scryfallId: scryfallData.id,
                                price: parseFloat(scryfallData.prices?.eur || "0"),
                                foil: csvFoil,
                                importedAt: new Date()
                            };

                            if (importMode === 'add') {
                                 batch.set(cardRef, { ...cardData, quantity: increment(csvQty) }, { merge: true });
                            } else {
                                 batch.set(cardRef, { ...cardData, quantity: csvQty }, { merge: true });
                            }
                            successCount++;
                            batchHasOps = true;
                        }
                    }
                });

                if (batchHasOps) {
                    await batch.commit();
                }
                
            } catch (error) {
                console.error("Erreur Scryfall", error);
            }
            processedCount += chunk.length;
            setProgress(Math.round((processedCount / data.length) * 100));
            await new Promise(r => setTimeout(r, 100));
        }
    }

    // --- FIN DE L'OP√âRATION ---
    // On ferme directement et on notifie
    toast.success(`${successCount} cartes synchronis√©e(s) !`, { duration: 4000 });
    handleClose();
  };

  return (
    <div 
      className="fixed inset-0 bg-black/60 flex items-center justify-center z-50 p-4 backdrop-blur-sm"
      onClick={handleBackdropClick}
    >
      <div 
        className="bg-white dark:bg-gray-800 rounded-xl p-6 max-w-5xl w-full shadow-2xl border border-gray-100 dark:border-gray-700 flex flex-col max-h-[90vh]"
        onClick={(e) => e.stopPropagation()}
      >
        {/* HEADER */}
        <div className="flex-none flex justify-between items-center mb-4 border-b border-gray-100 dark:border-gray-700 pb-3">
          <h2 className="text-xl font-bold text-gray-900 dark:text-white">
            Ajouter des cartes
          </h2>
          {step !== 'importing' && (
             <button onClick={handleClose} className="text-gray-500 hover:text-gray-700 text-lg p-2">‚úï</button>
          )}
        </div>

        {/* CONTENT */}
        <div className="flex-grow overflow-hidden flex flex-col min-h-0">
            
            {step === 'upload' && (
                <div className="flex flex-col h-full overflow-hidden">
                    <div className="flex-none flex border-b border-gray-200 dark:border-gray-700 mb-4">
                        <button onClick={() => setInputType('file')} className={`px-4 py-2 font-medium text-sm border-b-2 transition-colors ${inputType === 'file' ? 'border-blue-600 text-blue-600' : 'border-transparent text-gray-500'}`}>üìÇ Fichier CSV</button>
                        <button onClick={() => setInputType('text')} className={`px-4 py-2 font-medium text-sm border-b-2 transition-colors ${inputType === 'text' ? 'border-blue-600 text-blue-600' : 'border-transparent text-gray-500'}`}>üìù Copier / Coller</button>
                    </div>
                    {inputType === 'file' ? (
                        <div className="flex-grow p-12 border-2 border-dashed border-gray-300 dark:border-gray-600 rounded-xl text-center hover:bg-gray-50 dark:hover:bg-gray-700/50 transition relative cursor-pointer group flex flex-col items-center justify-center">
                            <input type="file" accept=".csv" onChange={handleFileUpload} className="absolute inset-0 w-full h-full opacity-0 cursor-pointer z-50" />
                            <div className="text-6xl mb-4 group-hover:scale-110 transition-transform">üìÇ</div>
                            <p className="font-bold text-lg">D√©poser CSV Manabox</p>
                        </div>
                    ) : (
                        <div className="flex-grow flex flex-col min-h-0">
                            <textarea value={textInput} onChange={(e) => setTextInput(e.target.value)} rows={15} placeholder="Collez votre liste ici..." className="flex-grow w-full p-4 rounded-lg border border-gray-300 dark:border-gray-600 bg-gray-50 dark:bg-gray-900 font-mono text-xs focus:ring-2 focus:ring-blue-500 outline-none resize-none" />
                            <button onClick={handleTextParse} disabled={!textInput.trim()} className="flex-none mt-4 bg-blue-600 hover:bg-blue-700 disabled:opacity-50 text-white font-bold py-3 rounded-xl shadow-md transition">Analyser le texte</button>
                        </div>
                    )}
                </div>
            )}

            {step === 'preview' && (
                <div className="flex flex-col h-full overflow-hidden">
                    <div className="flex-none grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                        <div onClick={() => setImportMode('add')} className={`p-3 rounded-xl border-2 cursor-pointer transition flex flex-col gap-1 ${importMode === 'add' ? 'border-blue-500 bg-blue-50 dark:bg-blue-900/20' : 'border-gray-200 dark:border-gray-700 hover:border-blue-300'}`}>
                            <div className="flex items-center gap-2 font-bold text-blue-700 dark:text-blue-300 text-sm">
                                <span className={`w-4 h-4 rounded-full border flex items-center justify-center ${importMode === 'add' ? 'border-blue-600 bg-blue-600' : 'border-gray-400'}`}>{importMode === 'add' && <span className="w-2 h-2 rounded-full bg-white"></span>}</span> Ajouter
                            </div>
                            <p className="text-[10px] text-gray-500 ml-6">Ajoute (+1) aux quantit√©s existantes.</p>
                        </div>
                        <div onClick={() => setImportMode('sync')} className={`p-3 rounded-xl border-2 cursor-pointer transition flex flex-col gap-1 ${importMode === 'sync' ? 'border-purple-500 bg-purple-50 dark:bg-purple-900/20' : 'border-gray-200 dark:border-gray-700 hover:border-purple-300'}`}>
                            <div className="flex items-center gap-2 font-bold text-purple-700 dark:text-purple-300 text-sm">
                                <span className={`w-4 h-4 rounded-full border flex items-center justify-center ${importMode === 'sync' ? 'border-purple-600 bg-purple-600' : 'border-gray-400'}`}>{importMode === 'sync' && <span className="w-2 h-2 rounded-full bg-white"></span>}</span> Synchroniser
                            </div>
                            <p className="text-[10px] text-gray-500 ml-6">Remplace (=1) la quantit√© en base.</p>
                        </div>
                    </div>
                    <div className="flex-none flex justify-between items-center mb-2 px-1">
                        <span className="text-sm font-semibold">{data.length} cartes d√©tect√©es</span>
                        <button onClick={() => { setData([]); setStep('upload'); }} className="text-red-500 text-xs hover:underline">Retour</button>
                    </div>
                    <div className="flex-grow overflow-auto min-h-0 border border-gray-200 dark:border-gray-700 rounded-lg bg-gray-50 dark:bg-gray-900">
                        <table className="w-full text-xs text-left text-gray-500 dark:text-gray-400">
                            <thead className="text-gray-700 bg-gray-200 dark:bg-gray-800 sticky top-0 z-10">
                                <tr>{columns.slice(0,6).map((col, i) => <th key={i} className="px-4 py-2">{col}</th>)}</tr>
                            </thead>
                            <tbody>
                                {data.map((row, i) => (
                                    <tr key={i} className="bg-white border-b dark:bg-gray-800 dark:border-gray-700">
                                        {columns.slice(0,6).map((col, j) => <td key={j} className="px-4 py-1 truncate max-w-[150px]">{row[col as keyof ManaboxRow]}</td>)}
                                    </tr>
                                ))}
                            </tbody>
                        </table>
                    </div>
                    <div className="flex-none pt-4">
                        <button onClick={startImport} className={`w-full text-white font-bold py-3 rounded-xl shadow-lg transition transform hover:-translate-y-0.5 ${importMode === 'add' ? 'bg-blue-600 hover:bg-blue-700' : 'bg-purple-600 hover:bg-purple-700'}`}>
                            {importMode === 'add' ? '‚ûï Valider l\'Ajout' : 'üîÑ Valider la Synchronisation'}
                        </button>
                    </div>
                </div>
            )}

            {step === 'importing' && (
                <div className="flex flex-col items-center justify-center h-full py-10">
                    <div className="text-5xl font-bold text-blue-600 mb-2">{progress}%</div>
                    <p className="text-gray-500 animate-pulse mb-6">{statusMsg}</p>
                    <div className="w-full bg-gray-200 rounded-full h-4 dark:bg-gray-700 overflow-hidden max-w-md">
                        <div className="bg-blue-600 h-full rounded-full transition-all duration-300 ease-out" style={{ width: `${progress}%` }}></div>
                    </div>
                </div>
            )}
        </div>
      </div>
    </div>
  );
}
</file>

</files>
